import {
  __export
} from "./chunk-OL46QLBJ.js";

// node_modules/monaco-editor/esm/vs/nls.js
function _format(message, args) {
  let result;
  if (args.length === 0) {
    result = message;
  } else {
    result = message.replace(/\{(\d+)\}/g, function(match, rest) {
      const index = rest[0];
      return typeof args[index] !== "undefined" ? args[index] : match;
    });
  }
  return result;
}
function localize(data, message, ...args) {
  return _format(message, args);
}

// node_modules/monaco-editor/esm/vs/base/common/platform.js
var _a;
var LANGUAGE_DEFAULT = "en";
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isLinuxSnap = false;
var _isNative = false;
var _isWeb = false;
var _isElectron = false;
var _isIOS = false;
var _isCI = false;
var _locale = void 0;
var _language = LANGUAGE_DEFAULT;
var _translationsConfigFile = void 0;
var _userAgent = void 0;
var globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
var nodeProcess = void 0;
if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
  nodeProcess = globals.vscode.process;
} else if (typeof process !== "undefined") {
  nodeProcess = process;
}
var isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
var isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
if (typeof navigator === "object" && !isElectronRenderer) {
  _userAgent = navigator.userAgent;
  _isWindows = _userAgent.indexOf("Windows") >= 0;
  _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
  _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  _isLinux = _userAgent.indexOf("Linux") >= 0;
  _isWeb = true;
  _locale = navigator.language;
  _language = _locale;
} else if (typeof nodeProcess === "object") {
  _isWindows = nodeProcess.platform === "win32";
  _isMacintosh = nodeProcess.platform === "darwin";
  _isLinux = nodeProcess.platform === "linux";
  _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
  _isElectron = isElectronProcess;
  _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
  _locale = LANGUAGE_DEFAULT;
  _language = LANGUAGE_DEFAULT;
  const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
  if (rawNlsConfig) {
    try {
      const nlsConfig = JSON.parse(rawNlsConfig);
      const resolved = nlsConfig.availableLanguages["*"];
      _locale = nlsConfig.locale;
      _language = resolved ? resolved : LANGUAGE_DEFAULT;
      _translationsConfigFile = nlsConfig._translationsConfigFile;
    } catch (e) {
    }
  }
  _isNative = true;
} else {
  console.error("Unable to resolve platform.");
}
var _platform = 0;
if (_isMacintosh) {
  _platform = 1;
} else if (_isWindows) {
  _platform = 3;
} else if (_isLinux) {
  _platform = 2;
}
var isWindows = _isWindows;
var isMacintosh = _isMacintosh;
var isLinux = _isLinux;
var isNative = _isNative;
var isWeb = _isWeb;
var isWebWorker = _isWeb && typeof globals.importScripts === "function";
var isIOS = _isIOS;
var userAgent = _userAgent;
var setTimeout0 = (() => {
  if (typeof globals.postMessage === "function" && !globals.importScripts) {
    let pending = [];
    globals.addEventListener("message", (e) => {
      if (e.data && e.data.vscodeScheduleAsyncWork) {
        for (let i = 0, len = pending.length; i < len; i++) {
          const candidate = pending[i];
          if (candidate.id === e.data.vscodeScheduleAsyncWork) {
            pending.splice(i, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return (callback) => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback
      });
      globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
    };
  }
  return (callback) => setTimeout(callback);
})();
var OS = _isMacintosh || _isIOS ? 2 : _isWindows ? 1 : 3;
var _isLittleEndian = true;
var _isLittleEndianComputed = false;
function isLittleEndian() {
  if (!_isLittleEndianComputed) {
    _isLittleEndianComputed = true;
    const test = new Uint8Array(2);
    test[0] = 1;
    test[1] = 2;
    const view = new Uint16Array(test.buffer);
    _isLittleEndian = view[0] === (2 << 8) + 1;
  }
  return _isLittleEndian;
}
var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

// node_modules/monaco-editor/esm/vs/base/common/functional.js
function once(fn) {
  const _this = this;
  let didCall = false;
  let result;
  return function() {
    if (didCall) {
      return result;
    }
    didCall = true;
    result = fn.apply(_this, arguments);
    return result;
  };
}

// node_modules/monaco-editor/esm/vs/base/common/iterator.js
var Iterable;
(function(Iterable2) {
  function is(thing) {
    return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
  }
  Iterable2.is = is;
  const _empty2 = Object.freeze([]);
  function empty() {
    return _empty2;
  }
  Iterable2.empty = empty;
  function* single(element) {
    yield element;
  }
  Iterable2.single = single;
  function from(iterable) {
    return iterable || _empty2;
  }
  Iterable2.from = from;
  function isEmpty(iterable) {
    return !iterable || iterable[Symbol.iterator]().next().done === true;
  }
  Iterable2.isEmpty = isEmpty;
  function first(iterable) {
    return iterable[Symbol.iterator]().next().value;
  }
  Iterable2.first = first;
  function some(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return true;
      }
    }
    return false;
  }
  Iterable2.some = some;
  function find(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return element;
      }
    }
    return void 0;
  }
  Iterable2.find = find;
  function* filter(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        yield element;
      }
    }
  }
  Iterable2.filter = filter;
  function* map(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
      yield fn(element, index++);
    }
  }
  Iterable2.map = map;
  function* concat2(...iterables) {
    for (const iterable of iterables) {
      for (const element of iterable) {
        yield element;
      }
    }
  }
  Iterable2.concat = concat2;
  function* concatNested(iterables) {
    for (const iterable of iterables) {
      for (const element of iterable) {
        yield element;
      }
    }
  }
  Iterable2.concatNested = concatNested;
  function reduce(iterable, reducer, initialValue) {
    let value = initialValue;
    for (const element of iterable) {
      value = reducer(value, element);
    }
    return value;
  }
  Iterable2.reduce = reduce;
  function* slice(arr, from2, to = arr.length) {
    if (from2 < 0) {
      from2 += arr.length;
    }
    if (to < 0) {
      to += arr.length;
    } else if (to > arr.length) {
      to = arr.length;
    }
    for (; from2 < to; from2++) {
      yield arr[from2];
    }
  }
  Iterable2.slice = slice;
  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
    const consumed = [];
    if (atMost === 0) {
      return [consumed, iterable];
    }
    const iterator = iterable[Symbol.iterator]();
    for (let i = 0; i < atMost; i++) {
      const next = iterator.next();
      if (next.done) {
        return [consumed, Iterable2.empty()];
      }
      consumed.push(next.value);
    }
    return [consumed, { [Symbol.iterator]() {
      return iterator;
    } }];
  }
  Iterable2.consume = consume;
  function equals3(a, b, comparator = (at, bt) => at === bt) {
    const ai = a[Symbol.iterator]();
    const bi = b[Symbol.iterator]();
    while (true) {
      const an = ai.next();
      const bn = bi.next();
      if (an.done !== bn.done) {
        return false;
      } else if (an.done) {
        return true;
      } else if (!comparator(an.value, bn.value)) {
        return false;
      }
    }
  }
  Iterable2.equals = equals3;
})(Iterable || (Iterable = {}));

// node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
var TRACK_DISPOSABLES = false;
var disposableTracker = null;
function setDisposableTracker(tracker) {
  disposableTracker = tracker;
}
if (TRACK_DISPOSABLES) {
  const __is_disposable_tracked__ = "__is_disposable_tracked__";
  setDisposableTracker(new class {
    trackDisposable(x) {
      const stack = new Error("Potentially leaked disposable").stack;
      setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
          console.log(stack);
        }
      }, 3e3);
    }
    setParent(child, parent) {
      if (child && child !== Disposable.None) {
        try {
          child[__is_disposable_tracked__] = true;
        } catch (_a3) {
        }
      }
    }
    markAsDisposed(disposable) {
      if (disposable && disposable !== Disposable.None) {
        try {
          disposable[__is_disposable_tracked__] = true;
        } catch (_a3) {
        }
      }
    }
    markAsSingleton(disposable) {
    }
  }());
}
function trackDisposable(x) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
  return x;
}
function markAsDisposed(disposable) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
  if (!disposableTracker) {
    return;
  }
  for (const child of children) {
    disposableTracker.setParent(child, parent);
  }
}
function markAsSingleton(singleton) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);
  return singleton;
}
var MultiDisposeError = class extends Error {
  constructor(errors) {
    super(`Encountered errors while disposing of store. Errors: [${errors.join(", ")}]`);
    this.errors = errors;
  }
};
function isDisposable(thing) {
  return typeof thing.dispose === "function" && thing.dispose.length === 0;
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    let errors = [];
    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch (e) {
          errors.push(e);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      throw new MultiDisposeError(errors);
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function combinedDisposable(...disposables) {
  const parent = toDisposable(() => dispose(disposables));
  setParentOfDisposables(disposables, parent);
  return parent;
}
function toDisposable(fn) {
  const self2 = trackDisposable({
    dispose: once(() => {
      markAsDisposed(self2);
      fn();
    })
  });
  return self2;
}
var DisposableStore = class _DisposableStore {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set();
    this._isDisposed = false;
    trackDisposable(this);
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    markAsDisposed(this);
    this._isDisposed = true;
    this.clear();
  }
  /**
   * Returns `true` if this object has been disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    try {
      dispose(this._toDispose.values());
    } finally {
      this._toDispose.clear();
    }
  }
  add(o) {
    if (!o) {
      return o;
    }
    if (o === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    setParentOfDisposable(o, this);
    if (this._isDisposed) {
      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
      }
    } else {
      this._toDispose.add(o);
    }
    return o;
  }
};
DisposableStore.DISABLE_DISPOSED_WARNING = false;
var Disposable = class {
  constructor() {
    this._store = new DisposableStore();
    trackDisposable(this);
    setParentOfDisposable(this._store, this);
  }
  dispose() {
    markAsDisposed(this);
    this._store.dispose();
  }
  _register(o) {
    if (o === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    return this._store.add(o);
  }
};
Disposable.None = Object.freeze({ dispose() {
} });
var MutableDisposable = class {
  constructor() {
    this._isDisposed = false;
    trackDisposable(this);
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(value) {
    var _a3;
    if (this._isDisposed || value === this._value) {
      return;
    }
    (_a3 = this._value) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    if (value) {
      setParentOfDisposable(value, this);
    }
    this._value = value;
  }
  clear() {
    this.value = void 0;
  }
  dispose() {
    var _a3;
    this._isDisposed = true;
    markAsDisposed(this);
    (_a3 = this._value) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    this._value = void 0;
  }
  /**
   * Clears the value, but does not dispose it.
   * The old value is returned.
  */
  clearAndLeak() {
    const oldValue = this._value;
    this._value = void 0;
    if (oldValue) {
      setParentOfDisposable(oldValue, null);
    }
    return oldValue;
  }
};
var SafeDisposable = class {
  constructor() {
    this.dispose = () => {
    };
    this.unset = () => {
    };
    this.isset = () => false;
    trackDisposable(this);
  }
  set(fn) {
    let callback = fn;
    this.unset = () => callback = void 0;
    this.isset = () => callback !== void 0;
    this.dispose = () => {
      if (callback) {
        callback();
        callback = void 0;
        markAsDisposed(this);
      }
    };
    return this;
  }
};
var ImmortalReference = class {
  constructor(object) {
    this.object = object;
  }
  dispose() {
  }
};

// node_modules/monaco-editor/esm/vs/base/common/cache.js
var LRUCachedComputed = class {
  constructor(computeFn) {
    this.computeFn = computeFn;
    this.lastCache = void 0;
    this.lastArgKey = void 0;
  }
  get(arg) {
    const key = JSON.stringify(arg);
    if (this.lastArgKey !== key) {
      this.lastArgKey = key;
      this.lastCache = this.computeFn(arg);
    }
    return this.lastCache;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy = class {
  constructor(executor) {
    this.executor = executor;
    this._didRun = false;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  getValue() {
    if (!this._didRun) {
      try {
        this._value = this.executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/strings.js
var _a2;
function isFalsyOrWhitespace(str) {
  if (!str || typeof str !== "string") {
    return true;
  }
  return str.trim().length === 0;
}
var _formatRegexp = /{(\d+)}/g;
function format(value, ...args) {
  if (args.length === 0) {
    return value;
  }
  return value.replace(_formatRegexp, function(match, group) {
    const idx = parseInt(group, 10);
    return isNaN(idx) || idx < 0 || idx >= args.length ? match : args[idx];
  });
}
function escape(html) {
  return html.replace(/[<>&]/g, function(match) {
    switch (match) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return match;
    }
  });
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function ltrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length;
  if (needleLen === 0 || haystack.length === 0) {
    return haystack;
  }
  let offset = 0;
  while (haystack.indexOf(needle, offset) === offset) {
    offset = offset + needleLen;
  }
  return haystack.substring(offset);
}
function rtrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }
  const needleLen = needle.length, haystackLen = haystack.length;
  if (needleLen === 0 || haystackLen === 0) {
    return haystack;
  }
  let offset = haystackLen, idx = -1;
  while (true) {
    idx = haystack.lastIndexOf(needle, offset - 1);
    if (idx === -1 || idx + needleLen !== offset) {
      break;
    }
    if (idx === 0) {
      return "";
    }
    offset = idx;
  }
  return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
  return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function createRegExp(searchString, isRegex, options = {}) {
  if (!searchString) {
    throw new Error("Cannot create regex from empty string");
  }
  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }
  if (options.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = "\\b" + searchString;
    }
    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + "\\b";
    }
  }
  let modifiers = "";
  if (options.global) {
    modifiers += "g";
  }
  if (!options.matchCase) {
    modifiers += "i";
  }
  if (options.multiline) {
    modifiers += "m";
  }
  if (options.unicode) {
    modifiers += "u";
  }
  return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
  if (regexp.source === "^" || regexp.source === "^$" || regexp.source === "$" || regexp.source === "^\\s*$") {
    return false;
  }
  const match = regexp.exec("");
  return !!(match && regexp.lastIndex === 0);
}
function regExpFlags(regexp) {
  return (regexp.global ? "g" : "") + (regexp.ignoreCase ? "i" : "") + (regexp.multiline ? "m" : "") + (regexp.unicode ? "u" : "");
}
function splitLines(str) {
  return str.split(/\r\n|\r|\n/);
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function getLeadingWhitespace(str, start = 0, end = str.length) {
  for (let i = start; i < end; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return str.substring(start, i);
    }
  }
  return str.substring(start, end);
}
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function compare(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function compareIgnoreCase(a, b) {
  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);
    if (codeA === codeB) {
      continue;
    }
    if (codeA >= 128 || codeB >= 128) {
      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    }
    if (isLowerAsciiLetter(codeA)) {
      codeA -= 32;
    }
    if (isLowerAsciiLetter(codeB)) {
      codeB -= 32;
    }
    const diff = codeA - codeB;
    if (diff === 0) {
      continue;
    }
    return diff;
  }
  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;
  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }
  return 0;
}
function isLowerAsciiLetter(code) {
  return code >= 97 && code <= 122;
}
function isUpperAsciiLetter(code) {
  return code >= 65 && code <= 90;
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
  const candidateLength = candidate.length;
  if (candidate.length > str.length) {
    return false;
  }
  return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
function commonPrefixLength(a, b) {
  let i, len = Math.min(a.length, b.length);
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) {
      return i;
    }
  }
  return len;
}
function commonSuffixLength(a, b) {
  let i, len = Math.min(a.length, b.length);
  const aLastIndex = a.length - 1;
  const bLastIndex = b.length - 1;
  for (i = 0; i < len; i++) {
    if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
      return i;
    }
  }
  return len;
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
function getPrevCodePoint(str, offset) {
  const charCode = str.charCodeAt(offset - 1);
  if (isLowSurrogate(charCode) && offset > 1) {
    const prevCharCode = str.charCodeAt(offset - 2);
    if (isHighSurrogate(prevCharCode)) {
      return computeCodePoint(prevCharCode, charCode);
    }
  }
  return charCode;
}
var CodePointIterator = class {
  constructor(str, offset = 0) {
    this._str = str;
    this._len = str.length;
    this._offset = offset;
  }
  get offset() {
    return this._offset;
  }
  setOffset(offset) {
    this._offset = offset;
  }
  prevCodePoint() {
    const codePoint = getPrevCodePoint(this._str, this._offset);
    this._offset -= codePoint >= 65536 ? 2 : 1;
    return codePoint;
  }
  nextCodePoint() {
    const codePoint = getNextCodePoint(this._str, this._len, this._offset);
    this._offset += codePoint >= 65536 ? 2 : 1;
    return codePoint;
  }
  eol() {
    return this._offset >= this._len;
  }
};
var GraphemeIterator = class {
  constructor(str, offset = 0) {
    this._iterator = new CodePointIterator(str, offset);
  }
  get offset() {
    return this._iterator.offset;
  }
  nextGraphemeLength() {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const iterator = this._iterator;
    const initialOffset = iterator.offset;
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
    while (!iterator.eol()) {
      const offset = iterator.offset;
      const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
      if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
        iterator.setOffset(offset);
        break;
      }
      graphemeBreakType = nextGraphemeBreakType;
    }
    return iterator.offset - initialOffset;
  }
  prevGraphemeLength() {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const iterator = this._iterator;
    const initialOffset = iterator.offset;
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
    while (iterator.offset > 0) {
      const offset = iterator.offset;
      const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
      if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
        iterator.setOffset(offset);
        break;
      }
      graphemeBreakType = prevGraphemeBreakType;
    }
    return initialOffset - iterator.offset;
  }
  eol() {
    return this._iterator.eol();
  }
};
function nextCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.nextGraphemeLength();
}
function prevCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.prevGraphemeLength();
}
function getCharContainingOffset(str, offset) {
  if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {
    offset--;
  }
  const endOffset = offset + nextCharLength(str, offset);
  const startOffset = endOffset - prevCharLength(str, endOffset);
  return [startOffset, endOffset];
}
var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
function containsRTL(str) {
  return CONTAINS_RTL.test(str);
}
var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
var UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/;
function containsUnusualLineTerminators(str) {
  return UNUSUAL_LINE_TERMINATORS.test(str);
}
function isFullWidthCharacter(charCode) {
  return charCode >= 11904 && charCode <= 55215 || charCode >= 63744 && charCode <= 64255 || charCode >= 65281 && charCode <= 65374;
}
function isEmojiImprecise(x) {
  return x >= 127462 && x <= 127487 || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
var UTF8_BOM_CHARACTER = String.fromCharCode(
  65279
  /* UTF8_BOM */
);
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === 65279);
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
  if (!target) {
    return false;
  }
  if (ignoreEscapedChars) {
    target = target.replace(/\\./g, "");
  }
  return target.toLowerCase() !== target;
}
function singleLetterHash(n) {
  const LETTERS_CNT = 90 - 65 + 1;
  n = n % (2 * LETTERS_CNT);
  if (n < LETTERS_CNT) {
    return String.fromCharCode(97 + n);
  }
  return String.fromCharCode(65 + n - LETTERS_CNT);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
  if (breakTypeA === 0) {
    return breakTypeB !== 5 && breakTypeB !== 7;
  }
  if (breakTypeA === 2) {
    if (breakTypeB === 3) {
      return false;
    }
  }
  if (breakTypeA === 4 || breakTypeA === 2 || breakTypeA === 3) {
    return true;
  }
  if (breakTypeB === 4 || breakTypeB === 2 || breakTypeB === 3) {
    return true;
  }
  if (breakTypeA === 8) {
    if (breakTypeB === 8 || breakTypeB === 9 || breakTypeB === 11 || breakTypeB === 12) {
      return false;
    }
  }
  if (breakTypeA === 11 || breakTypeA === 9) {
    if (breakTypeB === 9 || breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeA === 12 || breakTypeA === 10) {
    if (breakTypeB === 10) {
      return false;
    }
  }
  if (breakTypeB === 5 || breakTypeB === 13) {
    return false;
  }
  if (breakTypeB === 7) {
    return false;
  }
  if (breakTypeA === 1) {
    return false;
  }
  if (breakTypeA === 13 && breakTypeB === 14) {
    return false;
  }
  if (breakTypeA === 6 && breakTypeB === 6) {
    return false;
  }
  return true;
}
var GraphemeBreakTree = class _GraphemeBreakTree {
  constructor() {
    this._data = getGraphemeBreakRawData();
  }
  static getInstance() {
    if (!_GraphemeBreakTree._INSTANCE) {
      _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
    }
    return _GraphemeBreakTree._INSTANCE;
  }
  getGraphemeBreakType(codePoint) {
    if (codePoint < 32) {
      if (codePoint === 10) {
        return 3;
      }
      if (codePoint === 13) {
        return 2;
      }
      return 4;
    }
    if (codePoint < 127) {
      return 0;
    }
    const data = this._data;
    const nodeCount = data.length / 3;
    let nodeIndex = 1;
    while (nodeIndex <= nodeCount) {
      if (codePoint < data[3 * nodeIndex]) {
        nodeIndex = 2 * nodeIndex;
      } else if (codePoint > data[3 * nodeIndex + 1]) {
        nodeIndex = 2 * nodeIndex + 1;
      } else {
        return data[3 * nodeIndex + 2];
      }
    }
    return 0;
  }
};
GraphemeBreakTree._INSTANCE = null;
function getGraphemeBreakRawData() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function getLeftDeleteOffset(offset, str) {
  if (offset === 0) {
    return 0;
  }
  const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);
  if (emojiOffset !== void 0) {
    return emojiOffset;
  }
  const iterator = new CodePointIterator(str, offset);
  iterator.prevCodePoint();
  return iterator.offset;
}
function getOffsetBeforeLastEmojiComponent(initialOffset, str) {
  const iterator = new CodePointIterator(str, initialOffset);
  let codePoint = iterator.prevCodePoint();
  while (isEmojiModifier(codePoint) || codePoint === 65039 || codePoint === 8419) {
    if (iterator.offset === 0) {
      return void 0;
    }
    codePoint = iterator.prevCodePoint();
  }
  if (!isEmojiImprecise(codePoint)) {
    return void 0;
  }
  let resultOffset = iterator.offset;
  if (resultOffset > 0) {
    const optionalZwjCodePoint = iterator.prevCodePoint();
    if (optionalZwjCodePoint === 8205) {
      resultOffset = iterator.offset;
    }
  }
  return resultOffset;
}
function isEmojiModifier(codePoint) {
  return 127995 <= codePoint && codePoint <= 127999;
}
var AmbiguousCharacters = class _AmbiguousCharacters {
  constructor(confusableDictionary) {
    this.confusableDictionary = confusableDictionary;
  }
  static getInstance(locales) {
    return _AmbiguousCharacters.cache.get(Array.from(locales));
  }
  static getLocales() {
    return _AmbiguousCharacters._locales.getValue();
  }
  isAmbiguous(codePoint) {
    return this.confusableDictionary.has(codePoint);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(codePoint) {
    return this.confusableDictionary.get(codePoint);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
_a2 = AmbiguousCharacters;
AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
  return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
});
AmbiguousCharacters.cache = new LRUCachedComputed((locales) => {
  function arrayToMap(arr) {
    const result = /* @__PURE__ */ new Map();
    for (let i = 0; i < arr.length; i += 2) {
      result.set(arr[i], arr[i + 1]);
    }
    return result;
  }
  function mergeMaps(map1, map2) {
    const result = new Map(map1);
    for (const [key, value] of map2) {
      result.set(key, value);
    }
    return result;
  }
  function intersectMaps(map1, map2) {
    if (!map1) {
      return map2;
    }
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of map1) {
      if (map2.has(key)) {
        result.set(key, value);
      }
    }
    return result;
  }
  const data = _a2.ambiguousCharacterData.getValue();
  let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
  if (filteredLocales.length === 0) {
    filteredLocales = ["_default"];
  }
  let languageSpecificMap = void 0;
  for (const locale of filteredLocales) {
    const map2 = arrayToMap(data[locale]);
    languageSpecificMap = intersectMaps(languageSpecificMap, map2);
  }
  const commonMap = arrayToMap(data["_common"]);
  const map = mergeMaps(commonMap, languageSpecificMap);
  return new AmbiguousCharacters(map);
});
AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter((k) => !k.startsWith("_")));
var InvisibleCharacters = class _InvisibleCharacters {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static getData() {
    if (!this._data) {
      this._data = new Set(_InvisibleCharacters.getRawData());
    }
    return this._data;
  }
  static isInvisibleCharacter(codePoint) {
    return _InvisibleCharacters.getData().has(codePoint);
  }
  static get codePoints() {
    return _InvisibleCharacters.getData();
  }
};
InvisibleCharacters._data = void 0;

// node_modules/monaco-editor/esm/vs/base/common/errors.js
var ErrorHandler = class {
  constructor() {
    this.listeners = [];
    this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        if (e.stack) {
          throw new Error(e.message + "\n\n" + e.stack);
        }
        throw e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((listener) => {
      listener(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e);
    this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
};
var errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedError(e);
  }
  return void 0;
}
function onUnexpectedExternalError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }
  return void 0;
}
function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    let { name, message } = error;
    const stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name,
      message,
      stack
    };
  }
  return error;
}
var canceledName = "Canceled";
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
var CancellationError = class extends Error {
  constructor() {
    super(canceledName);
    this.name = this.message;
  }
};
function canceled() {
  const error = new Error(canceledName);
  error.name = error.message;
  return error;
}
function illegalArgument(name) {
  if (name) {
    return new Error(`Illegal argument: ${name}`);
  } else {
    return new Error("Illegal argument");
  }
}
function illegalState(name) {
  if (name) {
    return new Error(`Illegal state: ${name}`);
  } else {
    return new Error("Illegal state");
  }
}
var NotSupportedError = class extends Error {
  constructor(message) {
    super("NotSupported");
    if (message) {
      this.message = message;
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/common/linkedList.js
var Node2 = class _Node {
  constructor(element) {
    this.element = element;
    this.next = _Node.Undefined;
    this.prev = _Node.Undefined;
  }
};
Node2.Undefined = new Node2(void 0);
var LinkedList = class {
  constructor() {
    this._first = Node2.Undefined;
    this._last = Node2.Undefined;
    this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Node2.Undefined;
  }
  clear() {
    let node = this._first;
    while (node !== Node2.Undefined) {
      const next = node.next;
      node.prev = Node2.Undefined;
      node.next = Node2.Undefined;
      node = next;
    }
    this._first = Node2.Undefined;
    this._last = Node2.Undefined;
    this._size = 0;
  }
  unshift(element) {
    return this._insert(element, false);
  }
  push(element) {
    return this._insert(element, true);
  }
  _insert(element, atTheEnd) {
    const newNode = new Node2(element);
    if (this._first === Node2.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atTheEnd) {
      const oldLast = this._last;
      this._last = newNode;
      newNode.prev = oldLast;
      oldLast.next = newNode;
    } else {
      const oldFirst = this._first;
      this._first = newNode;
      newNode.next = oldFirst;
      oldFirst.prev = newNode;
    }
    this._size += 1;
    let didRemove = false;
    return () => {
      if (!didRemove) {
        didRemove = true;
        this._remove(newNode);
      }
    };
  }
  shift() {
    if (this._first === Node2.Undefined) {
      return void 0;
    } else {
      const res = this._first.element;
      this._remove(this._first);
      return res;
    }
  }
  pop() {
    if (this._last === Node2.Undefined) {
      return void 0;
    } else {
      const res = this._last.element;
      this._remove(this._last);
      return res;
    }
  }
  _remove(node) {
    if (node.prev !== Node2.Undefined && node.next !== Node2.Undefined) {
      const anchor = node.prev;
      anchor.next = node.next;
      node.next.prev = anchor;
    } else if (node.prev === Node2.Undefined && node.next === Node2.Undefined) {
      this._first = Node2.Undefined;
      this._last = Node2.Undefined;
    } else if (node.next === Node2.Undefined) {
      this._last = this._last.prev;
      this._last.next = Node2.Undefined;
    } else if (node.prev === Node2.Undefined) {
      this._first = this._first.next;
      this._first.prev = Node2.Undefined;
    }
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let node = this._first;
    while (node !== Node2.Undefined) {
      yield node.element;
      node = node.next;
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
var hasPerformanceNow = globals.performance && typeof globals.performance.now === "function";
var StopWatch = class _StopWatch {
  constructor(highResolution) {
    this._highResolution = hasPerformanceNow && highResolution;
    this._startTime = this._now();
    this._stopTime = -1;
  }
  static create(highResolution = true) {
    return new _StopWatch(highResolution);
  }
  stop() {
    this._stopTime = this._now();
  }
  elapsed() {
    if (this._stopTime !== -1) {
      return this._stopTime - this._startTime;
    }
    return this._now() - this._startTime;
  }
  _now() {
    return this._highResolution ? globals.performance.now() : Date.now();
  }
};

// node_modules/monaco-editor/esm/vs/base/common/event.js
var _enableDisposeWithListenerWarning = false;
var _enableSnapshotPotentialLeakWarning = false;
var Event;
(function(Event2) {
  Event2.None = () => Disposable.None;
  function _addLeakageTraceLogic(options) {
    if (_enableSnapshotPotentialLeakWarning) {
      const { onListenerDidAdd: origListenerDidAdd } = options;
      const stack = Stacktrace.create();
      let count = 0;
      options.onListenerDidAdd = () => {
        if (++count === 2) {
          console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
          stack.print();
        }
        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
      };
    }
  }
  function once3(event) {
    return (listener, thisArgs = null, disposables) => {
      let didFire = false;
      let result;
      result = event((e) => {
        if (didFire) {
          return;
        } else if (result) {
          result.dispose();
        } else {
          didFire = true;
        }
        return listener.call(thisArgs, e);
      }, null, disposables);
      if (didFire) {
        result.dispose();
      }
      return result;
    };
  }
  Event2.once = once3;
  function map(event, map2, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
  }
  Event2.map = map;
  function forEach(event, each, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => {
      each(i);
      listener.call(thisArgs, i);
    }, null, disposables), disposable);
  }
  Event2.forEach = forEach;
  function filter(event, filter2, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
  }
  Event2.filter = filter;
  function signal(event) {
    return event;
  }
  Event2.signal = signal;
  function any(...events) {
    return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
  }
  Event2.any = any;
  function reduce(event, merge, initial, disposable) {
    let output = initial;
    return map(event, (e) => {
      output = merge(output, e);
      return output;
    }, disposable);
  }
  Event2.reduce = reduce;
  function snapshot(event, disposable) {
    let listener;
    const options = {
      onFirstListenerAdd() {
        listener = event(emitter.fire, emitter);
      },
      onLastListenerRemove() {
        listener.dispose();
      }
    };
    if (!disposable) {
      _addLeakageTraceLogic(options);
    }
    const emitter = new Emitter(options);
    if (disposable) {
      disposable.add(emitter);
    }
    return emitter.event;
  }
  function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {
    let subscription;
    let output = void 0;
    let handle = void 0;
    let numDebouncedCalls = 0;
    const options = {
      leakWarningThreshold,
      onFirstListenerAdd() {
        subscription = event((cur) => {
          numDebouncedCalls++;
          output = merge(output, cur);
          if (leading && !handle) {
            emitter.fire(output);
            output = void 0;
          }
          clearTimeout(handle);
          handle = setTimeout(() => {
            const _output = output;
            output = void 0;
            handle = void 0;
            if (!leading || numDebouncedCalls > 1) {
              emitter.fire(_output);
            }
            numDebouncedCalls = 0;
          }, delay);
        });
      },
      onLastListenerRemove() {
        subscription.dispose();
      }
    };
    if (!disposable) {
      _addLeakageTraceLogic(options);
    }
    const emitter = new Emitter(options);
    if (disposable) {
      disposable.add(emitter);
    }
    return emitter.event;
  }
  Event2.debounce = debounce;
  function latch(event, equals3 = (a, b) => a === b, disposable) {
    let firstCall = true;
    let cache;
    return filter(event, (value) => {
      const shouldEmit = firstCall || !equals3(value, cache);
      firstCall = false;
      cache = value;
      return shouldEmit;
    }, disposable);
  }
  Event2.latch = latch;
  function split(event, isT, disposable) {
    return [
      Event2.filter(event, isT, disposable),
      Event2.filter(event, (e) => !isT(e), disposable)
    ];
  }
  Event2.split = split;
  function buffer(event, flushAfterTimeout = false, _buffer = []) {
    let buffer2 = _buffer.slice();
    let listener = event((e) => {
      if (buffer2) {
        buffer2.push(e);
      } else {
        emitter.fire(e);
      }
    });
    const flush = () => {
      if (buffer2) {
        buffer2.forEach((e) => emitter.fire(e));
      }
      buffer2 = null;
    };
    const emitter = new Emitter({
      onFirstListenerAdd() {
        if (!listener) {
          listener = event((e) => emitter.fire(e));
        }
      },
      onFirstListenerDidAdd() {
        if (buffer2) {
          if (flushAfterTimeout) {
            setTimeout(flush);
          } else {
            flush();
          }
        }
      },
      onLastListenerRemove() {
        if (listener) {
          listener.dispose();
        }
        listener = null;
      }
    });
    return emitter.event;
  }
  Event2.buffer = buffer;
  class ChainableEvent {
    constructor(event) {
      this.event = event;
    }
    map(fn) {
      return new ChainableEvent(map(this.event, fn));
    }
    forEach(fn) {
      return new ChainableEvent(forEach(this.event, fn));
    }
    filter(fn) {
      return new ChainableEvent(filter(this.event, fn));
    }
    reduce(merge, initial) {
      return new ChainableEvent(reduce(this.event, merge, initial));
    }
    latch() {
      return new ChainableEvent(latch(this.event));
    }
    debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
    }
    on(listener, thisArgs, disposables) {
      return this.event(listener, thisArgs, disposables);
    }
    once(listener, thisArgs, disposables) {
      return once3(this.event)(listener, thisArgs, disposables);
    }
  }
  function chain(event) {
    return new ChainableEvent(event);
  }
  Event2.chain = chain;
  function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
    const fn = (...args) => result.fire(map2(...args));
    const onFirstListenerAdd = () => emitter.on(eventName, fn);
    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
    const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
    return result.event;
  }
  Event2.fromNodeEventEmitter = fromNodeEventEmitter;
  function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
    const fn = (...args) => result.fire(map2(...args));
    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
    const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
    return result.event;
  }
  Event2.fromDOMEventEmitter = fromDOMEventEmitter;
  function toPromise(event) {
    return new Promise((resolve2) => once3(event)(resolve2));
  }
  Event2.toPromise = toPromise;
  function runAndSubscribe(event, handler) {
    handler(void 0);
    return event((e) => handler(e));
  }
  Event2.runAndSubscribe = runAndSubscribe;
  function runAndSubscribeWithStore(event, handler) {
    let store = null;
    function run(e) {
      store === null || store === void 0 ? void 0 : store.dispose();
      store = new DisposableStore();
      handler(e, store);
    }
    run(void 0);
    const disposable = event((e) => run(e));
    return toDisposable(() => {
      disposable.dispose();
      store === null || store === void 0 ? void 0 : store.dispose();
    });
  }
  Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
})(Event || (Event = {}));
var EventProfiling = class _EventProfiling {
  constructor(name) {
    this._listenerCount = 0;
    this._invocationCount = 0;
    this._elapsedOverall = 0;
    this._name = `${name}_${_EventProfiling._idPool++}`;
  }
  start(listenerCount) {
    this._stopWatch = new StopWatch(true);
    this._listenerCount = listenerCount;
  }
  stop() {
    if (this._stopWatch) {
      const elapsed = this._stopWatch.elapsed();
      this._elapsedOverall += elapsed;
      this._invocationCount += 1;
      console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);
      this._stopWatch = void 0;
    }
  }
};
EventProfiling._idPool = 0;
var _globalLeakWarningThreshold = -1;
var LeakageMonitor = class {
  constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
    this.customThreshold = customThreshold;
    this.name = name;
    this._warnCountdown = 0;
  }
  dispose() {
    if (this._stacks) {
      this._stacks.clear();
    }
  }
  check(stack, listenerCount) {
    let threshold = _globalLeakWarningThreshold;
    if (typeof this.customThreshold === "number") {
      threshold = this.customThreshold;
    }
    if (threshold <= 0 || listenerCount < threshold) {
      return void 0;
    }
    if (!this._stacks) {
      this._stacks = /* @__PURE__ */ new Map();
    }
    const count = this._stacks.get(stack.value) || 0;
    this._stacks.set(stack.value, count + 1);
    this._warnCountdown -= 1;
    if (this._warnCountdown <= 0) {
      this._warnCountdown = threshold * 0.5;
      let topStack;
      let topCount = 0;
      for (const [stack2, count2] of this._stacks) {
        if (!topStack || topCount < count2) {
          topStack = stack2;
          topCount = count2;
        }
      }
      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
      console.warn(topStack);
    }
    return () => {
      const count2 = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count2 - 1);
    };
  }
};
var Stacktrace = class _Stacktrace {
  constructor(value) {
    this.value = value;
  }
  static create() {
    var _a3;
    return new _Stacktrace((_a3 = new Error().stack) !== null && _a3 !== void 0 ? _a3 : "");
  }
  print() {
    console.warn(this.value.split("\n").slice(2).join("\n"));
  }
};
var Listener = class {
  constructor(callback, callbackThis, stack) {
    this.callback = callback;
    this.callbackThis = callbackThis;
    this.stack = stack;
    this.subscription = new SafeDisposable();
  }
  invoke(e) {
    this.callback.call(this.callbackThis, e);
  }
};
var Emitter = class {
  constructor(options) {
    var _a3;
    this._disposed = false;
    this._options = options;
    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : void 0;
    this._perfMon = ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3._profName) ? new EventProfiling(this._options._profName) : void 0;
  }
  dispose() {
    var _a3, _b, _c, _d;
    if (!this._disposed) {
      this._disposed = true;
      if (this._listeners) {
        if (_enableDisposeWithListenerWarning) {
          const listeners = Array.from(this._listeners);
          queueMicrotask(() => {
            var _a4;
            for (const listener of listeners) {
              if (listener.subscription.isset()) {
                listener.subscription.unset();
                (_a4 = listener.stack) === null || _a4 === void 0 ? void 0 : _a4.print();
              }
            }
          });
        }
        this._listeners.clear();
      }
      (_a3 = this._deliveryQueue) === null || _a3 === void 0 ? void 0 : _a3.clear();
      (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);
      (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    if (!this._event) {
      this._event = (callback, thisArgs, disposables) => {
        var _a3, _b, _c;
        if (!this._listeners) {
          this._listeners = new LinkedList();
        }
        const firstListener = this._listeners.isEmpty();
        if (firstListener && ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.onFirstListenerAdd)) {
          this._options.onFirstListenerAdd(this);
        }
        let removeMonitor;
        let stack;
        if (this._leakageMon && this._listeners.size >= 30) {
          stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
        }
        if (_enableDisposeWithListenerWarning) {
          stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
        }
        const listener = new Listener(callback, thisArgs, stack);
        const removeListener = this._listeners.push(listener);
        if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {
          this._options.onFirstListenerDidAdd(this);
        }
        if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {
          this._options.onListenerDidAdd(this, callback, thisArgs);
        }
        const result = listener.subscription.set(() => {
          if (removeMonitor) {
            removeMonitor();
          }
          if (!this._disposed) {
            removeListener();
            if (this._options && this._options.onLastListenerRemove) {
              const hasListeners = this._listeners && !this._listeners.isEmpty();
              if (!hasListeners) {
                this._options.onLastListenerRemove(this);
              }
            }
          }
        });
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        return result;
      };
    }
    return this._event;
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(event) {
    var _a3, _b;
    if (this._listeners) {
      if (!this._deliveryQueue) {
        this._deliveryQueue = new LinkedList();
      }
      for (let listener of this._listeners) {
        this._deliveryQueue.push([listener, event]);
      }
      (_a3 = this._perfMon) === null || _a3 === void 0 ? void 0 : _a3.start(this._deliveryQueue.size);
      while (this._deliveryQueue.size > 0) {
        const [listener, event2] = this._deliveryQueue.shift();
        try {
          listener.invoke(event2);
        } catch (e) {
          onUnexpectedError(e);
        }
      }
      (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();
    }
  }
};
var PauseableEmitter = class extends Emitter {
  constructor(options) {
    super(options);
    this._isPaused = 0;
    this._eventQueue = new LinkedList();
    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0) {
      if (this._mergeFn) {
        const events = Array.from(this._eventQueue);
        this._eventQueue.clear();
        super.fire(this._mergeFn(events));
      } else {
        while (!this._isPaused && this._eventQueue.size !== 0) {
          super.fire(this._eventQueue.shift());
        }
      }
    }
  }
  fire(event) {
    if (this._listeners) {
      if (this._isPaused !== 0) {
        this._eventQueue.push(event);
      } else {
        super.fire(event);
      }
    }
  }
};
var DebounceEmitter = class extends PauseableEmitter {
  constructor(options) {
    var _a3;
    super(options);
    this._delay = (_a3 = options.delay) !== null && _a3 !== void 0 ? _a3 : 100;
  }
  fire(event) {
    if (!this._handle) {
      this.pause();
      this._handle = setTimeout(() => {
        this._handle = void 0;
        this.resume();
      }, this._delay);
    }
    super.fire(event);
  }
};
var EventBufferer = class {
  constructor() {
    this.buffers = [];
  }
  wrapEvent(event) {
    return (listener, thisArgs, disposables) => {
      return event((i) => {
        const buffer = this.buffers[this.buffers.length - 1];
        if (buffer) {
          buffer.push(() => listener.call(thisArgs, i));
        } else {
          listener.call(thisArgs, i);
        }
      }, void 0, disposables);
    };
  }
  bufferEvents(fn) {
    const buffer = [];
    this.buffers.push(buffer);
    const r = fn();
    this.buffers.pop();
    buffer.forEach((flush) => flush());
    return r;
  }
};
var Relay = class {
  constructor() {
    this.listening = false;
    this.inputEvent = Event.None;
    this.inputEventListener = Disposable.None;
    this.emitter = new Emitter({
      onFirstListenerDidAdd: () => {
        this.listening = true;
        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onLastListenerRemove: () => {
        this.listening = false;
        this.inputEventListener.dispose();
      }
    });
    this.event = this.emitter.event;
  }
  set input(event) {
    this.inputEvent = event;
    if (this.listening) {
      this.inputEventListener.dispose();
      this.inputEventListener = event(this.emitter.fire, this.emitter);
    }
  }
  dispose() {
    this.inputEventListener.dispose();
    this.emitter.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/common/cancellation.js
var shortcutEvent = Object.freeze(function(callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return { dispose() {
    clearTimeout(handle);
  } };
});
var CancellationToken;
(function(CancellationToken2) {
  function isCancellationToken(thing) {
    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
      return true;
    }
    if (thing instanceof MutableToken) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
  }
  CancellationToken2.isCancellationToken = isCancellationToken;
  CancellationToken2.None = Object.freeze({
    isCancellationRequested: false,
    onCancellationRequested: Event.None
  });
  CancellationToken2.Cancelled = Object.freeze({
    isCancellationRequested: true,
    onCancellationRequested: shortcutEvent
  });
})(CancellationToken || (CancellationToken = {}));
var MutableToken = class {
  constructor() {
    this._isCancelled = false;
    this._emitter = null;
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(void 0);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }
    if (!this._emitter) {
      this._emitter = new Emitter();
    }
    return this._emitter.event;
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
};
var CancellationTokenSource = class {
  constructor(parent) {
    this._token = void 0;
    this._parentListener = void 0;
    this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
  }
  get token() {
    if (!this._token) {
      this._token = new MutableToken();
    }
    return this._token;
  }
  cancel() {
    if (!this._token) {
      this._token = CancellationToken.Cancelled;
    } else if (this._token instanceof MutableToken) {
      this._token.cancel();
    }
  }
  dispose(cancel = false) {
    if (cancel) {
      this.cancel();
    }
    if (this._parentListener) {
      this._parentListener.dispose();
    }
    if (!this._token) {
      this._token = CancellationToken.None;
    } else if (this._token instanceof MutableToken) {
      this._token.dispose();
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/common/async.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
};
function isThenable(obj) {
  return !!obj && typeof obj.then === "function";
}
function createCancelablePromise(callback) {
  const source = new CancellationTokenSource();
  const thenable = callback(source.token);
  const promise = new Promise((resolve2, reject) => {
    const subscription = source.token.onCancellationRequested(() => {
      subscription.dispose();
      source.dispose();
      reject(new CancellationError());
    });
    Promise.resolve(thenable).then((value) => {
      subscription.dispose();
      source.dispose();
      resolve2(value);
    }, (err) => {
      subscription.dispose();
      source.dispose();
      reject(err);
    });
  });
  return new class {
    cancel() {
      source.cancel();
    }
    then(resolve2, reject) {
      return promise.then(resolve2, reject);
    }
    catch(reject) {
      return this.then(void 0, reject);
    }
    finally(onfinally) {
      return promise.finally(onfinally);
    }
  }();
}
var Throttler = class {
  constructor() {
    this.activePromise = null;
    this.queuedPromise = null;
    this.queuedPromiseFactory = null;
  }
  queue(promiseFactory) {
    if (this.activePromise) {
      this.queuedPromiseFactory = promiseFactory;
      if (!this.queuedPromise) {
        const onComplete = () => {
          this.queuedPromise = null;
          const result = this.queue(this.queuedPromiseFactory);
          this.queuedPromiseFactory = null;
          return result;
        };
        this.queuedPromise = new Promise((resolve2) => {
          this.activePromise.then(onComplete, onComplete).then(resolve2);
        });
      }
      return new Promise((resolve2, reject) => {
        this.queuedPromise.then(resolve2, reject);
      });
    }
    this.activePromise = promiseFactory();
    return new Promise((resolve2, reject) => {
      this.activePromise.then((result) => {
        this.activePromise = null;
        resolve2(result);
      }, (err) => {
        this.activePromise = null;
        reject(err);
      });
    });
  }
};
var timeoutDeferred = (timeout2, fn) => {
  let scheduled = true;
  const handle = setTimeout(() => {
    scheduled = false;
    fn();
  }, timeout2);
  return {
    isTriggered: () => scheduled,
    dispose: () => {
      clearTimeout(handle);
      scheduled = false;
    }
  };
};
var microtaskDeferred = (fn) => {
  let scheduled = true;
  queueMicrotask(() => {
    if (scheduled) {
      scheduled = false;
      fn();
    }
  });
  return {
    isTriggered: () => scheduled,
    dispose: () => {
      scheduled = false;
    }
  };
};
var MicrotaskDelay = Symbol("MicrotaskDelay");
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.deferred = null;
    this.completionPromise = null;
    this.doResolve = null;
    this.doReject = null;
    this.task = null;
  }
  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    this.cancelTimeout();
    if (!this.completionPromise) {
      this.completionPromise = new Promise((resolve2, reject) => {
        this.doResolve = resolve2;
        this.doReject = reject;
      }).then(() => {
        this.completionPromise = null;
        this.doResolve = null;
        if (this.task) {
          const task2 = this.task;
          this.task = null;
          return task2();
        }
        return void 0;
      });
    }
    const fn = () => {
      var _a3;
      this.deferred = null;
      (_a3 = this.doResolve) === null || _a3 === void 0 ? void 0 : _a3.call(this, null);
    };
    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);
    return this.completionPromise;
  }
  isTriggered() {
    var _a3;
    return !!((_a3 = this.deferred) === null || _a3 === void 0 ? void 0 : _a3.isTriggered());
  }
  cancel() {
    this.cancelTimeout();
    if (this.completionPromise) {
      if (this.doReject) {
        this.doReject(new CancellationError());
      }
      this.completionPromise = null;
    }
  }
  cancelTimeout() {
    var _a3;
    (_a3 = this.deferred) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
};
var ThrottledDelayer = class {
  constructor(defaultDelay) {
    this.delayer = new Delayer(defaultDelay);
    this.throttler = new Throttler();
  }
  trigger(promiseFactory, delay) {
    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
  }
  dispose() {
    this.delayer.dispose();
  }
};
function timeout(millis, token) {
  if (!token) {
    return createCancelablePromise((token2) => timeout(millis, token2));
  }
  return new Promise((resolve2, reject) => {
    const handle = setTimeout(() => {
      disposable.dispose();
      resolve2();
    }, millis);
    const disposable = token.onCancellationRequested(() => {
      clearTimeout(handle);
      disposable.dispose();
      reject(new CancellationError());
    });
  });
}
function disposableTimeout(handler, timeout2 = 0) {
  const timer = setTimeout(handler, timeout2);
  return toDisposable(() => clearTimeout(timer));
}
var TimeoutTimer = class {
  constructor(runner, timeout2) {
    this._token = -1;
    if (typeof runner === "function" && typeof timeout2 === "number") {
      this.setIfNotSet(runner, timeout2);
    }
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    if (this._token !== -1) {
      clearTimeout(this._token);
      this._token = -1;
    }
  }
  cancelAndSet(runner, timeout2) {
    this.cancel();
    this._token = setTimeout(() => {
      this._token = -1;
      runner();
    }, timeout2);
  }
  setIfNotSet(runner, timeout2) {
    if (this._token !== -1) {
      return;
    }
    this._token = setTimeout(() => {
      this._token = -1;
      runner();
    }, timeout2);
  }
};
var IntervalTimer = class {
  constructor() {
    this._token = -1;
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    if (this._token !== -1) {
      clearInterval(this._token);
      this._token = -1;
    }
  }
  cancelAndSet(runner, interval) {
    this.cancel();
    this._token = setInterval(() => {
      runner();
    }, interval);
  }
};
var RunOnceScheduler = class {
  constructor(runner, delay) {
    this.timeoutToken = -1;
    this.runner = runner;
    this.timeout = delay;
    this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel();
    this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    if (this.isScheduled()) {
      clearTimeout(this.timeoutToken);
      this.timeoutToken = -1;
    }
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(delay = this.timeout) {
    this.cancel();
    this.timeoutToken = setTimeout(this.timeoutHandler, delay);
  }
  get delay() {
    return this.timeout;
  }
  set delay(value) {
    this.timeout = value;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1;
    if (this.runner) {
      this.doRun();
    }
  }
  doRun() {
    if (this.runner) {
      this.runner();
    }
  }
};
var runWhenIdle;
(function() {
  if (typeof requestIdleCallback !== "function" || typeof cancelIdleCallback !== "function") {
    runWhenIdle = (runner) => {
      setTimeout0(() => {
        if (disposed) {
          return;
        }
        const end = Date.now() + 15;
        runner(Object.freeze({
          didTimeout: true,
          timeRemaining() {
            return Math.max(0, end - Date.now());
          }
        }));
      });
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
        }
      };
    };
  } else {
    runWhenIdle = (runner, timeout2) => {
      const handle = requestIdleCallback(runner, typeof timeout2 === "number" ? { timeout: timeout2 } : void 0);
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }
          disposed = true;
          cancelIdleCallback(handle);
        }
      };
    };
  }
})();
var IdleValue = class {
  constructor(executor) {
    this._didRun = false;
    this._executor = () => {
      try {
        this._value = executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    };
    this._handle = runWhenIdle(() => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (!this._didRun) {
      this._handle.dispose();
      this._executor();
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
};
var DeferredPromise = class {
  constructor() {
    this.rejected = false;
    this.resolved = false;
    this.p = new Promise((c, e) => {
      this.completeCallback = c;
      this.errorCallback = e;
    });
  }
  get isRejected() {
    return this.rejected;
  }
  get isSettled() {
    return this.rejected || this.resolved;
  }
  complete(value) {
    return new Promise((resolve2) => {
      this.completeCallback(value);
      this.resolved = true;
      resolve2();
    });
  }
  cancel() {
    new Promise((resolve2) => {
      this.errorCallback(new CancellationError());
      this.rejected = true;
      resolve2();
    });
  }
};
var Promises;
(function(Promises2) {
  function settled(promises) {
    return __awaiter(this, void 0, void 0, function* () {
      let firstError = void 0;
      const result = yield Promise.all(promises.map((promise) => promise.then((value) => value, (error) => {
        if (!firstError) {
          firstError = error;
        }
        return void 0;
      })));
      if (typeof firstError !== "undefined") {
        throw firstError;
      }
      return result;
    });
  }
  Promises2.settled = settled;
  function withAsyncBody(bodyFn) {
    return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
      try {
        yield bodyFn(resolve2, reject);
      } catch (error) {
        reject(error);
      }
    }));
  }
  Promises2.withAsyncBody = withAsyncBody;
})(Promises || (Promises = {}));
var AsyncIterableObject = class _AsyncIterableObject {
  constructor(executor) {
    this._state = 0;
    this._results = [];
    this._error = null;
    this._onStateChanged = new Emitter();
    queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {
      const writer = {
        emitOne: (item) => this.emitOne(item),
        emitMany: (items) => this.emitMany(items),
        reject: (error) => this.reject(error)
      };
      try {
        yield Promise.resolve(executor(writer));
        this.resolve();
      } catch (err) {
        this.reject(err);
      } finally {
        writer.emitOne = void 0;
        writer.emitMany = void 0;
        writer.reject = void 0;
      }
    }));
  }
  static fromArray(items) {
    return new _AsyncIterableObject((writer) => {
      writer.emitMany(items);
    });
  }
  static fromPromise(promise) {
    return new _AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
      emitter.emitMany(yield promise);
    }));
  }
  static fromPromises(promises) {
    return new _AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(promises.map((p) => __awaiter(this, void 0, void 0, function* () {
        return emitter.emitOne(yield p);
      })));
    }));
  }
  static merge(iterables) {
    return new _AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(iterables.map((iterable) => {
        var iterable_1, iterable_1_1;
        return __awaiter(this, void 0, void 0, function* () {
          var e_1, _a3;
          try {
            for (iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done; ) {
              const item = iterable_1_1.value;
              emitter.emitOne(item);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (iterable_1_1 && !iterable_1_1.done && (_a3 = iterable_1.return)) yield _a3.call(iterable_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        });
      }));
    }));
  }
  [Symbol.asyncIterator]() {
    let i = 0;
    return {
      next: () => __awaiter(this, void 0, void 0, function* () {
        do {
          if (this._state === 2) {
            throw this._error;
          }
          if (i < this._results.length) {
            return { done: false, value: this._results[i++] };
          }
          if (this._state === 1) {
            return { done: true, value: void 0 };
          }
          yield Event.toPromise(this._onStateChanged.event);
        } while (true);
      })
    };
  }
  static map(iterable, mapFn) {
    return new _AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
      var e_2, _a3;
      try {
        for (var iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield iterable_2.next(), !iterable_2_1.done; ) {
          const item = iterable_2_1.value;
          emitter.emitOne(mapFn(item));
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (iterable_2_1 && !iterable_2_1.done && (_a3 = iterable_2.return)) yield _a3.call(iterable_2);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }));
  }
  map(mapFn) {
    return _AsyncIterableObject.map(this, mapFn);
  }
  static filter(iterable, filterFn) {
    return new _AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {
      var e_3, _a3;
      try {
        for (var iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield iterable_3.next(), !iterable_3_1.done; ) {
          const item = iterable_3_1.value;
          if (filterFn(item)) {
            emitter.emitOne(item);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (iterable_3_1 && !iterable_3_1.done && (_a3 = iterable_3.return)) yield _a3.call(iterable_3);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
    }));
  }
  filter(filterFn) {
    return _AsyncIterableObject.filter(this, filterFn);
  }
  static coalesce(iterable) {
    return _AsyncIterableObject.filter(iterable, (item) => !!item);
  }
  coalesce() {
    return _AsyncIterableObject.coalesce(this);
  }
  static toPromise(iterable) {
    var iterable_4, iterable_4_1;
    var e_4, _a3;
    return __awaiter(this, void 0, void 0, function* () {
      const result = [];
      try {
        for (iterable_4 = __asyncValues(iterable); iterable_4_1 = yield iterable_4.next(), !iterable_4_1.done; ) {
          const item = iterable_4_1.value;
          result.push(item);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (iterable_4_1 && !iterable_4_1.done && (_a3 = iterable_4.return)) yield _a3.call(iterable_4);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
      return result;
    });
  }
  toPromise() {
    return _AsyncIterableObject.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(value) {
    if (this._state !== 0) {
      return;
    }
    this._results.push(value);
    this._onStateChanged.fire();
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(values) {
    if (this._state !== 0) {
      return;
    }
    this._results = this._results.concat(values);
    this._onStateChanged.fire();
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    if (this._state !== 0) {
      return;
    }
    this._state = 1;
    this._onStateChanged.fire();
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(error) {
    if (this._state !== 0) {
      return;
    }
    this._state = 2;
    this._error = error;
    this._onStateChanged.fire();
  }
};
AsyncIterableObject.EMPTY = AsyncIterableObject.fromArray([]);

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js
var _util;
(function(_util2) {
  _util2.serviceIds = /* @__PURE__ */ new Map();
  _util2.DI_TARGET = "$di$target";
  _util2.DI_DEPENDENCIES = "$di$dependencies";
  function getServiceDependencies(ctor) {
    return ctor[_util2.DI_DEPENDENCIES] || [];
  }
  _util2.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
var IInstantiationService = createDecorator("instantiationService");
function storeServiceDependency(id, target, index) {
  if (target[_util.DI_TARGET] === target) {
    target[_util.DI_DEPENDENCIES].push({ id, index });
  } else {
    target[_util.DI_DEPENDENCIES] = [{ id, index }];
    target[_util.DI_TARGET] = target;
  }
}
function createDecorator(serviceId) {
  if (_util.serviceIds.has(serviceId)) {
    return _util.serviceIds.get(serviceId);
  }
  const id = function(target, key, index) {
    if (arguments.length !== 3) {
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    }
    storeServiceDependency(id, target, index);
  };
  id.toString = () => serviceId;
  _util.serviceIds.set(serviceId, id);
  return id;
}

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js
var CONSTANT_VALUES = /* @__PURE__ */ new Map();
CONSTANT_VALUES.set("false", false);
CONSTANT_VALUES.set("true", true);
CONSTANT_VALUES.set("isMac", isMacintosh);
CONSTANT_VALUES.set("isLinux", isLinux);
CONSTANT_VALUES.set("isWindows", isWindows);
CONSTANT_VALUES.set("isWeb", isWeb);
CONSTANT_VALUES.set("isMacNative", isMacintosh && !isWeb);
CONSTANT_VALUES.set("isEdge", isEdge);
CONSTANT_VALUES.set("isFirefox", isFirefox);
CONSTANT_VALUES.set("isChrome", isChrome);
CONSTANT_VALUES.set("isSafari", isSafari);
var hasOwnProperty = Object.prototype.hasOwnProperty;
var ContextKeyExpr = class {
  static has(key) {
    return ContextKeyDefinedExpr.create(key);
  }
  static equals(key, value) {
    return ContextKeyEqualsExpr.create(key, value);
  }
  static regex(key, value) {
    return ContextKeyRegexExpr.create(key, value);
  }
  static not(key) {
    return ContextKeyNotExpr.create(key);
  }
  static and(...expr) {
    return ContextKeyAndExpr.create(expr, null);
  }
  static or(...expr) {
    return ContextKeyOrExpr.create(expr, null, true);
  }
  static deserialize(serialized, strict = false) {
    if (!serialized) {
      return void 0;
    }
    return this._deserializeOrExpression(serialized, strict);
  }
  static _deserializeOrExpression(serialized, strict) {
    let pieces = serialized.split("||");
    return ContextKeyOrExpr.create(pieces.map((p) => this._deserializeAndExpression(p, strict)), null, true);
  }
  static _deserializeAndExpression(serialized, strict) {
    let pieces = serialized.split("&&");
    return ContextKeyAndExpr.create(pieces.map((p) => this._deserializeOne(p, strict)), null);
  }
  static _deserializeOne(serializedOne, strict) {
    serializedOne = serializedOne.trim();
    if (serializedOne.indexOf("!=") >= 0) {
      let pieces = serializedOne.split("!=");
      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));
    }
    if (serializedOne.indexOf("==") >= 0) {
      let pieces = serializedOne.split("==");
      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));
    }
    if (serializedOne.indexOf("=~") >= 0) {
      let pieces = serializedOne.split("=~");
      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));
    }
    if (serializedOne.indexOf(" in ") >= 0) {
      let pieces = serializedOne.split(" in ");
      return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());
    }
    if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {
      const pieces = serializedOne.split(">=");
      return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());
    }
    if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {
      const pieces = serializedOne.split(">");
      return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());
    }
    if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {
      const pieces = serializedOne.split("<=");
      return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());
    }
    if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {
      const pieces = serializedOne.split("<");
      return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());
    }
    if (/^\!\s*/.test(serializedOne)) {
      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());
    }
    return ContextKeyDefinedExpr.create(serializedOne);
  }
  static _deserializeValue(serializedValue, strict) {
    serializedValue = serializedValue.trim();
    if (serializedValue === "true") {
      return true;
    }
    if (serializedValue === "false") {
      return false;
    }
    let m = /^'([^']*)'$/.exec(serializedValue);
    if (m) {
      return m[1].trim();
    }
    return serializedValue;
  }
  static _deserializeRegexValue(serializedValue, strict) {
    if (isFalsyOrWhitespace(serializedValue)) {
      if (strict) {
        throw new Error("missing regexp-value for =~-expression");
      } else {
        console.warn("missing regexp-value for =~-expression");
      }
      return null;
    }
    let start = serializedValue.indexOf("/");
    let end = serializedValue.lastIndexOf("/");
    if (start === end || start < 0) {
      if (strict) {
        throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);
      } else {
        console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);
      }
      return null;
    }
    let value = serializedValue.slice(start + 1, end);
    let caseIgnoreFlag = serializedValue[end + 1] === "i" ? "i" : "";
    try {
      return new RegExp(value, caseIgnoreFlag);
    } catch (e) {
      if (strict) {
        throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);
      } else {
        console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);
      }
      return null;
    }
  }
};
function expressionsAreEqualWithConstantSubstitution(a, b) {
  const aExpr = a ? a.substituteConstants() : void 0;
  const bExpr = b ? b.substituteConstants() : void 0;
  if (!aExpr && !bExpr) {
    return true;
  }
  if (!aExpr || !bExpr) {
    return false;
  }
  return aExpr.equals(bExpr);
}
function cmp(a, b) {
  return a.cmp(b);
}
var ContextKeyFalseExpr = class {
  constructor() {
    this.type = 0;
  }
  cmp(other) {
    return this.type - other.type;
  }
  equals(other) {
    return other.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return false;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return ContextKeyTrueExpr.INSTANCE;
  }
};
ContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();
var ContextKeyTrueExpr = class {
  constructor() {
    this.type = 1;
  }
  cmp(other) {
    return this.type - other.type;
  }
  equals(other) {
    return other.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return true;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return ContextKeyFalseExpr.INSTANCE;
  }
};
ContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();
var ContextKeyDefinedExpr = class _ContextKeyDefinedExpr {
  constructor(key, negated) {
    this.key = key;
    this.negated = negated;
    this.type = 2;
  }
  static create(key, negated = null) {
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return new _ContextKeyDefinedExpr(key, negated);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp1(this.key, other.key);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return !!context.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotExpr.create(this.key, this);
    }
    return this.negated;
  }
};
var ContextKeyEqualsExpr = class _ContextKeyEqualsExpr {
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 4;
  }
  static create(key, value, negated = null) {
    if (typeof value === "boolean") {
      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);
    }
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      const trueValue = constantValue ? "true" : "false";
      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return new _ContextKeyEqualsExpr(key, value, negated);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      const trueValue = constantValue ? "true" : "false";
      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return context.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyInExpr = class _ContextKeyInExpr {
  constructor(key, valueKey) {
    this.key = key;
    this.valueKey = valueKey;
    this.type = 10;
    this.negated = null;
  }
  static create(key, valueKey) {
    return new _ContextKeyInExpr(key, valueKey);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.valueKey, other.key, other.valueKey);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.valueKey === other.valueKey;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    const source = context.getValue(this.valueKey);
    const item = context.getValue(this.key);
    if (Array.isArray(source)) {
      return source.indexOf(item) >= 0;
    }
    if (typeof item === "string" && typeof source === "object" && source !== null) {
      return hasOwnProperty.call(source, item);
    }
    return false;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotInExpr.create(this);
    }
    return this.negated;
  }
};
var ContextKeyNotInExpr = class _ContextKeyNotInExpr {
  constructor(_actual) {
    this._actual = _actual;
    this.type = 11;
  }
  static create(actual) {
    return new _ContextKeyNotInExpr(actual);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return this._actual.cmp(other._actual);
  }
  equals(other) {
    if (other.type === this.type) {
      return this._actual.equals(other._actual);
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return !this._actual.evaluate(context);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
};
var ContextKeyNotEqualsExpr = class _ContextKeyNotEqualsExpr {
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 5;
  }
  static create(key, value, negated = null) {
    if (typeof value === "boolean") {
      if (value) {
        return ContextKeyNotExpr.create(key, negated);
      }
      return ContextKeyDefinedExpr.create(key, negated);
    }
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      const falseValue = constantValue ? "true" : "false";
      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return new _ContextKeyNotEqualsExpr(key, value, negated);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      const falseValue = constantValue ? "true" : "false";
      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return context.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyNotExpr = class _ContextKeyNotExpr {
  constructor(key, negated) {
    this.key = key;
    this.negated = negated;
    this.type = 3;
  }
  static create(key, negated = null) {
    const constantValue = CONSTANT_VALUES.get(key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return new _ContextKeyNotExpr(key, negated);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp1(this.key, other.key);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key;
    }
    return false;
  }
  substituteConstants() {
    const constantValue = CONSTANT_VALUES.get(this.key);
    if (typeof constantValue === "boolean") {
      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
    }
    return this;
  }
  evaluate(context) {
    return !context.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyDefinedExpr.create(this.key, this);
    }
    return this.negated;
  }
};
function withFloatOrStr(value, callback) {
  if (typeof value === "string") {
    const n = parseFloat(value);
    if (!isNaN(n)) {
      value = n;
    }
  }
  if (typeof value === "string" || typeof value === "number") {
    return callback(value);
  }
  return ContextKeyFalseExpr.INSTANCE;
}
var ContextKeyGreaterExpr = class _ContextKeyGreaterExpr {
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 12;
  }
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeyGreaterExpr(key, value, negated));
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyGreaterEqualsExpr = class _ContextKeyGreaterEqualsExpr {
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 13;
  }
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeyGreaterEqualsExpr(key, value, negated));
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeySmallerExpr = class _ContextKeySmallerExpr {
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 14;
  }
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeySmallerExpr(key, value, negated));
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeySmallerEqualsExpr = class _ContextKeySmallerEqualsExpr {
  constructor(key, value, negated) {
    this.key = key;
    this.value = value;
    this.negated = negated;
    this.type = 15;
  }
  static create(key, _value, negated = null) {
    return withFloatOrStr(_value, (value) => new _ContextKeySmallerEqualsExpr(key, value, negated));
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return cmp2(this.key, this.value, other.key, other.value);
  }
  equals(other) {
    if (other.type === this.type) {
      return this.key === other.key && this.value === other.value;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    if (typeof this.value === "string") {
      return false;
    }
    return parseFloat(context.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
    }
    return this.negated;
  }
};
var ContextKeyRegexExpr = class _ContextKeyRegexExpr {
  constructor(key, regexp) {
    this.key = key;
    this.regexp = regexp;
    this.type = 7;
    this.negated = null;
  }
  static create(key, regexp) {
    return new _ContextKeyRegexExpr(key, regexp);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.key < other.key) {
      return -1;
    }
    if (this.key > other.key) {
      return 1;
    }
    const thisSource = this.regexp ? this.regexp.source : "";
    const otherSource = other.regexp ? other.regexp.source : "";
    if (thisSource < otherSource) {
      return -1;
    }
    if (thisSource > otherSource) {
      return 1;
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      const thisSource = this.regexp ? this.regexp.source : "";
      const otherSource = other.regexp ? other.regexp.source : "";
      return this.key === other.key && thisSource === otherSource;
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    let value = context.getValue(this.key);
    return this.regexp ? this.regexp.test(value) : false;
  }
  serialize() {
    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? "i" : ""}` : "/invalid/";
    return `${this.key} =~ ${value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    if (!this.negated) {
      this.negated = ContextKeyNotRegexExpr.create(this);
    }
    return this.negated;
  }
};
var ContextKeyNotRegexExpr = class _ContextKeyNotRegexExpr {
  constructor(_actual) {
    this._actual = _actual;
    this.type = 8;
  }
  static create(actual) {
    return new _ContextKeyNotRegexExpr(actual);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    return this._actual.cmp(other._actual);
  }
  equals(other) {
    if (other.type === this.type) {
      return this._actual.equals(other._actual);
    }
    return false;
  }
  substituteConstants() {
    return this;
  }
  evaluate(context) {
    return !this._actual.evaluate(context);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
};
function eliminateConstantsInArray(arr) {
  let newArr = null;
  for (let i = 0, len = arr.length; i < len; i++) {
    const newExpr = arr[i].substituteConstants();
    if (arr[i] !== newExpr) {
      if (newArr === null) {
        newArr = [];
        for (let j = 0; j < i; j++) {
          newArr[j] = arr[j];
        }
      }
    }
    if (newArr !== null) {
      newArr[i] = newExpr;
    }
  }
  if (newArr === null) {
    return arr;
  }
  return newArr;
}
var ContextKeyAndExpr = class _ContextKeyAndExpr {
  constructor(expr, negated) {
    this.expr = expr;
    this.negated = negated;
    this.type = 6;
  }
  static create(_expr, negated) {
    return _ContextKeyAndExpr._normalizeArr(_expr, negated);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.expr.length < other.expr.length) {
      return -1;
    }
    if (this.expr.length > other.expr.length) {
      return 1;
    }
    for (let i = 0, len = this.expr.length; i < len; i++) {
      const r = cmp(this.expr[i], other.expr[i]);
      if (r !== 0) {
        return r;
      }
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      if (this.expr.length !== other.expr.length) {
        return false;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].equals(other.expr[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  substituteConstants() {
    const exprArr = eliminateConstantsInArray(this.expr);
    if (exprArr === this.expr) {
      return this;
    }
    return _ContextKeyAndExpr.create(exprArr, this.negated);
  }
  evaluate(context) {
    for (let i = 0, len = this.expr.length; i < len; i++) {
      if (!this.expr[i].evaluate(context)) {
        return false;
      }
    }
    return true;
  }
  static _normalizeArr(arr, negated) {
    const expr = [];
    let hasTrue = false;
    for (const e of arr) {
      if (!e) {
        continue;
      }
      if (e.type === 1) {
        hasTrue = true;
        continue;
      }
      if (e.type === 0) {
        return ContextKeyFalseExpr.INSTANCE;
      }
      if (e.type === 6) {
        expr.push(...e.expr);
        continue;
      }
      expr.push(e);
    }
    if (expr.length === 0 && hasTrue) {
      return ContextKeyTrueExpr.INSTANCE;
    }
    if (expr.length === 0) {
      return void 0;
    }
    if (expr.length === 1) {
      return expr[0];
    }
    expr.sort(cmp);
    for (let i = 1; i < expr.length; i++) {
      if (expr[i - 1].equals(expr[i])) {
        expr.splice(i, 1);
        i--;
      }
    }
    if (expr.length === 1) {
      return expr[0];
    }
    while (expr.length > 1) {
      const lastElement = expr[expr.length - 1];
      if (lastElement.type !== 9) {
        break;
      }
      expr.pop();
      const secondToLastElement = expr.pop();
      const isFinished = expr.length === 0;
      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map((el) => _ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);
      if (resultElement) {
        expr.push(resultElement);
        expr.sort(cmp);
      }
    }
    if (expr.length === 1) {
      return expr[0];
    }
    return new _ContextKeyAndExpr(expr, negated);
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const result = [];
    for (let expr of this.expr) {
      result.push(...expr.keys());
    }
    return result;
  }
  negate() {
    if (!this.negated) {
      const result = [];
      for (let expr of this.expr) {
        result.push(expr.negate());
      }
      this.negated = ContextKeyOrExpr.create(result, this, true);
    }
    return this.negated;
  }
};
var ContextKeyOrExpr = class _ContextKeyOrExpr {
  constructor(expr, negated) {
    this.expr = expr;
    this.negated = negated;
    this.type = 9;
  }
  static create(_expr, negated, extraRedundantCheck) {
    return _ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
  }
  cmp(other) {
    if (other.type !== this.type) {
      return this.type - other.type;
    }
    if (this.expr.length < other.expr.length) {
      return -1;
    }
    if (this.expr.length > other.expr.length) {
      return 1;
    }
    for (let i = 0, len = this.expr.length; i < len; i++) {
      const r = cmp(this.expr[i], other.expr[i]);
      if (r !== 0) {
        return r;
      }
    }
    return 0;
  }
  equals(other) {
    if (other.type === this.type) {
      if (this.expr.length !== other.expr.length) {
        return false;
      }
      for (let i = 0, len = this.expr.length; i < len; i++) {
        if (!this.expr[i].equals(other.expr[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  substituteConstants() {
    const exprArr = eliminateConstantsInArray(this.expr);
    if (exprArr === this.expr) {
      return this;
    }
    return _ContextKeyOrExpr.create(exprArr, this.negated, false);
  }
  evaluate(context) {
    for (let i = 0, len = this.expr.length; i < len; i++) {
      if (this.expr[i].evaluate(context)) {
        return true;
      }
    }
    return false;
  }
  static _normalizeArr(arr, negated, extraRedundantCheck) {
    let expr = [];
    let hasFalse = false;
    if (arr) {
      for (let i = 0, len = arr.length; i < len; i++) {
        const e = arr[i];
        if (!e) {
          continue;
        }
        if (e.type === 0) {
          hasFalse = true;
          continue;
        }
        if (e.type === 1) {
          return ContextKeyTrueExpr.INSTANCE;
        }
        if (e.type === 9) {
          expr = expr.concat(e.expr);
          continue;
        }
        expr.push(e);
      }
      if (expr.length === 0 && hasFalse) {
        return ContextKeyFalseExpr.INSTANCE;
      }
      expr.sort(cmp);
    }
    if (expr.length === 0) {
      return void 0;
    }
    if (expr.length === 1) {
      return expr[0];
    }
    for (let i = 1; i < expr.length; i++) {
      if (expr[i - 1].equals(expr[i])) {
        expr.splice(i, 1);
        i--;
      }
    }
    if (expr.length === 1) {
      return expr[0];
    }
    if (extraRedundantCheck) {
      for (let i = 0; i < expr.length; i++) {
        for (let j = i + 1; j < expr.length; j++) {
          if (implies(expr[i], expr[j])) {
            expr.splice(j, 1);
            j--;
          }
        }
      }
      if (expr.length === 1) {
        return expr[0];
      }
    }
    return new _ContextKeyOrExpr(expr, negated);
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const result = [];
    for (let expr of this.expr) {
      result.push(...expr.keys());
    }
    return result;
  }
  negate() {
    if (!this.negated) {
      let result = [];
      for (let expr of this.expr) {
        result.push(expr.negate());
      }
      while (result.length > 1) {
        const LEFT = result.shift();
        const RIGHT = result.shift();
        const all = [];
        for (const left of getTerminals(LEFT)) {
          for (const right of getTerminals(RIGHT)) {
            all.push(ContextKeyAndExpr.create([left, right], null));
          }
        }
        const isFinished = result.length === 0;
        result.unshift(_ContextKeyOrExpr.create(all, null, isFinished));
      }
      this.negated = result[0];
    }
    return this.negated;
  }
};
var RawContextKey = class _RawContextKey extends ContextKeyDefinedExpr {
  constructor(key, defaultValue, metaOrHide) {
    super(key, null);
    this._defaultValue = defaultValue;
    if (typeof metaOrHide === "object") {
      _RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));
    } else if (metaOrHide !== true) {
      _RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== void 0 ? typeof defaultValue : void 0 });
    }
  }
  static all() {
    return _RawContextKey._info.values();
  }
  bindTo(target) {
    return target.createKey(this.key, this._defaultValue);
  }
  getValue(target) {
    return target.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(value) {
    return ContextKeyEqualsExpr.create(this.key, value);
  }
};
RawContextKey._info = [];
var IContextKeyService = createDecorator("contextKeyService");
var SET_CONTEXT_COMMAND_ID = "setContext";
function cmp1(key1, key2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  return 0;
}
function cmp2(key1, value1, key2, value2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  if (value1 > value2) {
    return 1;
  }
  return 0;
}
function implies(p, q) {
  if (q.type === 6 && (p.type !== 9 && p.type !== 6)) {
    for (const qTerm of q.expr) {
      if (p.equals(qTerm)) {
        return true;
      }
    }
  }
  const notP = p.negate();
  const expr = getTerminals(notP).concat(getTerminals(q));
  expr.sort(cmp);
  for (let i = 0; i < expr.length; i++) {
    const a = expr[i];
    const notA = a.negate();
    for (let j = i + 1; j < expr.length; j++) {
      const b = expr[j];
      if (notA.equals(b)) {
        return true;
      }
    }
  }
  return false;
}
function getTerminals(node) {
  if (node.type === 9) {
    return node.expr;
  }
  return [node];
}

// node_modules/monaco-editor/esm/vs/base/common/codicons.js
function getCodiconAriaLabel(text) {
  if (!text) {
    return "";
  }
  return text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim();
}
var Codicon = class _Codicon {
  constructor(id, definition, description) {
    this.id = id;
    this.definition = definition;
    this.description = description;
    _Codicon._allCodicons.push(this);
  }
  get classNames() {
    return "codicon codicon-" + this.id;
  }
  // classNamesArray is useful for migrating to ES6 classlist
  get classNamesArray() {
    return ["codicon", "codicon-" + this.id];
  }
  get cssSelector() {
    return ".codicon.codicon-" + this.id;
  }
  /**
   * @returns Returns all default icons covered by the codicon font. Only to be used by the icon registry in platform.
   */
  static getAll() {
    return _Codicon._allCodicons;
  }
};
Codicon._allCodicons = [];
Codicon.add = new Codicon("add", { fontCharacter: "\\ea60" });
Codicon.plus = new Codicon("plus", Codicon.add.definition);
Codicon.gistNew = new Codicon("gist-new", Codicon.add.definition);
Codicon.repoCreate = new Codicon("repo-create", Codicon.add.definition);
Codicon.lightbulb = new Codicon("lightbulb", { fontCharacter: "\\ea61" });
Codicon.lightBulb = new Codicon("light-bulb", { fontCharacter: "\\ea61" });
Codicon.repo = new Codicon("repo", { fontCharacter: "\\ea62" });
Codicon.repoDelete = new Codicon("repo-delete", { fontCharacter: "\\ea62" });
Codicon.gistFork = new Codicon("gist-fork", { fontCharacter: "\\ea63" });
Codicon.repoForked = new Codicon("repo-forked", { fontCharacter: "\\ea63" });
Codicon.gitPullRequest = new Codicon("git-pull-request", { fontCharacter: "\\ea64" });
Codicon.gitPullRequestAbandoned = new Codicon("git-pull-request-abandoned", { fontCharacter: "\\ea64" });
Codicon.recordKeys = new Codicon("record-keys", { fontCharacter: "\\ea65" });
Codicon.keyboard = new Codicon("keyboard", { fontCharacter: "\\ea65" });
Codicon.tag = new Codicon("tag", { fontCharacter: "\\ea66" });
Codicon.tagAdd = new Codicon("tag-add", { fontCharacter: "\\ea66" });
Codicon.tagRemove = new Codicon("tag-remove", { fontCharacter: "\\ea66" });
Codicon.person = new Codicon("person", { fontCharacter: "\\ea67" });
Codicon.personFollow = new Codicon("person-follow", { fontCharacter: "\\ea67" });
Codicon.personOutline = new Codicon("person-outline", { fontCharacter: "\\ea67" });
Codicon.personFilled = new Codicon("person-filled", { fontCharacter: "\\ea67" });
Codicon.gitBranch = new Codicon("git-branch", { fontCharacter: "\\ea68" });
Codicon.gitBranchCreate = new Codicon("git-branch-create", { fontCharacter: "\\ea68" });
Codicon.gitBranchDelete = new Codicon("git-branch-delete", { fontCharacter: "\\ea68" });
Codicon.sourceControl = new Codicon("source-control", { fontCharacter: "\\ea68" });
Codicon.mirror = new Codicon("mirror", { fontCharacter: "\\ea69" });
Codicon.mirrorPublic = new Codicon("mirror-public", { fontCharacter: "\\ea69" });
Codicon.star = new Codicon("star", { fontCharacter: "\\ea6a" });
Codicon.starAdd = new Codicon("star-add", { fontCharacter: "\\ea6a" });
Codicon.starDelete = new Codicon("star-delete", { fontCharacter: "\\ea6a" });
Codicon.starEmpty = new Codicon("star-empty", { fontCharacter: "\\ea6a" });
Codicon.comment = new Codicon("comment", { fontCharacter: "\\ea6b" });
Codicon.commentAdd = new Codicon("comment-add", { fontCharacter: "\\ea6b" });
Codicon.alert = new Codicon("alert", { fontCharacter: "\\ea6c" });
Codicon.warning = new Codicon("warning", { fontCharacter: "\\ea6c" });
Codicon.search = new Codicon("search", { fontCharacter: "\\ea6d" });
Codicon.searchSave = new Codicon("search-save", { fontCharacter: "\\ea6d" });
Codicon.logOut = new Codicon("log-out", { fontCharacter: "\\ea6e" });
Codicon.signOut = new Codicon("sign-out", { fontCharacter: "\\ea6e" });
Codicon.logIn = new Codicon("log-in", { fontCharacter: "\\ea6f" });
Codicon.signIn = new Codicon("sign-in", { fontCharacter: "\\ea6f" });
Codicon.eye = new Codicon("eye", { fontCharacter: "\\ea70" });
Codicon.eyeUnwatch = new Codicon("eye-unwatch", { fontCharacter: "\\ea70" });
Codicon.eyeWatch = new Codicon("eye-watch", { fontCharacter: "\\ea70" });
Codicon.circleFilled = new Codicon("circle-filled", { fontCharacter: "\\ea71" });
Codicon.primitiveDot = new Codicon("primitive-dot", { fontCharacter: "\\ea71" });
Codicon.closeDirty = new Codicon("close-dirty", { fontCharacter: "\\ea71" });
Codicon.debugBreakpoint = new Codicon("debug-breakpoint", { fontCharacter: "\\ea71" });
Codicon.debugBreakpointDisabled = new Codicon("debug-breakpoint-disabled", { fontCharacter: "\\ea71" });
Codicon.debugHint = new Codicon("debug-hint", { fontCharacter: "\\ea71" });
Codicon.primitiveSquare = new Codicon("primitive-square", { fontCharacter: "\\ea72" });
Codicon.edit = new Codicon("edit", { fontCharacter: "\\ea73" });
Codicon.pencil = new Codicon("pencil", { fontCharacter: "\\ea73" });
Codicon.info = new Codicon("info", { fontCharacter: "\\ea74" });
Codicon.issueOpened = new Codicon("issue-opened", { fontCharacter: "\\ea74" });
Codicon.gistPrivate = new Codicon("gist-private", { fontCharacter: "\\ea75" });
Codicon.gitForkPrivate = new Codicon("git-fork-private", { fontCharacter: "\\ea75" });
Codicon.lock = new Codicon("lock", { fontCharacter: "\\ea75" });
Codicon.mirrorPrivate = new Codicon("mirror-private", { fontCharacter: "\\ea75" });
Codicon.close = new Codicon("close", { fontCharacter: "\\ea76" });
Codicon.removeClose = new Codicon("remove-close", { fontCharacter: "\\ea76" });
Codicon.x = new Codicon("x", { fontCharacter: "\\ea76" });
Codicon.repoSync = new Codicon("repo-sync", { fontCharacter: "\\ea77" });
Codicon.sync = new Codicon("sync", { fontCharacter: "\\ea77" });
Codicon.clone = new Codicon("clone", { fontCharacter: "\\ea78" });
Codicon.desktopDownload = new Codicon("desktop-download", { fontCharacter: "\\ea78" });
Codicon.beaker = new Codicon("beaker", { fontCharacter: "\\ea79" });
Codicon.microscope = new Codicon("microscope", { fontCharacter: "\\ea79" });
Codicon.vm = new Codicon("vm", { fontCharacter: "\\ea7a" });
Codicon.deviceDesktop = new Codicon("device-desktop", { fontCharacter: "\\ea7a" });
Codicon.file = new Codicon("file", { fontCharacter: "\\ea7b" });
Codicon.fileText = new Codicon("file-text", { fontCharacter: "\\ea7b" });
Codicon.more = new Codicon("more", { fontCharacter: "\\ea7c" });
Codicon.ellipsis = new Codicon("ellipsis", { fontCharacter: "\\ea7c" });
Codicon.kebabHorizontal = new Codicon("kebab-horizontal", { fontCharacter: "\\ea7c" });
Codicon.mailReply = new Codicon("mail-reply", { fontCharacter: "\\ea7d" });
Codicon.reply = new Codicon("reply", { fontCharacter: "\\ea7d" });
Codicon.organization = new Codicon("organization", { fontCharacter: "\\ea7e" });
Codicon.organizationFilled = new Codicon("organization-filled", { fontCharacter: "\\ea7e" });
Codicon.organizationOutline = new Codicon("organization-outline", { fontCharacter: "\\ea7e" });
Codicon.newFile = new Codicon("new-file", { fontCharacter: "\\ea7f" });
Codicon.fileAdd = new Codicon("file-add", { fontCharacter: "\\ea7f" });
Codicon.newFolder = new Codicon("new-folder", { fontCharacter: "\\ea80" });
Codicon.fileDirectoryCreate = new Codicon("file-directory-create", { fontCharacter: "\\ea80" });
Codicon.trash = new Codicon("trash", { fontCharacter: "\\ea81" });
Codicon.trashcan = new Codicon("trashcan", { fontCharacter: "\\ea81" });
Codicon.history = new Codicon("history", { fontCharacter: "\\ea82" });
Codicon.clock = new Codicon("clock", { fontCharacter: "\\ea82" });
Codicon.folder = new Codicon("folder", { fontCharacter: "\\ea83" });
Codicon.fileDirectory = new Codicon("file-directory", { fontCharacter: "\\ea83" });
Codicon.symbolFolder = new Codicon("symbol-folder", { fontCharacter: "\\ea83" });
Codicon.logoGithub = new Codicon("logo-github", { fontCharacter: "\\ea84" });
Codicon.markGithub = new Codicon("mark-github", { fontCharacter: "\\ea84" });
Codicon.github = new Codicon("github", { fontCharacter: "\\ea84" });
Codicon.terminal = new Codicon("terminal", { fontCharacter: "\\ea85" });
Codicon.console = new Codicon("console", { fontCharacter: "\\ea85" });
Codicon.repl = new Codicon("repl", { fontCharacter: "\\ea85" });
Codicon.zap = new Codicon("zap", { fontCharacter: "\\ea86" });
Codicon.symbolEvent = new Codicon("symbol-event", { fontCharacter: "\\ea86" });
Codicon.error = new Codicon("error", { fontCharacter: "\\ea87" });
Codicon.stop = new Codicon("stop", { fontCharacter: "\\ea87" });
Codicon.variable = new Codicon("variable", { fontCharacter: "\\ea88" });
Codicon.symbolVariable = new Codicon("symbol-variable", { fontCharacter: "\\ea88" });
Codicon.array = new Codicon("array", { fontCharacter: "\\ea8a" });
Codicon.symbolArray = new Codicon("symbol-array", { fontCharacter: "\\ea8a" });
Codicon.symbolModule = new Codicon("symbol-module", { fontCharacter: "\\ea8b" });
Codicon.symbolPackage = new Codicon("symbol-package", { fontCharacter: "\\ea8b" });
Codicon.symbolNamespace = new Codicon("symbol-namespace", { fontCharacter: "\\ea8b" });
Codicon.symbolObject = new Codicon("symbol-object", { fontCharacter: "\\ea8b" });
Codicon.symbolMethod = new Codicon("symbol-method", { fontCharacter: "\\ea8c" });
Codicon.symbolFunction = new Codicon("symbol-function", { fontCharacter: "\\ea8c" });
Codicon.symbolConstructor = new Codicon("symbol-constructor", { fontCharacter: "\\ea8c" });
Codicon.symbolBoolean = new Codicon("symbol-boolean", { fontCharacter: "\\ea8f" });
Codicon.symbolNull = new Codicon("symbol-null", { fontCharacter: "\\ea8f" });
Codicon.symbolNumeric = new Codicon("symbol-numeric", { fontCharacter: "\\ea90" });
Codicon.symbolNumber = new Codicon("symbol-number", { fontCharacter: "\\ea90" });
Codicon.symbolStructure = new Codicon("symbol-structure", { fontCharacter: "\\ea91" });
Codicon.symbolStruct = new Codicon("symbol-struct", { fontCharacter: "\\ea91" });
Codicon.symbolParameter = new Codicon("symbol-parameter", { fontCharacter: "\\ea92" });
Codicon.symbolTypeParameter = new Codicon("symbol-type-parameter", { fontCharacter: "\\ea92" });
Codicon.symbolKey = new Codicon("symbol-key", { fontCharacter: "\\ea93" });
Codicon.symbolText = new Codicon("symbol-text", { fontCharacter: "\\ea93" });
Codicon.symbolReference = new Codicon("symbol-reference", { fontCharacter: "\\ea94" });
Codicon.goToFile = new Codicon("go-to-file", { fontCharacter: "\\ea94" });
Codicon.symbolEnum = new Codicon("symbol-enum", { fontCharacter: "\\ea95" });
Codicon.symbolValue = new Codicon("symbol-value", { fontCharacter: "\\ea95" });
Codicon.symbolRuler = new Codicon("symbol-ruler", { fontCharacter: "\\ea96" });
Codicon.symbolUnit = new Codicon("symbol-unit", { fontCharacter: "\\ea96" });
Codicon.activateBreakpoints = new Codicon("activate-breakpoints", { fontCharacter: "\\ea97" });
Codicon.archive = new Codicon("archive", { fontCharacter: "\\ea98" });
Codicon.arrowBoth = new Codicon("arrow-both", { fontCharacter: "\\ea99" });
Codicon.arrowDown = new Codicon("arrow-down", { fontCharacter: "\\ea9a" });
Codicon.arrowLeft = new Codicon("arrow-left", { fontCharacter: "\\ea9b" });
Codicon.arrowRight = new Codicon("arrow-right", { fontCharacter: "\\ea9c" });
Codicon.arrowSmallDown = new Codicon("arrow-small-down", { fontCharacter: "\\ea9d" });
Codicon.arrowSmallLeft = new Codicon("arrow-small-left", { fontCharacter: "\\ea9e" });
Codicon.arrowSmallRight = new Codicon("arrow-small-right", { fontCharacter: "\\ea9f" });
Codicon.arrowSmallUp = new Codicon("arrow-small-up", { fontCharacter: "\\eaa0" });
Codicon.arrowUp = new Codicon("arrow-up", { fontCharacter: "\\eaa1" });
Codicon.bell = new Codicon("bell", { fontCharacter: "\\eaa2" });
Codicon.bold = new Codicon("bold", { fontCharacter: "\\eaa3" });
Codicon.book = new Codicon("book", { fontCharacter: "\\eaa4" });
Codicon.bookmark = new Codicon("bookmark", { fontCharacter: "\\eaa5" });
Codicon.debugBreakpointConditionalUnverified = new Codicon("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" });
Codicon.debugBreakpointConditional = new Codicon("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" });
Codicon.debugBreakpointConditionalDisabled = new Codicon("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" });
Codicon.debugBreakpointDataUnverified = new Codicon("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" });
Codicon.debugBreakpointData = new Codicon("debug-breakpoint-data", { fontCharacter: "\\eaa9" });
Codicon.debugBreakpointDataDisabled = new Codicon("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" });
Codicon.debugBreakpointLogUnverified = new Codicon("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" });
Codicon.debugBreakpointLog = new Codicon("debug-breakpoint-log", { fontCharacter: "\\eaab" });
Codicon.debugBreakpointLogDisabled = new Codicon("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" });
Codicon.briefcase = new Codicon("briefcase", { fontCharacter: "\\eaac" });
Codicon.broadcast = new Codicon("broadcast", { fontCharacter: "\\eaad" });
Codicon.browser = new Codicon("browser", { fontCharacter: "\\eaae" });
Codicon.bug = new Codicon("bug", { fontCharacter: "\\eaaf" });
Codicon.calendar = new Codicon("calendar", { fontCharacter: "\\eab0" });
Codicon.caseSensitive = new Codicon("case-sensitive", { fontCharacter: "\\eab1" });
Codicon.check = new Codicon("check", { fontCharacter: "\\eab2" });
Codicon.checklist = new Codicon("checklist", { fontCharacter: "\\eab3" });
Codicon.chevronDown = new Codicon("chevron-down", { fontCharacter: "\\eab4" });
Codicon.dropDownButton = new Codicon("drop-down-button", Codicon.chevronDown.definition);
Codicon.chevronLeft = new Codicon("chevron-left", { fontCharacter: "\\eab5" });
Codicon.chevronRight = new Codicon("chevron-right", { fontCharacter: "\\eab6" });
Codicon.chevronUp = new Codicon("chevron-up", { fontCharacter: "\\eab7" });
Codicon.chromeClose = new Codicon("chrome-close", { fontCharacter: "\\eab8" });
Codicon.chromeMaximize = new Codicon("chrome-maximize", { fontCharacter: "\\eab9" });
Codicon.chromeMinimize = new Codicon("chrome-minimize", { fontCharacter: "\\eaba" });
Codicon.chromeRestore = new Codicon("chrome-restore", { fontCharacter: "\\eabb" });
Codicon.circleOutline = new Codicon("circle-outline", { fontCharacter: "\\eabc" });
Codicon.debugBreakpointUnverified = new Codicon("debug-breakpoint-unverified", { fontCharacter: "\\eabc" });
Codicon.circleSlash = new Codicon("circle-slash", { fontCharacter: "\\eabd" });
Codicon.circuitBoard = new Codicon("circuit-board", { fontCharacter: "\\eabe" });
Codicon.clearAll = new Codicon("clear-all", { fontCharacter: "\\eabf" });
Codicon.clippy = new Codicon("clippy", { fontCharacter: "\\eac0" });
Codicon.closeAll = new Codicon("close-all", { fontCharacter: "\\eac1" });
Codicon.cloudDownload = new Codicon("cloud-download", { fontCharacter: "\\eac2" });
Codicon.cloudUpload = new Codicon("cloud-upload", { fontCharacter: "\\eac3" });
Codicon.code = new Codicon("code", { fontCharacter: "\\eac4" });
Codicon.collapseAll = new Codicon("collapse-all", { fontCharacter: "\\eac5" });
Codicon.colorMode = new Codicon("color-mode", { fontCharacter: "\\eac6" });
Codicon.commentDiscussion = new Codicon("comment-discussion", { fontCharacter: "\\eac7" });
Codicon.compareChanges = new Codicon("compare-changes", { fontCharacter: "\\eafd" });
Codicon.creditCard = new Codicon("credit-card", { fontCharacter: "\\eac9" });
Codicon.dash = new Codicon("dash", { fontCharacter: "\\eacc" });
Codicon.dashboard = new Codicon("dashboard", { fontCharacter: "\\eacd" });
Codicon.database = new Codicon("database", { fontCharacter: "\\eace" });
Codicon.debugContinue = new Codicon("debug-continue", { fontCharacter: "\\eacf" });
Codicon.debugDisconnect = new Codicon("debug-disconnect", { fontCharacter: "\\ead0" });
Codicon.debugPause = new Codicon("debug-pause", { fontCharacter: "\\ead1" });
Codicon.debugRestart = new Codicon("debug-restart", { fontCharacter: "\\ead2" });
Codicon.debugStart = new Codicon("debug-start", { fontCharacter: "\\ead3" });
Codicon.debugStepInto = new Codicon("debug-step-into", { fontCharacter: "\\ead4" });
Codicon.debugStepOut = new Codicon("debug-step-out", { fontCharacter: "\\ead5" });
Codicon.debugStepOver = new Codicon("debug-step-over", { fontCharacter: "\\ead6" });
Codicon.debugStop = new Codicon("debug-stop", { fontCharacter: "\\ead7" });
Codicon.debug = new Codicon("debug", { fontCharacter: "\\ead8" });
Codicon.deviceCameraVideo = new Codicon("device-camera-video", { fontCharacter: "\\ead9" });
Codicon.deviceCamera = new Codicon("device-camera", { fontCharacter: "\\eada" });
Codicon.deviceMobile = new Codicon("device-mobile", { fontCharacter: "\\eadb" });
Codicon.diffAdded = new Codicon("diff-added", { fontCharacter: "\\eadc" });
Codicon.diffIgnored = new Codicon("diff-ignored", { fontCharacter: "\\eadd" });
Codicon.diffModified = new Codicon("diff-modified", { fontCharacter: "\\eade" });
Codicon.diffRemoved = new Codicon("diff-removed", { fontCharacter: "\\eadf" });
Codicon.diffRenamed = new Codicon("diff-renamed", { fontCharacter: "\\eae0" });
Codicon.diff = new Codicon("diff", { fontCharacter: "\\eae1" });
Codicon.discard = new Codicon("discard", { fontCharacter: "\\eae2" });
Codicon.editorLayout = new Codicon("editor-layout", { fontCharacter: "\\eae3" });
Codicon.emptyWindow = new Codicon("empty-window", { fontCharacter: "\\eae4" });
Codicon.exclude = new Codicon("exclude", { fontCharacter: "\\eae5" });
Codicon.extensions = new Codicon("extensions", { fontCharacter: "\\eae6" });
Codicon.eyeClosed = new Codicon("eye-closed", { fontCharacter: "\\eae7" });
Codicon.fileBinary = new Codicon("file-binary", { fontCharacter: "\\eae8" });
Codicon.fileCode = new Codicon("file-code", { fontCharacter: "\\eae9" });
Codicon.fileMedia = new Codicon("file-media", { fontCharacter: "\\eaea" });
Codicon.filePdf = new Codicon("file-pdf", { fontCharacter: "\\eaeb" });
Codicon.fileSubmodule = new Codicon("file-submodule", { fontCharacter: "\\eaec" });
Codicon.fileSymlinkDirectory = new Codicon("file-symlink-directory", { fontCharacter: "\\eaed" });
Codicon.fileSymlinkFile = new Codicon("file-symlink-file", { fontCharacter: "\\eaee" });
Codicon.fileZip = new Codicon("file-zip", { fontCharacter: "\\eaef" });
Codicon.files = new Codicon("files", { fontCharacter: "\\eaf0" });
Codicon.filter = new Codicon("filter", { fontCharacter: "\\eaf1" });
Codicon.flame = new Codicon("flame", { fontCharacter: "\\eaf2" });
Codicon.foldDown = new Codicon("fold-down", { fontCharacter: "\\eaf3" });
Codicon.foldUp = new Codicon("fold-up", { fontCharacter: "\\eaf4" });
Codicon.fold = new Codicon("fold", { fontCharacter: "\\eaf5" });
Codicon.folderActive = new Codicon("folder-active", { fontCharacter: "\\eaf6" });
Codicon.folderOpened = new Codicon("folder-opened", { fontCharacter: "\\eaf7" });
Codicon.gear = new Codicon("gear", { fontCharacter: "\\eaf8" });
Codicon.gift = new Codicon("gift", { fontCharacter: "\\eaf9" });
Codicon.gistSecret = new Codicon("gist-secret", { fontCharacter: "\\eafa" });
Codicon.gist = new Codicon("gist", { fontCharacter: "\\eafb" });
Codicon.gitCommit = new Codicon("git-commit", { fontCharacter: "\\eafc" });
Codicon.gitCompare = new Codicon("git-compare", { fontCharacter: "\\eafd" });
Codicon.gitMerge = new Codicon("git-merge", { fontCharacter: "\\eafe" });
Codicon.githubAction = new Codicon("github-action", { fontCharacter: "\\eaff" });
Codicon.githubAlt = new Codicon("github-alt", { fontCharacter: "\\eb00" });
Codicon.globe = new Codicon("globe", { fontCharacter: "\\eb01" });
Codicon.grabber = new Codicon("grabber", { fontCharacter: "\\eb02" });
Codicon.graph = new Codicon("graph", { fontCharacter: "\\eb03" });
Codicon.gripper = new Codicon("gripper", { fontCharacter: "\\eb04" });
Codicon.heart = new Codicon("heart", { fontCharacter: "\\eb05" });
Codicon.home = new Codicon("home", { fontCharacter: "\\eb06" });
Codicon.horizontalRule = new Codicon("horizontal-rule", { fontCharacter: "\\eb07" });
Codicon.hubot = new Codicon("hubot", { fontCharacter: "\\eb08" });
Codicon.inbox = new Codicon("inbox", { fontCharacter: "\\eb09" });
Codicon.issueClosed = new Codicon("issue-closed", { fontCharacter: "\\eba4" });
Codicon.issueReopened = new Codicon("issue-reopened", { fontCharacter: "\\eb0b" });
Codicon.issues = new Codicon("issues", { fontCharacter: "\\eb0c" });
Codicon.italic = new Codicon("italic", { fontCharacter: "\\eb0d" });
Codicon.jersey = new Codicon("jersey", { fontCharacter: "\\eb0e" });
Codicon.json = new Codicon("json", { fontCharacter: "\\eb0f" });
Codicon.kebabVertical = new Codicon("kebab-vertical", { fontCharacter: "\\eb10" });
Codicon.key = new Codicon("key", { fontCharacter: "\\eb11" });
Codicon.law = new Codicon("law", { fontCharacter: "\\eb12" });
Codicon.lightbulbAutofix = new Codicon("lightbulb-autofix", { fontCharacter: "\\eb13" });
Codicon.linkExternal = new Codicon("link-external", { fontCharacter: "\\eb14" });
Codicon.link = new Codicon("link", { fontCharacter: "\\eb15" });
Codicon.listOrdered = new Codicon("list-ordered", { fontCharacter: "\\eb16" });
Codicon.listUnordered = new Codicon("list-unordered", { fontCharacter: "\\eb17" });
Codicon.liveShare = new Codicon("live-share", { fontCharacter: "\\eb18" });
Codicon.loading = new Codicon("loading", { fontCharacter: "\\eb19" });
Codicon.location = new Codicon("location", { fontCharacter: "\\eb1a" });
Codicon.mailRead = new Codicon("mail-read", { fontCharacter: "\\eb1b" });
Codicon.mail = new Codicon("mail", { fontCharacter: "\\eb1c" });
Codicon.markdown = new Codicon("markdown", { fontCharacter: "\\eb1d" });
Codicon.megaphone = new Codicon("megaphone", { fontCharacter: "\\eb1e" });
Codicon.mention = new Codicon("mention", { fontCharacter: "\\eb1f" });
Codicon.milestone = new Codicon("milestone", { fontCharacter: "\\eb20" });
Codicon.mortarBoard = new Codicon("mortar-board", { fontCharacter: "\\eb21" });
Codicon.move = new Codicon("move", { fontCharacter: "\\eb22" });
Codicon.multipleWindows = new Codicon("multiple-windows", { fontCharacter: "\\eb23" });
Codicon.mute = new Codicon("mute", { fontCharacter: "\\eb24" });
Codicon.noNewline = new Codicon("no-newline", { fontCharacter: "\\eb25" });
Codicon.note = new Codicon("note", { fontCharacter: "\\eb26" });
Codicon.octoface = new Codicon("octoface", { fontCharacter: "\\eb27" });
Codicon.openPreview = new Codicon("open-preview", { fontCharacter: "\\eb28" });
Codicon.package_ = new Codicon("package", { fontCharacter: "\\eb29" });
Codicon.paintcan = new Codicon("paintcan", { fontCharacter: "\\eb2a" });
Codicon.pin = new Codicon("pin", { fontCharacter: "\\eb2b" });
Codicon.play = new Codicon("play", { fontCharacter: "\\eb2c" });
Codicon.run = new Codicon("run", { fontCharacter: "\\eb2c" });
Codicon.plug = new Codicon("plug", { fontCharacter: "\\eb2d" });
Codicon.preserveCase = new Codicon("preserve-case", { fontCharacter: "\\eb2e" });
Codicon.preview = new Codicon("preview", { fontCharacter: "\\eb2f" });
Codicon.project = new Codicon("project", { fontCharacter: "\\eb30" });
Codicon.pulse = new Codicon("pulse", { fontCharacter: "\\eb31" });
Codicon.question = new Codicon("question", { fontCharacter: "\\eb32" });
Codicon.quote = new Codicon("quote", { fontCharacter: "\\eb33" });
Codicon.radioTower = new Codicon("radio-tower", { fontCharacter: "\\eb34" });
Codicon.reactions = new Codicon("reactions", { fontCharacter: "\\eb35" });
Codicon.references = new Codicon("references", { fontCharacter: "\\eb36" });
Codicon.refresh = new Codicon("refresh", { fontCharacter: "\\eb37" });
Codicon.regex = new Codicon("regex", { fontCharacter: "\\eb38" });
Codicon.remoteExplorer = new Codicon("remote-explorer", { fontCharacter: "\\eb39" });
Codicon.remote = new Codicon("remote", { fontCharacter: "\\eb3a" });
Codicon.remove = new Codicon("remove", { fontCharacter: "\\eb3b" });
Codicon.replaceAll = new Codicon("replace-all", { fontCharacter: "\\eb3c" });
Codicon.replace = new Codicon("replace", { fontCharacter: "\\eb3d" });
Codicon.repoClone = new Codicon("repo-clone", { fontCharacter: "\\eb3e" });
Codicon.repoForcePush = new Codicon("repo-force-push", { fontCharacter: "\\eb3f" });
Codicon.repoPull = new Codicon("repo-pull", { fontCharacter: "\\eb40" });
Codicon.repoPush = new Codicon("repo-push", { fontCharacter: "\\eb41" });
Codicon.report = new Codicon("report", { fontCharacter: "\\eb42" });
Codicon.requestChanges = new Codicon("request-changes", { fontCharacter: "\\eb43" });
Codicon.rocket = new Codicon("rocket", { fontCharacter: "\\eb44" });
Codicon.rootFolderOpened = new Codicon("root-folder-opened", { fontCharacter: "\\eb45" });
Codicon.rootFolder = new Codicon("root-folder", { fontCharacter: "\\eb46" });
Codicon.rss = new Codicon("rss", { fontCharacter: "\\eb47" });
Codicon.ruby = new Codicon("ruby", { fontCharacter: "\\eb48" });
Codicon.saveAll = new Codicon("save-all", { fontCharacter: "\\eb49" });
Codicon.saveAs = new Codicon("save-as", { fontCharacter: "\\eb4a" });
Codicon.save = new Codicon("save", { fontCharacter: "\\eb4b" });
Codicon.screenFull = new Codicon("screen-full", { fontCharacter: "\\eb4c" });
Codicon.screenNormal = new Codicon("screen-normal", { fontCharacter: "\\eb4d" });
Codicon.searchStop = new Codicon("search-stop", { fontCharacter: "\\eb4e" });
Codicon.server = new Codicon("server", { fontCharacter: "\\eb50" });
Codicon.settingsGear = new Codicon("settings-gear", { fontCharacter: "\\eb51" });
Codicon.settings = new Codicon("settings", { fontCharacter: "\\eb52" });
Codicon.shield = new Codicon("shield", { fontCharacter: "\\eb53" });
Codicon.smiley = new Codicon("smiley", { fontCharacter: "\\eb54" });
Codicon.sortPrecedence = new Codicon("sort-precedence", { fontCharacter: "\\eb55" });
Codicon.splitHorizontal = new Codicon("split-horizontal", { fontCharacter: "\\eb56" });
Codicon.splitVertical = new Codicon("split-vertical", { fontCharacter: "\\eb57" });
Codicon.squirrel = new Codicon("squirrel", { fontCharacter: "\\eb58" });
Codicon.starFull = new Codicon("star-full", { fontCharacter: "\\eb59" });
Codicon.starHalf = new Codicon("star-half", { fontCharacter: "\\eb5a" });
Codicon.symbolClass = new Codicon("symbol-class", { fontCharacter: "\\eb5b" });
Codicon.symbolColor = new Codicon("symbol-color", { fontCharacter: "\\eb5c" });
Codicon.symbolCustomColor = new Codicon("symbol-customcolor", { fontCharacter: "\\eb5c" });
Codicon.symbolConstant = new Codicon("symbol-constant", { fontCharacter: "\\eb5d" });
Codicon.symbolEnumMember = new Codicon("symbol-enum-member", { fontCharacter: "\\eb5e" });
Codicon.symbolField = new Codicon("symbol-field", { fontCharacter: "\\eb5f" });
Codicon.symbolFile = new Codicon("symbol-file", { fontCharacter: "\\eb60" });
Codicon.symbolInterface = new Codicon("symbol-interface", { fontCharacter: "\\eb61" });
Codicon.symbolKeyword = new Codicon("symbol-keyword", { fontCharacter: "\\eb62" });
Codicon.symbolMisc = new Codicon("symbol-misc", { fontCharacter: "\\eb63" });
Codicon.symbolOperator = new Codicon("symbol-operator", { fontCharacter: "\\eb64" });
Codicon.symbolProperty = new Codicon("symbol-property", { fontCharacter: "\\eb65" });
Codicon.wrench = new Codicon("wrench", { fontCharacter: "\\eb65" });
Codicon.wrenchSubaction = new Codicon("wrench-subaction", { fontCharacter: "\\eb65" });
Codicon.symbolSnippet = new Codicon("symbol-snippet", { fontCharacter: "\\eb66" });
Codicon.tasklist = new Codicon("tasklist", { fontCharacter: "\\eb67" });
Codicon.telescope = new Codicon("telescope", { fontCharacter: "\\eb68" });
Codicon.textSize = new Codicon("text-size", { fontCharacter: "\\eb69" });
Codicon.threeBars = new Codicon("three-bars", { fontCharacter: "\\eb6a" });
Codicon.thumbsdown = new Codicon("thumbsdown", { fontCharacter: "\\eb6b" });
Codicon.thumbsup = new Codicon("thumbsup", { fontCharacter: "\\eb6c" });
Codicon.tools = new Codicon("tools", { fontCharacter: "\\eb6d" });
Codicon.triangleDown = new Codicon("triangle-down", { fontCharacter: "\\eb6e" });
Codicon.triangleLeft = new Codicon("triangle-left", { fontCharacter: "\\eb6f" });
Codicon.triangleRight = new Codicon("triangle-right", { fontCharacter: "\\eb70" });
Codicon.triangleUp = new Codicon("triangle-up", { fontCharacter: "\\eb71" });
Codicon.twitter = new Codicon("twitter", { fontCharacter: "\\eb72" });
Codicon.unfold = new Codicon("unfold", { fontCharacter: "\\eb73" });
Codicon.unlock = new Codicon("unlock", { fontCharacter: "\\eb74" });
Codicon.unmute = new Codicon("unmute", { fontCharacter: "\\eb75" });
Codicon.unverified = new Codicon("unverified", { fontCharacter: "\\eb76" });
Codicon.verified = new Codicon("verified", { fontCharacter: "\\eb77" });
Codicon.versions = new Codicon("versions", { fontCharacter: "\\eb78" });
Codicon.vmActive = new Codicon("vm-active", { fontCharacter: "\\eb79" });
Codicon.vmOutline = new Codicon("vm-outline", { fontCharacter: "\\eb7a" });
Codicon.vmRunning = new Codicon("vm-running", { fontCharacter: "\\eb7b" });
Codicon.watch = new Codicon("watch", { fontCharacter: "\\eb7c" });
Codicon.whitespace = new Codicon("whitespace", { fontCharacter: "\\eb7d" });
Codicon.wholeWord = new Codicon("whole-word", { fontCharacter: "\\eb7e" });
Codicon.window = new Codicon("window", { fontCharacter: "\\eb7f" });
Codicon.wordWrap = new Codicon("word-wrap", { fontCharacter: "\\eb80" });
Codicon.zoomIn = new Codicon("zoom-in", { fontCharacter: "\\eb81" });
Codicon.zoomOut = new Codicon("zoom-out", { fontCharacter: "\\eb82" });
Codicon.listFilter = new Codicon("list-filter", { fontCharacter: "\\eb83" });
Codicon.listFlat = new Codicon("list-flat", { fontCharacter: "\\eb84" });
Codicon.listSelection = new Codicon("list-selection", { fontCharacter: "\\eb85" });
Codicon.selection = new Codicon("selection", { fontCharacter: "\\eb85" });
Codicon.listTree = new Codicon("list-tree", { fontCharacter: "\\eb86" });
Codicon.debugBreakpointFunctionUnverified = new Codicon("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" });
Codicon.debugBreakpointFunction = new Codicon("debug-breakpoint-function", { fontCharacter: "\\eb88" });
Codicon.debugBreakpointFunctionDisabled = new Codicon("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" });
Codicon.debugStackframeActive = new Codicon("debug-stackframe-active", { fontCharacter: "\\eb89" });
Codicon.debugStackframeDot = new Codicon("debug-stackframe-dot", { fontCharacter: "\\eb8a" });
Codicon.debugStackframe = new Codicon("debug-stackframe", { fontCharacter: "\\eb8b" });
Codicon.debugStackframeFocused = new Codicon("debug-stackframe-focused", { fontCharacter: "\\eb8b" });
Codicon.debugBreakpointUnsupported = new Codicon("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" });
Codicon.symbolString = new Codicon("symbol-string", { fontCharacter: "\\eb8d" });
Codicon.debugReverseContinue = new Codicon("debug-reverse-continue", { fontCharacter: "\\eb8e" });
Codicon.debugStepBack = new Codicon("debug-step-back", { fontCharacter: "\\eb8f" });
Codicon.debugRestartFrame = new Codicon("debug-restart-frame", { fontCharacter: "\\eb90" });
Codicon.callIncoming = new Codicon("call-incoming", { fontCharacter: "\\eb92" });
Codicon.callOutgoing = new Codicon("call-outgoing", { fontCharacter: "\\eb93" });
Codicon.menu = new Codicon("menu", { fontCharacter: "\\eb94" });
Codicon.expandAll = new Codicon("expand-all", { fontCharacter: "\\eb95" });
Codicon.feedback = new Codicon("feedback", { fontCharacter: "\\eb96" });
Codicon.groupByRefType = new Codicon("group-by-ref-type", { fontCharacter: "\\eb97" });
Codicon.ungroupByRefType = new Codicon("ungroup-by-ref-type", { fontCharacter: "\\eb98" });
Codicon.account = new Codicon("account", { fontCharacter: "\\eb99" });
Codicon.bellDot = new Codicon("bell-dot", { fontCharacter: "\\eb9a" });
Codicon.debugConsole = new Codicon("debug-console", { fontCharacter: "\\eb9b" });
Codicon.library = new Codicon("library", { fontCharacter: "\\eb9c" });
Codicon.output = new Codicon("output", { fontCharacter: "\\eb9d" });
Codicon.runAll = new Codicon("run-all", { fontCharacter: "\\eb9e" });
Codicon.syncIgnored = new Codicon("sync-ignored", { fontCharacter: "\\eb9f" });
Codicon.pinned = new Codicon("pinned", { fontCharacter: "\\eba0" });
Codicon.githubInverted = new Codicon("github-inverted", { fontCharacter: "\\eba1" });
Codicon.debugAlt = new Codicon("debug-alt", { fontCharacter: "\\eb91" });
Codicon.serverProcess = new Codicon("server-process", { fontCharacter: "\\eba2" });
Codicon.serverEnvironment = new Codicon("server-environment", { fontCharacter: "\\eba3" });
Codicon.pass = new Codicon("pass", { fontCharacter: "\\eba4" });
Codicon.stopCircle = new Codicon("stop-circle", { fontCharacter: "\\eba5" });
Codicon.playCircle = new Codicon("play-circle", { fontCharacter: "\\eba6" });
Codicon.record = new Codicon("record", { fontCharacter: "\\eba7" });
Codicon.debugAltSmall = new Codicon("debug-alt-small", { fontCharacter: "\\eba8" });
Codicon.vmConnect = new Codicon("vm-connect", { fontCharacter: "\\eba9" });
Codicon.cloud = new Codicon("cloud", { fontCharacter: "\\ebaa" });
Codicon.merge = new Codicon("merge", { fontCharacter: "\\ebab" });
Codicon.exportIcon = new Codicon("export", { fontCharacter: "\\ebac" });
Codicon.graphLeft = new Codicon("graph-left", { fontCharacter: "\\ebad" });
Codicon.magnet = new Codicon("magnet", { fontCharacter: "\\ebae" });
Codicon.notebook = new Codicon("notebook", { fontCharacter: "\\ebaf" });
Codicon.redo = new Codicon("redo", { fontCharacter: "\\ebb0" });
Codicon.checkAll = new Codicon("check-all", { fontCharacter: "\\ebb1" });
Codicon.pinnedDirty = new Codicon("pinned-dirty", { fontCharacter: "\\ebb2" });
Codicon.passFilled = new Codicon("pass-filled", { fontCharacter: "\\ebb3" });
Codicon.circleLargeFilled = new Codicon("circle-large-filled", { fontCharacter: "\\ebb4" });
Codicon.circleLargeOutline = new Codicon("circle-large-outline", { fontCharacter: "\\ebb5" });
Codicon.combine = new Codicon("combine", { fontCharacter: "\\ebb6" });
Codicon.gather = new Codicon("gather", { fontCharacter: "\\ebb6" });
Codicon.table = new Codicon("table", { fontCharacter: "\\ebb7" });
Codicon.variableGroup = new Codicon("variable-group", { fontCharacter: "\\ebb8" });
Codicon.typeHierarchy = new Codicon("type-hierarchy", { fontCharacter: "\\ebb9" });
Codicon.typeHierarchySub = new Codicon("type-hierarchy-sub", { fontCharacter: "\\ebba" });
Codicon.typeHierarchySuper = new Codicon("type-hierarchy-super", { fontCharacter: "\\ebbb" });
Codicon.gitPullRequestCreate = new Codicon("git-pull-request-create", { fontCharacter: "\\ebbc" });
Codicon.runAbove = new Codicon("run-above", { fontCharacter: "\\ebbd" });
Codicon.runBelow = new Codicon("run-below", { fontCharacter: "\\ebbe" });
Codicon.notebookTemplate = new Codicon("notebook-template", { fontCharacter: "\\ebbf" });
Codicon.debugRerun = new Codicon("debug-rerun", { fontCharacter: "\\ebc0" });
Codicon.workspaceTrusted = new Codicon("workspace-trusted", { fontCharacter: "\\ebc1" });
Codicon.workspaceUntrusted = new Codicon("workspace-untrusted", { fontCharacter: "\\ebc2" });
Codicon.workspaceUnspecified = new Codicon("workspace-unspecified", { fontCharacter: "\\ebc3" });
Codicon.terminalCmd = new Codicon("terminal-cmd", { fontCharacter: "\\ebc4" });
Codicon.terminalDebian = new Codicon("terminal-debian", { fontCharacter: "\\ebc5" });
Codicon.terminalLinux = new Codicon("terminal-linux", { fontCharacter: "\\ebc6" });
Codicon.terminalPowershell = new Codicon("terminal-powershell", { fontCharacter: "\\ebc7" });
Codicon.terminalTmux = new Codicon("terminal-tmux", { fontCharacter: "\\ebc8" });
Codicon.terminalUbuntu = new Codicon("terminal-ubuntu", { fontCharacter: "\\ebc9" });
Codicon.terminalBash = new Codicon("terminal-bash", { fontCharacter: "\\ebca" });
Codicon.arrowSwap = new Codicon("arrow-swap", { fontCharacter: "\\ebcb" });
Codicon.copy = new Codicon("copy", { fontCharacter: "\\ebcc" });
Codicon.personAdd = new Codicon("person-add", { fontCharacter: "\\ebcd" });
Codicon.filterFilled = new Codicon("filter-filled", { fontCharacter: "\\ebce" });
Codicon.wand = new Codicon("wand", { fontCharacter: "\\ebcf" });
Codicon.debugLineByLine = new Codicon("debug-line-by-line", { fontCharacter: "\\ebd0" });
Codicon.inspect = new Codicon("inspect", { fontCharacter: "\\ebd1" });
Codicon.layers = new Codicon("layers", { fontCharacter: "\\ebd2" });
Codicon.layersDot = new Codicon("layers-dot", { fontCharacter: "\\ebd3" });
Codicon.layersActive = new Codicon("layers-active", { fontCharacter: "\\ebd4" });
Codicon.compass = new Codicon("compass", { fontCharacter: "\\ebd5" });
Codicon.compassDot = new Codicon("compass-dot", { fontCharacter: "\\ebd6" });
Codicon.compassActive = new Codicon("compass-active", { fontCharacter: "\\ebd7" });
Codicon.azure = new Codicon("azure", { fontCharacter: "\\ebd8" });
Codicon.issueDraft = new Codicon("issue-draft", { fontCharacter: "\\ebd9" });
Codicon.gitPullRequestClosed = new Codicon("git-pull-request-closed", { fontCharacter: "\\ebda" });
Codicon.gitPullRequestDraft = new Codicon("git-pull-request-draft", { fontCharacter: "\\ebdb" });
Codicon.debugAll = new Codicon("debug-all", { fontCharacter: "\\ebdc" });
Codicon.debugCoverage = new Codicon("debug-coverage", { fontCharacter: "\\ebdd" });
Codicon.runErrors = new Codicon("run-errors", { fontCharacter: "\\ebde" });
Codicon.folderLibrary = new Codicon("folder-library", { fontCharacter: "\\ebdf" });
Codicon.debugContinueSmall = new Codicon("debug-continue-small", { fontCharacter: "\\ebe0" });
Codicon.beakerStop = new Codicon("beaker-stop", { fontCharacter: "\\ebe1" });
Codicon.graphLine = new Codicon("graph-line", { fontCharacter: "\\ebe2" });
Codicon.graphScatter = new Codicon("graph-scatter", { fontCharacter: "\\ebe3" });
Codicon.pieChart = new Codicon("pie-chart", { fontCharacter: "\\ebe4" });
Codicon.bracket = new Codicon("bracket", Codicon.json.definition);
Codicon.bracketDot = new Codicon("bracket-dot", { fontCharacter: "\\ebe5" });
Codicon.bracketError = new Codicon("bracket-error", { fontCharacter: "\\ebe6" });
Codicon.lockSmall = new Codicon("lock-small", { fontCharacter: "\\ebe7" });
Codicon.azureDevops = new Codicon("azure-devops", { fontCharacter: "\\ebe8" });
Codicon.verifiedFilled = new Codicon("verified-filled", { fontCharacter: "\\ebe9" });
Codicon.newLine = new Codicon("newline", { fontCharacter: "\\ebea" });
Codicon.layout = new Codicon("layout", { fontCharacter: "\\ebeb" });
Codicon.layoutActivitybarLeft = new Codicon("layout-activitybar-left", { fontCharacter: "\\ebec" });
Codicon.layoutActivitybarRight = new Codicon("layout-activitybar-right", { fontCharacter: "\\ebed" });
Codicon.layoutPanelLeft = new Codicon("layout-panel-left", { fontCharacter: "\\ebee" });
Codicon.layoutPanelCenter = new Codicon("layout-panel-center", { fontCharacter: "\\ebef" });
Codicon.layoutPanelJustify = new Codicon("layout-panel-justify", { fontCharacter: "\\ebf0" });
Codicon.layoutPanelRight = new Codicon("layout-panel-right", { fontCharacter: "\\ebf1" });
Codicon.layoutPanel = new Codicon("layout-panel", { fontCharacter: "\\ebf2" });
Codicon.layoutSidebarLeft = new Codicon("layout-sidebar-left", { fontCharacter: "\\ebf3" });
Codicon.layoutSidebarRight = new Codicon("layout-sidebar-right", { fontCharacter: "\\ebf4" });
Codicon.layoutStatusbar = new Codicon("layout-statusbar", { fontCharacter: "\\ebf5" });
Codicon.layoutMenubar = new Codicon("layout-menubar", { fontCharacter: "\\ebf6" });
Codicon.layoutCentered = new Codicon("layout-centered", { fontCharacter: "\\ebf7" });
Codicon.target = new Codicon("target", { fontCharacter: "\\ebf8" });
Codicon.indent = new Codicon("indent", { fontCharacter: "\\ebf9" });
Codicon.recordSmall = new Codicon("record-small", { fontCharacter: "\\ebfa" });
Codicon.errorSmall = new Codicon("error-small", { fontCharacter: "\\ebfb" });
Codicon.arrowCircleDown = new Codicon("arrow-circle-down", { fontCharacter: "\\ebfc" });
Codicon.arrowCircleLeft = new Codicon("arrow-circle-left", { fontCharacter: "\\ebfd" });
Codicon.arrowCircleRight = new Codicon("arrow-circle-right", { fontCharacter: "\\ebfe" });
Codicon.arrowCircleUp = new Codicon("arrow-circle-up", { fontCharacter: "\\ebff" });
Codicon.dialogError = new Codicon("dialog-error", Codicon.error.definition);
Codicon.dialogWarning = new Codicon("dialog-warning", Codicon.warning.definition);
Codicon.dialogInfo = new Codicon("dialog-info", Codicon.info.definition);
Codicon.dialogClose = new Codicon("dialog-close", Codicon.close.definition);
Codicon.treeItemExpanded = new Codicon("tree-item-expanded", Codicon.chevronDown.definition);
Codicon.treeFilterOnTypeOn = new Codicon("tree-filter-on-type-on", Codicon.listFilter.definition);
Codicon.treeFilterOnTypeOff = new Codicon("tree-filter-on-type-off", Codicon.listSelection.definition);
Codicon.treeFilterClear = new Codicon("tree-filter-clear", Codicon.close.definition);
Codicon.treeItemLoading = new Codicon("tree-item-loading", Codicon.loading.definition);
Codicon.menuSelection = new Codicon("menu-selection", Codicon.check.definition);
Codicon.menuSubmenu = new Codicon("menu-submenu", Codicon.chevronRight.definition);
Codicon.menuBarMore = new Codicon("menubar-more", Codicon.more.definition);
Codicon.scrollbarButtonLeft = new Codicon("scrollbar-button-left", Codicon.triangleLeft.definition);
Codicon.scrollbarButtonRight = new Codicon("scrollbar-button-right", Codicon.triangleRight.definition);
Codicon.scrollbarButtonUp = new Codicon("scrollbar-button-up", Codicon.triangleUp.definition);
Codicon.scrollbarButtonDown = new Codicon("scrollbar-button-down", Codicon.triangleDown.definition);
Codicon.toolBarMore = new Codicon("toolbar-more", Codicon.more.definition);
Codicon.quickInputBack = new Codicon("quick-input-back", Codicon.arrowLeft.definition);
var CSSIcon;
(function(CSSIcon2) {
  CSSIcon2.iconNameSegment = "[A-Za-z0-9]+";
  CSSIcon2.iconNameExpression = "[A-Za-z0-9-]+";
  CSSIcon2.iconModifierExpression = "~[A-Za-z]+";
  CSSIcon2.iconNameCharacter = "[A-Za-z0-9~-]";
  const cssIconIdRegex = new RegExp(`^(${CSSIcon2.iconNameExpression})(${CSSIcon2.iconModifierExpression})?$`);
  function asClassNameArray(icon) {
    if (icon instanceof Codicon) {
      return ["codicon", "codicon-" + icon.id];
    }
    const match = cssIconIdRegex.exec(icon.id);
    if (!match) {
      return asClassNameArray(Codicon.error);
    }
    let [, id, modifier] = match;
    const classNames = ["codicon", "codicon-" + id];
    if (modifier) {
      classNames.push("codicon-modifier-" + modifier.substr(1));
    }
    return classNames;
  }
  CSSIcon2.asClassNameArray = asClassNameArray;
  function asClassName(icon) {
    return asClassNameArray(icon).join(" ");
  }
  CSSIcon2.asClassName = asClassName;
  function asCSSSelector(icon) {
    return "." + asClassNameArray(icon).join(".");
  }
  CSSIcon2.asCSSSelector = asCSSSelector;
})(CSSIcon || (CSSIcon = {}));

// node_modules/monaco-editor/esm/vs/base/common/assert.js
function ok(value, message) {
  if (!value) {
    throw new Error(message ? `Assertion failed (${message})` : "Assertion Failed");
  }
}

// node_modules/monaco-editor/esm/vs/base/common/types.js
function isString(str) {
  return typeof str === "string";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function isNumber(obj) {
  return typeof obj === "number" && !isNaN(obj);
}
function isIterable(obj) {
  return !!obj && typeof obj[Symbol.iterator] === "function";
}
function isBoolean(obj) {
  return obj === true || obj === false;
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isDefined(arg) {
  return !isUndefinedOrNull(arg);
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
  }
}
function isFunction(obj) {
  return typeof obj === "function";
}
function validateConstraints(args, constraints) {
  const len = Math.min(args.length, constraints.length);
  for (let i = 0; i < len; i++) {
    validateConstraint(args[i], constraints[i]);
  }
}
function validateConstraint(arg, constraint) {
  if (isString(constraint)) {
    if (typeof arg !== constraint) {
      throw new Error(`argument does not match constraint: typeof ${constraint}`);
    }
  } else if (isFunction(constraint)) {
    try {
      if (arg instanceof constraint) {
        return;
      }
    } catch (_a3) {
    }
    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
      return;
    }
    if (constraint.length === 1 && constraint.call(void 0, arg) === true) {
      return;
    }
    throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
  }
}
function getAllPropertyNames(obj) {
  let res = [];
  let proto = Object.getPrototypeOf(obj);
  while (Object.prototype !== proto) {
    res = res.concat(Object.getOwnPropertyNames(proto));
    proto = Object.getPrototypeOf(proto);
  }
  return res;
}
function getAllMethodNames(obj) {
  const methods = [];
  for (const prop of getAllPropertyNames(obj)) {
    if (typeof obj[prop] === "function") {
      methods.push(prop);
    }
  }
  return methods;
}
function createProxyObject(methodNames, invoke) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  let result = {};
  for (const methodName of methodNames) {
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}
function withNullAsUndefined(x) {
  return x === null ? void 0 : x;
}
function assertNever(value, message = "Unreachable") {
  throw new Error(message);
}

// node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js
var RegistryImpl = class {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(id, data) {
    ok(isString(id));
    ok(isObject(data));
    ok(!this.data.has(id), "There is already an extension with this id");
    this.data.set(id, data);
  }
  as(id) {
    return this.data.get(id) || null;
  }
};
var Registry = new RegistryImpl();

// node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js
var ColorScheme;
(function(ColorScheme2) {
  ColorScheme2["DARK"] = "dark";
  ColorScheme2["LIGHT"] = "light";
  ColorScheme2["HIGH_CONTRAST"] = "hc";
})(ColorScheme || (ColorScheme = {}));

// node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js
var IThemeService = createDecorator("themeService");
var ThemeColor;
(function(ThemeColor2) {
  function isThemeColor(obj) {
    return obj && typeof obj === "object" && typeof obj.id === "string";
  }
  ThemeColor2.isThemeColor = isThemeColor;
})(ThemeColor || (ThemeColor = {}));
function themeColorFromId(id) {
  return { id };
}
var ThemeIcon;
(function(ThemeIcon2) {
  function isThemeIcon(obj) {
    return obj && typeof obj === "object" && typeof obj.id === "string" && (typeof obj.color === "undefined" || ThemeColor.isThemeColor(obj.color));
  }
  ThemeIcon2.isThemeIcon = isThemeIcon;
  const _regexFromString = new RegExp(`^\\$\\((${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?)\\)$`);
  function fromString(str) {
    const match = _regexFromString.exec(str);
    if (!match) {
      return void 0;
    }
    let [, name] = match;
    return { id: name };
  }
  ThemeIcon2.fromString = fromString;
  function fromId(id) {
    return { id };
  }
  ThemeIcon2.fromId = fromId;
  function modify(icon, modifier) {
    let id = icon.id;
    const tildeIndex = id.lastIndexOf("~");
    if (tildeIndex !== -1) {
      id = id.substring(0, tildeIndex);
    }
    if (modifier) {
      id = `${id}~${modifier}`;
    }
    return { id };
  }
  ThemeIcon2.modify = modify;
  function getModifier(icon) {
    const tildeIndex = icon.id.lastIndexOf("~");
    if (tildeIndex !== -1) {
      return icon.id.substring(tildeIndex + 1);
    }
    return void 0;
  }
  ThemeIcon2.getModifier = getModifier;
  function isEqual2(ti1, ti2) {
    var _a3, _b;
    return ti1.id === ti2.id && ((_a3 = ti1.color) === null || _a3 === void 0 ? void 0 : _a3.id) === ((_b = ti2.color) === null || _b === void 0 ? void 0 : _b.id);
  }
  ThemeIcon2.isEqual = isEqual2;
  function asThemeIcon(codicon, color) {
    return { id: codicon.id, color: color ? themeColorFromId(color) : void 0 };
  }
  ThemeIcon2.asThemeIcon = asThemeIcon;
  ThemeIcon2.asClassNameArray = CSSIcon.asClassNameArray;
  ThemeIcon2.asClassName = CSSIcon.asClassName;
  ThemeIcon2.asCSSSelector = CSSIcon.asCSSSelector;
})(ThemeIcon || (ThemeIcon = {}));
function getThemeTypeSelector(type) {
  switch (type) {
    case ColorScheme.DARK:
      return "vs-dark";
    case ColorScheme.HIGH_CONTRAST:
      return "hc-black";
    default:
      return "vs";
  }
}
var Extensions = {
  ThemingContribution: "base.contributions.theming"
};
var ThemingRegistry = class {
  constructor() {
    this.themingParticipants = [];
    this.themingParticipants = [];
    this.onThemingParticipantAddedEmitter = new Emitter();
  }
  onColorThemeChange(participant) {
    this.themingParticipants.push(participant);
    this.onThemingParticipantAddedEmitter.fire(participant);
    return toDisposable(() => {
      const idx = this.themingParticipants.indexOf(participant);
      this.themingParticipants.splice(idx, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
};
var themingRegistry = new ThemingRegistry();
Registry.add(Extensions.ThemingContribution, themingRegistry);
function registerThemingParticipant(participant) {
  return themingRegistry.onColorThemeChange(participant);
}
var Themable = class extends Disposable {
  constructor(themeService) {
    super();
    this.themeService = themeService;
    this.theme = themeService.getColorTheme();
    this._register(this.themeService.onDidColorThemeChange((theme) => this.onThemeChange(theme)));
  }
  onThemeChange(theme) {
    this.theme = theme;
    this.updateStyles();
  }
  updateStyles() {
  }
};

// node_modules/monaco-editor/esm/vs/base/common/actions.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Action = class extends Disposable {
  constructor(id, label = "", cssClass = "", enabled = true, actionCallback) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._enabled = true;
    this._id = id;
    this._label = label;
    this._cssClass = cssClass;
    this._enabled = enabled;
    this._actionCallback = actionCallback;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(value) {
    this._setLabel(value);
  }
  _setLabel(value) {
    if (this._label !== value) {
      this._label = value;
      this._onDidChange.fire({ label: value });
    }
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(value) {
    this._setTooltip(value);
  }
  _setTooltip(value) {
    if (this._tooltip !== value) {
      this._tooltip = value;
      this._onDidChange.fire({ tooltip: value });
    }
  }
  get class() {
    return this._cssClass;
  }
  set class(value) {
    this._setClass(value);
  }
  _setClass(value) {
    if (this._cssClass !== value) {
      this._cssClass = value;
      this._onDidChange.fire({ class: value });
    }
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._setEnabled(value);
  }
  _setEnabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      this._onDidChange.fire({ enabled: value });
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._setChecked(value);
  }
  _setChecked(value) {
    if (this._checked !== value) {
      this._checked = value;
      this._onDidChange.fire({ checked: value });
    }
  }
  run(event, data) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this._actionCallback) {
        yield this._actionCallback(event);
      }
    });
  }
};
var ActionRunner = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onBeforeRun = this._register(new Emitter());
    this.onBeforeRun = this._onBeforeRun.event;
    this._onDidRun = this._register(new Emitter());
    this.onDidRun = this._onDidRun.event;
  }
  run(action, context) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!action.enabled) {
        return;
      }
      this._onBeforeRun.fire({ action });
      let error = void 0;
      try {
        yield this.runAction(action, context);
      } catch (e) {
        error = e;
      }
      this._onDidRun.fire({ action, error });
    });
  }
  runAction(action, context) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield action.run(context);
    });
  }
};
var Separator = class _Separator extends Action {
  constructor(label) {
    super(_Separator.ID, label, label ? "separator text" : "separator");
    this.checked = false;
    this.enabled = false;
  }
};
Separator.ID = "vs.actions.separator";
var SubmenuAction = class {
  constructor(id, label, actions, cssClass) {
    this.tooltip = "";
    this.enabled = true;
    this.checked = void 0;
    this.id = id;
    this.label = label;
    this.class = cssClass;
    this._actions = actions;
  }
  get actions() {
    return this._actions;
  }
  dispose() {
  }
  run() {
    return __awaiter2(this, void 0, void 0, function* () {
    });
  }
};
var EmptySubmenuAction = class _EmptySubmenuAction extends Action {
  constructor() {
    super(_EmptySubmenuAction.ID, localize("submenu.empty", "(empty)"), void 0, false);
  }
};
EmptySubmenuAction.ID = "vs.actions.empty";

// node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js
var ICommandService = createDecorator("commandService");
var CommandsRegistry = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
    this._onDidRegisterCommand = new Emitter();
    this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(idOrCommand, handler) {
    if (!idOrCommand) {
      throw new Error(`invalid command`);
    }
    if (typeof idOrCommand === "string") {
      if (!handler) {
        throw new Error(`invalid command`);
      }
      return this.registerCommand({ id: idOrCommand, handler });
    }
    if (idOrCommand.description) {
      const constraints = [];
      for (let arg of idOrCommand.description.args) {
        constraints.push(arg.constraint);
      }
      const actualHandler = idOrCommand.handler;
      idOrCommand.handler = function(accessor, ...args) {
        validateConstraints(args, constraints);
        return actualHandler(accessor, ...args);
      };
    }
    const { id } = idOrCommand;
    let commands = this._commands.get(id);
    if (!commands) {
      commands = new LinkedList();
      this._commands.set(id, commands);
    }
    let removeFn = commands.unshift(idOrCommand);
    let ret = toDisposable(() => {
      removeFn();
      const command = this._commands.get(id);
      if (command === null || command === void 0 ? void 0 : command.isEmpty()) {
        this._commands.delete(id);
      }
    });
    this._onDidRegisterCommand.fire(id);
    return ret;
  }
  registerCommandAlias(oldId, newId) {
    return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));
  }
  getCommand(id) {
    const list = this._commands.get(id);
    if (!list || list.isEmpty()) {
      return void 0;
    }
    return Iterable.first(list);
  }
  getCommands() {
    const result = /* @__PURE__ */ new Map();
    for (const key of this._commands.keys()) {
      const command = this.getCommand(key);
      if (command) {
        result.set(key, command);
      }
    }
    return result;
  }
}();
CommandsRegistry.registerCommand("noop", () => {
});

// node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function isIMenuItem(item) {
  return item.command !== void 0;
}
var MenuId = class _MenuId {
  constructor(debugName) {
    this.id = _MenuId._idPool++;
    this._debugName = debugName;
  }
};
MenuId._idPool = 0;
MenuId.CommandPalette = new MenuId("CommandPalette");
MenuId.DebugBreakpointsContext = new MenuId("DebugBreakpointsContext");
MenuId.DebugCallStackContext = new MenuId("DebugCallStackContext");
MenuId.DebugConsoleContext = new MenuId("DebugConsoleContext");
MenuId.DebugVariablesContext = new MenuId("DebugVariablesContext");
MenuId.DebugWatchContext = new MenuId("DebugWatchContext");
MenuId.DebugToolBar = new MenuId("DebugToolBar");
MenuId.EditorContext = new MenuId("EditorContext");
MenuId.SimpleEditorContext = new MenuId("SimpleEditorContext");
MenuId.EditorContextCopy = new MenuId("EditorContextCopy");
MenuId.EditorContextPeek = new MenuId("EditorContextPeek");
MenuId.EditorTitle = new MenuId("EditorTitle");
MenuId.EditorTitleRun = new MenuId("EditorTitleRun");
MenuId.EditorTitleContext = new MenuId("EditorTitleContext");
MenuId.EmptyEditorGroup = new MenuId("EmptyEditorGroup");
MenuId.EmptyEditorGroupContext = new MenuId("EmptyEditorGroupContext");
MenuId.ExplorerContext = new MenuId("ExplorerContext");
MenuId.ExtensionContext = new MenuId("ExtensionContext");
MenuId.GlobalActivity = new MenuId("GlobalActivity");
MenuId.LayoutControlMenuSubmenu = new MenuId("LayoutControlMenuSubmenu");
MenuId.LayoutControlMenu = new MenuId("LayoutControlMenu");
MenuId.MenubarMainMenu = new MenuId("MenubarMainMenu");
MenuId.MenubarAppearanceMenu = new MenuId("MenubarAppearanceMenu");
MenuId.MenubarDebugMenu = new MenuId("MenubarDebugMenu");
MenuId.MenubarEditMenu = new MenuId("MenubarEditMenu");
MenuId.MenubarCopy = new MenuId("MenubarCopy");
MenuId.MenubarFileMenu = new MenuId("MenubarFileMenu");
MenuId.MenubarGoMenu = new MenuId("MenubarGoMenu");
MenuId.MenubarHelpMenu = new MenuId("MenubarHelpMenu");
MenuId.MenubarLayoutMenu = new MenuId("MenubarLayoutMenu");
MenuId.MenubarNewBreakpointMenu = new MenuId("MenubarNewBreakpointMenu");
MenuId.MenubarPanelAlignmentMenu = new MenuId("MenubarPanelAlignmentMenu");
MenuId.MenubarPanelPositionMenu = new MenuId("MenubarPanelPositionMenu");
MenuId.MenubarPreferencesMenu = new MenuId("MenubarPreferencesMenu");
MenuId.MenubarRecentMenu = new MenuId("MenubarRecentMenu");
MenuId.MenubarSelectionMenu = new MenuId("MenubarSelectionMenu");
MenuId.MenubarSwitchEditorMenu = new MenuId("MenubarSwitchEditorMenu");
MenuId.MenubarSwitchGroupMenu = new MenuId("MenubarSwitchGroupMenu");
MenuId.MenubarTerminalMenu = new MenuId("MenubarTerminalMenu");
MenuId.MenubarViewMenu = new MenuId("MenubarViewMenu");
MenuId.MenubarHomeMenu = new MenuId("MenubarHomeMenu");
MenuId.OpenEditorsContext = new MenuId("OpenEditorsContext");
MenuId.ProblemsPanelContext = new MenuId("ProblemsPanelContext");
MenuId.SCMChangeContext = new MenuId("SCMChangeContext");
MenuId.SCMResourceContext = new MenuId("SCMResourceContext");
MenuId.SCMResourceFolderContext = new MenuId("SCMResourceFolderContext");
MenuId.SCMResourceGroupContext = new MenuId("SCMResourceGroupContext");
MenuId.SCMSourceControl = new MenuId("SCMSourceControl");
MenuId.SCMTitle = new MenuId("SCMTitle");
MenuId.SearchContext = new MenuId("SearchContext");
MenuId.StatusBarWindowIndicatorMenu = new MenuId("StatusBarWindowIndicatorMenu");
MenuId.StatusBarRemoteIndicatorMenu = new MenuId("StatusBarRemoteIndicatorMenu");
MenuId.TestItem = new MenuId("TestItem");
MenuId.TestItemGutter = new MenuId("TestItemGutter");
MenuId.TestPeekElement = new MenuId("TestPeekElement");
MenuId.TestPeekTitle = new MenuId("TestPeekTitle");
MenuId.TouchBarContext = new MenuId("TouchBarContext");
MenuId.TitleBarContext = new MenuId("TitleBarContext");
MenuId.TunnelContext = new MenuId("TunnelContext");
MenuId.TunnelPrivacy = new MenuId("TunnelPrivacy");
MenuId.TunnelProtocol = new MenuId("TunnelProtocol");
MenuId.TunnelPortInline = new MenuId("TunnelInline");
MenuId.TunnelTitle = new MenuId("TunnelTitle");
MenuId.TunnelLocalAddressInline = new MenuId("TunnelLocalAddressInline");
MenuId.TunnelOriginInline = new MenuId("TunnelOriginInline");
MenuId.ViewItemContext = new MenuId("ViewItemContext");
MenuId.ViewContainerTitle = new MenuId("ViewContainerTitle");
MenuId.ViewContainerTitleContext = new MenuId("ViewContainerTitleContext");
MenuId.ViewTitle = new MenuId("ViewTitle");
MenuId.ViewTitleContext = new MenuId("ViewTitleContext");
MenuId.CommentThreadTitle = new MenuId("CommentThreadTitle");
MenuId.CommentThreadActions = new MenuId("CommentThreadActions");
MenuId.CommentTitle = new MenuId("CommentTitle");
MenuId.CommentActions = new MenuId("CommentActions");
MenuId.InteractiveToolbar = new MenuId("InteractiveToolbar");
MenuId.InteractiveCellTitle = new MenuId("InteractiveCellTitle");
MenuId.InteractiveCellExecute = new MenuId("InteractiveCellExecute");
MenuId.InteractiveInputExecute = new MenuId("InteractiveInputExecute");
MenuId.NotebookToolbar = new MenuId("NotebookToolbar");
MenuId.NotebookCellTitle = new MenuId("NotebookCellTitle");
MenuId.NotebookCellInsert = new MenuId("NotebookCellInsert");
MenuId.NotebookCellBetween = new MenuId("NotebookCellBetween");
MenuId.NotebookCellListTop = new MenuId("NotebookCellTop");
MenuId.NotebookCellExecute = new MenuId("NotebookCellExecute");
MenuId.NotebookCellExecutePrimary = new MenuId("NotebookCellExecutePrimary");
MenuId.NotebookDiffCellInputTitle = new MenuId("NotebookDiffCellInputTitle");
MenuId.NotebookDiffCellMetadataTitle = new MenuId("NotebookDiffCellMetadataTitle");
MenuId.NotebookDiffCellOutputsTitle = new MenuId("NotebookDiffCellOutputsTitle");
MenuId.NotebookOutputToolbar = new MenuId("NotebookOutputToolbar");
MenuId.NotebookEditorLayoutConfigure = new MenuId("NotebookEditorLayoutConfigure");
MenuId.BulkEditTitle = new MenuId("BulkEditTitle");
MenuId.BulkEditContext = new MenuId("BulkEditContext");
MenuId.TimelineItemContext = new MenuId("TimelineItemContext");
MenuId.TimelineTitle = new MenuId("TimelineTitle");
MenuId.TimelineTitleContext = new MenuId("TimelineTitleContext");
MenuId.AccountsContext = new MenuId("AccountsContext");
MenuId.PanelTitle = new MenuId("PanelTitle");
MenuId.AuxiliaryBarTitle = new MenuId("AuxiliaryBarTitle");
MenuId.TerminalInstanceContext = new MenuId("TerminalInstanceContext");
MenuId.TerminalEditorInstanceContext = new MenuId("TerminalEditorInstanceContext");
MenuId.TerminalNewDropdownContext = new MenuId("TerminalNewDropdownContext");
MenuId.TerminalTabContext = new MenuId("TerminalTabContext");
MenuId.TerminalTabEmptyAreaContext = new MenuId("TerminalTabEmptyAreaContext");
MenuId.TerminalInlineTabContext = new MenuId("TerminalInlineTabContext");
MenuId.WebviewContext = new MenuId("WebviewContext");
MenuId.InlineCompletionsActions = new MenuId("InlineCompletionsActions");
MenuId.NewFile = new MenuId("NewFile");
var IMenuService = createDecorator("menuService");
var MenuRegistry = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
    this._menuItems = /* @__PURE__ */ new Map();
    this._onDidChangeMenu = new Emitter();
    this.onDidChangeMenu = this._onDidChangeMenu.event;
    this._commandPaletteChangeEvent = {
      has: (id) => id === MenuId.CommandPalette
    };
  }
  addCommand(command) {
    return this.addCommands(Iterable.single(command));
  }
  addCommands(commands) {
    for (const command of commands) {
      this._commands.set(command.id, command);
    }
    this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
    return toDisposable(() => {
      let didChange = false;
      for (const command of commands) {
        didChange = this._commands.delete(command.id) || didChange;
      }
      if (didChange) {
        this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
      }
    });
  }
  getCommand(id) {
    return this._commands.get(id);
  }
  getCommands() {
    const map = /* @__PURE__ */ new Map();
    this._commands.forEach((value, key) => map.set(key, value));
    return map;
  }
  appendMenuItem(id, item) {
    return this.appendMenuItems(Iterable.single({ id, item }));
  }
  appendMenuItems(items) {
    const changedIds = /* @__PURE__ */ new Set();
    const toRemove = new LinkedList();
    for (const { id, item } of items) {
      let list = this._menuItems.get(id);
      if (!list) {
        list = new LinkedList();
        this._menuItems.set(id, list);
      }
      toRemove.push(list.push(item));
      changedIds.add(id);
    }
    this._onDidChangeMenu.fire(changedIds);
    return toDisposable(() => {
      if (toRemove.size > 0) {
        for (let fn of toRemove) {
          fn();
        }
        this._onDidChangeMenu.fire(changedIds);
        toRemove.clear();
      }
    });
  }
  getMenuItems(id) {
    let result;
    if (this._menuItems.has(id)) {
      result = [...this._menuItems.get(id)];
    } else {
      result = [];
    }
    if (id === MenuId.CommandPalette) {
      this._appendImplicitItems(result);
    }
    return result;
  }
  _appendImplicitItems(result) {
    const set = /* @__PURE__ */ new Set();
    for (const item of result) {
      if (isIMenuItem(item)) {
        set.add(item.command.id);
        if (item.alt) {
          set.add(item.alt.id);
        }
      }
    }
    this._commands.forEach((command, id) => {
      if (!set.has(id)) {
        result.push({ command });
      }
    });
  }
}();
var SubmenuItemAction = class extends SubmenuAction {
  constructor(item, _menuService, _contextKeyService, _options) {
    super(`submenuitem.${item.submenu.id}`, typeof item.title === "string" ? item.title : item.title.value, [], "submenu");
    this.item = item;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._options = _options;
  }
  get actions() {
    const result = [];
    const menu = this._menuService.createMenu(this.item.submenu, this._contextKeyService);
    const groups = menu.getActions(this._options);
    menu.dispose();
    for (const [, actions] of groups) {
      if (actions.length > 0) {
        result.push(...actions);
        result.push(new Separator());
      }
    }
    if (result.length) {
      result.pop();
    }
    return result;
  }
};
var MenuItemAction = class MenuItemAction2 {
  constructor(item, alt, options, contextKeyService, _commandService) {
    var _a3, _b;
    this._commandService = _commandService;
    this.id = item.id;
    this.label = (options === null || options === void 0 ? void 0 : options.renderShortTitle) && item.shortTitle ? typeof item.shortTitle === "string" ? item.shortTitle : item.shortTitle.value : typeof item.title === "string" ? item.title : item.title.value;
    this.tooltip = (_b = typeof item.tooltip === "string" ? item.tooltip : (_a3 = item.tooltip) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b !== void 0 ? _b : "";
    this.enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);
    this.checked = void 0;
    if (item.toggled) {
      const toggled = item.toggled.condition ? item.toggled : { condition: item.toggled };
      this.checked = contextKeyService.contextMatchesRules(toggled.condition);
      if (this.checked && toggled.tooltip) {
        this.tooltip = typeof toggled.tooltip === "string" ? toggled.tooltip : toggled.tooltip.value;
      }
      if (toggled.title) {
        this.label = typeof toggled.title === "string" ? toggled.title : toggled.title.value;
      }
    }
    this.item = item;
    this.alt = alt ? new MenuItemAction2(alt, void 0, options, contextKeyService, _commandService) : void 0;
    this._options = options;
    if (ThemeIcon.isThemeIcon(item.icon)) {
      this.class = CSSIcon.asClassName(item.icon);
    }
  }
  dispose() {
  }
  run(...args) {
    var _a3, _b;
    let runArgs = [];
    if ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.arg) {
      runArgs = [...runArgs, this._options.arg];
    }
    if ((_b = this._options) === null || _b === void 0 ? void 0 : _b.shouldForwardArgs) {
      runArgs = [...runArgs, ...args];
    }
    return this._commandService.executeCommand(this.id, ...runArgs);
  }
};
MenuItemAction = __decorate([
  __param(3, IContextKeyService),
  __param(4, ICommandService)
], MenuItemAction);

// node_modules/monaco-editor/esm/vs/base/common/process.js
var safeProcess;
if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
  const sandboxProcess = globals.vscode.process;
  safeProcess = {
    get platform() {
      return sandboxProcess.platform;
    },
    get arch() {
      return sandboxProcess.arch;
    },
    get env() {
      return sandboxProcess.env;
    },
    cwd() {
      return sandboxProcess.cwd();
    }
  };
} else if (typeof process !== "undefined") {
  safeProcess = {
    get platform() {
      return process.platform;
    },
    get arch() {
      return process.arch;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env["VSCODE_CWD"] || process.cwd();
    }
  };
} else {
  safeProcess = {
    // Supported
    get platform() {
      return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
    },
    get arch() {
      return void 0;
    },
    // Unsupported
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
}
var cwd = safeProcess.cwd;
var env = safeProcess.env;
var platform = safeProcess.platform;

// node_modules/monaco-editor/esm/vs/base/common/path.js
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;
var ErrorInvalidArgType = class extends Error {
  constructor(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.indexOf("not ") === 0) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    const type = name.indexOf(".") !== -1 ? "property" : "argument";
    let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
    msg += `. Received type ${typeof actual}`;
    super(msg);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new ErrorInvalidArgType(name, "string", value);
  }
}
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (isPathSeparator3(code)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator3(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep2, pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ErrorInvalidArgType("pathObject", "Object", pathObject);
  }
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
}
var win32 = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        path = pathSegments[i];
        validateString(path, "path");
        if (path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = cwd();
      } else {
        path = env[`=${resolvedDevice}`] || cwd();
        if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          path = `${resolvedDevice}\\`;
        }
      }
      const len = path.length;
      let rootEnd = 0;
      let device = "";
      let isAbsolute = false;
      const code = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          rootEnd = 1;
          isAbsolute = true;
        }
      } else if (isPathSeparator(code)) {
        isAbsolute = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len || j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute = true;
          rootEnd = 3;
        }
      }
      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }
      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute;
        if (isAbsolute && resolvedDevice.length > 0) {
          break;
        }
      }
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
  },
  normalize(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len === 1) {
      return isPosixPathSeparator(code) ? "\\" : path;
    }
    if (isPathSeparator(code)) {
      isAbsolute = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }
            if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      device = path.slice(0, 2);
      rootEnd = 2;
      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
        isAbsolute = true;
        rootEnd = 3;
      }
    }
    let tail3 = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
    if (tail3.length === 0 && !isAbsolute) {
      tail3 = ".";
    }
    if (tail3.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
      tail3 += "\\";
    }
    if (device === void 0) {
      return isAbsolute ? `\\${tail3}` : tail3;
    }
    return isAbsolute ? `${device}\\${tail3}` : `${device}${tail3}`;
  },
  isAbsolute(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return false;
    }
    const code = path.charCodeAt(0);
    return isPathSeparator(code) || // Possible device root
    len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    let firstPart;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = firstPart = arg;
        } else {
          joined += `\\${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    let needsReplace = true;
    let slashCount = 0;
    if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) {
            ++slashCount;
          } else {
            needsReplace = false;
          }
        }
      }
    }
    if (needsReplace) {
      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      }
      if (slashCount >= 2) {
        joined = `\\${joined.slice(slashCount)}`;
      }
    }
    return win32.normalize(joined);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    const fromOrig = win32.resolve(from);
    const toOrig = win32.resolve(to);
    if (fromOrig === toOrig) {
      return "";
    }
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) {
      return "";
    }
    let fromStart = 0;
    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    }
    let fromEnd = from.length;
    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    }
    let toEnd = to.length;
    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? ".." : "\\..";
      }
    }
    toStart += lastCommonSep;
    if (out.length > 0) {
      return `${out}${toOrig.slice(toStart, toEnd)}`;
    }
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      ++toStart;
    }
    return toOrig.slice(toStart, toEnd);
  },
  toNamespacedPath(path) {
    if (typeof path !== "string") {
      return path;
    }
    if (path.length === 0) {
      return "";
    }
    const resolvedPath = win32.resolve(path);
    if (resolvedPath.length <= 2) {
      return path;
    }
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
      return `\\\\?\\${resolvedPath}`;
    }
    return path;
  },
  dirname(path) {
    validateString(path, "path");
    const len = path.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = -1;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len === 1) {
      return isPathSeparator(code) ? path : ".";
    }
    if (isPathSeparator(code)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }
    let end = -1;
    let matchedSlash = true;
    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      if (rootEnd === -1) {
        return ".";
      }
      end = rootEnd;
    }
    return path.slice(0, end);
  },
  basename(path, ext) {
    if (ext !== void 0) {
      validateString(ext, "ext");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return "";
      }
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }
    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format2.bind(null, "\\"),
  parse(path) {
    validateString(path, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0) {
      return ret;
    }
    const len = path.length;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len === 1) {
      if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
      }
      ret.base = ret.name = path;
      return ret;
    }
    if (isPathSeparator(code)) {
      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      if (len <= 2) {
        ret.root = ret.dir = path;
        return ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 3;
      }
    }
    if (rootEnd > 0) {
      ret.root = path.slice(0, rootEnd);
    }
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= rootEnd; --i) {
      code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(startPart, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path.slice(0, startPart - 1);
    } else {
      ret.dir = ret.root;
    }
    return ret;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
};
var posix = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      const path = i >= 0 ? pathSegments[i] : cwd();
      validateString(path, "path");
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }
    return resolvedPath.length > 0 ? resolvedPath : ".";
  },
  normalize(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0) {
      if (isAbsolute) {
        return "/";
      }
      return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator) {
      path += "/";
    }
    return isAbsolute ? `/${path}` : path;
  },
  isAbsolute(path) {
    validateString(path, "path");
    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = arg;
        } else {
          joined += `/${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return posix.normalize(joined);
  },
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) {
      return "";
    }
    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i + 1);
        }
        if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? ".." : "/..";
      }
    }
    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },
  toNamespacedPath(path) {
    return path;
  },
  dirname(path) {
    validateString(path, "path");
    if (path.length === 0) {
      return ".";
    }
    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      return hasRoot ? "/" : ".";
    }
    if (hasRoot && end === 1) {
      return "//";
    }
    return path.slice(0, end);
  },
  basename(path, ext) {
    if (ext !== void 0) {
      validateString(ext, "ext");
    }
    validateString(path, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return "";
      }
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }
      return path.slice(start, end);
    }
    for (i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path.slice(start, end);
  },
  extname(path) {
    validateString(path, "path");
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: _format2.bind(null, "/"),
  parse(path) {
    validateString(path, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0) {
      return ret;
    }
    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;
    if (isAbsolute) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(start2, end);
      } else {
        ret.name = path.slice(start2, startDot);
        ret.base = path.slice(start2, end);
        ret.ext = path.slice(startDot, end);
      }
    }
    if (startPart > 0) {
      ret.dir = path.slice(0, startPart - 1);
    } else if (isAbsolute) {
      ret.dir = "/";
    }
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
var normalize = platform === "win32" ? win32.normalize : posix.normalize;
var resolve = platform === "win32" ? win32.resolve : posix.resolve;
var relative = platform === "win32" ? win32.relative : posix.relative;
var dirname = platform === "win32" ? win32.dirname : posix.dirname;
var basename = platform === "win32" ? win32.basename : posix.basename;
var extname = platform === "win32" ? win32.extname : posix.extname;
var sep = platform === "win32" ? win32.sep : posix.sep;

// node_modules/monaco-editor/esm/vs/base/common/uri.js
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }
      break;
  }
  return path;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = class _URI {
  /**
   * @internal
   */
  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  static isUri(thing) {
    if (thing instanceof _URI) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return uriToFsPath(this, false);
  }
  // ---- modify to new -------------------------
  with(change) {
    if (!change) {
      return this;
    }
    let { scheme, authority, path, query, fragment } = change;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path === void 0) {
      path = this.path;
    } else if (path === null) {
      path = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new Uri(scheme, authority, path, query, fragment);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(value, _strict = false) {
    const match = _regexp.exec(value);
    if (!match) {
      return new Uri(_empty, _empty, _empty, _empty, _empty);
    }
    return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(path) {
    let authority = _empty;
    if (isWindows) {
      path = path.replace(/\\/g, _slash);
    }
    if (path[0] === _slash && path[1] === _slash) {
      const idx = path.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path.substring(2);
        path = _slash;
      } else {
        authority = path.substring(2, idx);
        path = path.substring(idx) || _slash;
      }
    }
    return new Uri("file", authority, path, _empty, _empty);
  }
  static from(components) {
    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
    _validateUri(result, true);
    return result;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(uri, ...pathFragment) {
    if (!uri.path) {
      throw new Error(`[UriError]: cannot call joinPath on URI without path`);
    }
    let newPath;
    if (isWindows && uri.scheme === "file") {
      newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    } else {
      newPath = posix.join(uri.path, ...pathFragment);
    }
    return uri.with({ path: newPath });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(skipEncoding = false) {
    return _asFormatted(this, skipEncoding);
  }
  toJSON() {
    return this;
  }
  static revive(data) {
    if (!data) {
      return data;
    } else if (data instanceof _URI) {
      return data;
    } else {
      const result = new Uri(data);
      result._formatted = data.external;
      result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
      return result;
    }
  }
};
var _pathSepMarker = isWindows ? 1 : void 0;
var Uri = class extends URI {
  constructor() {
    super(...arguments);
    this._formatted = null;
    this._fsPath = null;
  }
  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = uriToFsPath(this, false);
    }
    return this._fsPath;
  }
  toString(skipEncoding = false) {
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  }
  toJSON() {
    const res = {
      $mid: 1
      /* Uri */
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  }
};
var encodeTable = {
  [
    58
    /* Colon */
  ]: "%3A",
  [
    47
    /* Slash */
  ]: "%2F",
  [
    63
    /* QuestionMark */
  ]: "%3F",
  [
    35
    /* Hash */
  ]: "%23",
  [
    91
    /* OpenSquareBracket */
  ]: "%5B",
  [
    93
    /* CloseSquareBracket */
  ]: "%5D",
  [
    64
    /* AtSign */
  ]: "%40",
  [
    33
    /* ExclamationMark */
  ]: "%21",
  [
    36
    /* DollarSign */
  ]: "%24",
  [
    38
    /* Ampersand */
  ]: "%26",
  [
    39
    /* SingleQuote */
  ]: "%27",
  [
    40
    /* OpenParen */
  ]: "%28",
  [
    41
    /* CloseParen */
  ]: "%29",
  [
    42
    /* Asterisk */
  ]: "%2A",
  [
    43
    /* Plus */
  ]: "%2B",
  [
    44
    /* Comma */
  ]: "%2C",
  [
    59
    /* Semicolon */
  ]: "%3B",
  [
    61
    /* Equals */
  ]: "%3D",
  [
    32
    /* Space */
  ]: "%20"
};
function encodeURIComponentFast(uriComponent, allowSlash) {
  let res = void 0;
  let nativeEncodePos = -1;
  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      const escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
  let res = void 0;
  for (let pos = 0; pos < path.length; pos++) {
    const code = path.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path[pos];
      }
    }
  }
  return res !== void 0 ? res : path;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = "";
  let { scheme, authority, path, query, fragment } = uri;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    let idx = authority.indexOf("@");
    if (idx !== -1) {
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
      const code = path.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
      const code = path.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
      }
    }
    res += encoder(path, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a3) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
}

// node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js
var ICodeEditorService = createDecorator("codeEditorService");

// node_modules/monaco-editor/esm/vs/editor/common/core/position.js
var Position = class _Position {
  constructor(lineNumber, column) {
    this.lineNumber = lineNumber;
    this.column = column;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(newLineNumber = this.lineNumber, newColumn = this.column) {
    if (newLineNumber === this.lineNumber && newColumn === this.column) {
      return this;
    } else {
      return new _Position(newLineNumber, newColumn);
    }
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(deltaLineNumber = 0, deltaColumn = 0) {
    return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
  }
  /**
   * Test if this position equals other position
   */
  equals(other) {
    return _Position.equals(this, other);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(a, b) {
    if (!a && !b) {
      return true;
    }
    return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(other) {
    return _Position.isBefore(this, other);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(a, b) {
    if (a.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a.lineNumber) {
      return false;
    }
    return a.column < b.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(other) {
    return _Position.isBeforeOrEqual(this, other);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(a, b) {
    if (a.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a.lineNumber) {
      return false;
    }
    return a.column <= b.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(a, b) {
    const aLineNumber = a.lineNumber | 0;
    const bLineNumber = b.lineNumber | 0;
    if (aLineNumber === bLineNumber) {
      const aColumn = a.column | 0;
      const bColumn = b.column | 0;
      return aColumn - bColumn;
    }
    return aLineNumber - bLineNumber;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new _Position(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(pos) {
    return new _Position(pos.lineNumber, pos.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(obj) {
    return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/model.js
var IModelService = createDecorator("modelService");

// node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js
var ITextModelService = createDecorator("textModelService");

// node_modules/monaco-editor/esm/vs/base/common/keybindings.js
function createKeybinding(keybinding, OS2) {
  if (keybinding === 0) {
    return null;
  }
  const firstPart = (keybinding & 65535) >>> 0;
  const chordPart = (keybinding & 4294901760) >>> 16;
  if (chordPart !== 0) {
    return new ChordKeybinding([
      createSimpleKeybinding(firstPart, OS2),
      createSimpleKeybinding(chordPart, OS2)
    ]);
  }
  return new ChordKeybinding([createSimpleKeybinding(firstPart, OS2)]);
}
function createSimpleKeybinding(keybinding, OS2) {
  const ctrlCmd = keybinding & 2048 ? true : false;
  const winCtrl = keybinding & 256 ? true : false;
  const ctrlKey = OS2 === 2 ? winCtrl : ctrlCmd;
  const shiftKey = keybinding & 1024 ? true : false;
  const altKey = keybinding & 512 ? true : false;
  const metaKey = OS2 === 2 ? ctrlCmd : winCtrl;
  const keyCode = keybinding & 255;
  return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
var SimpleKeybinding = class {
  constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyCode = keyCode;
  }
  equals(other) {
    return this.ctrlKey === other.ctrlKey && this.shiftKey === other.shiftKey && this.altKey === other.altKey && this.metaKey === other.metaKey && this.keyCode === other.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  toChord() {
    return new ChordKeybinding([this]);
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
};
var ChordKeybinding = class {
  constructor(parts) {
    if (parts.length === 0) {
      throw illegalArgument(`parts`);
    }
    this.parts = parts;
  }
};
var ResolvedKeybindingPart = class {
  constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyLabel = kbLabel;
    this.keyAriaLabel = kbAriaLabel;
  }
};
var ResolvedKeybinding = class {
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js
var KeybindingsRegistryImpl = class _KeybindingsRegistryImpl {
  constructor() {
    this._coreKeybindings = [];
    this._extensionKeybindings = [];
    this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(kb) {
    if (OS === 1) {
      if (kb && kb.win) {
        return kb.win;
      }
    } else if (OS === 2) {
      if (kb && kb.mac) {
        return kb.mac;
      }
    } else {
      if (kb && kb.linux) {
        return kb.linux;
      }
    }
    return kb;
  }
  registerKeybindingRule(rule) {
    const actualKb = _KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
    if (actualKb && actualKb.primary) {
      const kk = createKeybinding(actualKb.primary, OS);
      if (kk) {
        this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when);
      }
    }
    if (actualKb && Array.isArray(actualKb.secondary)) {
      for (let i = 0, len = actualKb.secondary.length; i < len; i++) {
        const k = actualKb.secondary[i];
        const kk = createKeybinding(k, OS);
        if (kk) {
          this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i - 1, rule.when);
        }
      }
    }
  }
  registerCommandAndKeybindingRule(desc) {
    this.registerKeybindingRule(desc);
    CommandsRegistry.registerCommand(desc);
  }
  static _mightProduceChar(keyCode) {
    if (keyCode >= 21 && keyCode <= 30) {
      return true;
    }
    if (keyCode >= 31 && keyCode <= 56) {
      return true;
    }
    return keyCode === 80 || keyCode === 81 || keyCode === 82 || keyCode === 83 || keyCode === 84 || keyCode === 85 || keyCode === 86 || keyCode === 110 || keyCode === 111 || keyCode === 87 || keyCode === 88 || keyCode === 89 || keyCode === 90 || keyCode === 91 || keyCode === 92;
  }
  _assertNoCtrlAlt(keybinding, commandId) {
    if (keybinding.ctrlKey && keybinding.altKey && !keybinding.metaKey) {
      if (_KeybindingsRegistryImpl._mightProduceChar(keybinding.keyCode)) {
        console.warn("Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", keybinding, " for ", commandId);
      }
    }
  }
  _registerDefaultKeybinding(keybinding, commandId, commandArgs, weight1, weight2, when) {
    if (OS === 1) {
      this._assertNoCtrlAlt(keybinding.parts[0], commandId);
    }
    this._coreKeybindings.push({
      keybinding: keybinding.parts,
      command: commandId,
      commandArgs,
      when,
      weight1,
      weight2,
      extensionId: null,
      isBuiltinExtension: false
    });
    this._cachedMergedKeybindings = null;
  }
  getDefaultKeybindings() {
    if (!this._cachedMergedKeybindings) {
      this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings);
      this._cachedMergedKeybindings.sort(sorter);
    }
    return this._cachedMergedKeybindings.slice(0);
  }
};
var KeybindingsRegistry = new KeybindingsRegistryImpl();
var Extensions2 = {
  EditorModes: "platform.keybindingsRegistry"
};
Registry.add(Extensions2.EditorModes, KeybindingsRegistry);
function sorter(a, b) {
  if (a.weight1 !== b.weight1) {
    return a.weight1 - b.weight1;
  }
  if (a.command < b.command) {
    return -1;
  }
  if (a.command > b.command) {
    return 1;
  }
  return a.weight2 - b.weight2;
}

// node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js
var ITelemetryService = createDecorator("telemetryService");

// node_modules/monaco-editor/esm/vs/platform/log/common/log.js
var ILogService = createDecorator("logService");
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warning"] = 3] = "Warning";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Critical"] = 5] = "Critical";
  LogLevel2[LogLevel2["Off"] = 6] = "Off";
})(LogLevel || (LogLevel = {}));
var DEFAULT_LOG_LEVEL = LogLevel.Info;
var AbstractLogger = class extends Disposable {
  constructor() {
    super(...arguments);
    this.level = DEFAULT_LOG_LEVEL;
    this._onDidChangeLogLevel = this._register(new Emitter());
  }
  setLevel(level) {
    if (this.level !== level) {
      this.level = level;
      this._onDidChangeLogLevel.fire(this.level);
    }
  }
  getLevel() {
    return this.level;
  }
};
var ConsoleLogger = class extends AbstractLogger {
  constructor(logLevel = DEFAULT_LOG_LEVEL) {
    super();
    this.setLevel(logLevel);
  }
  trace(message, ...args) {
    if (this.getLevel() <= LogLevel.Trace) {
      console.log("%cTRACE", "color: #888", message, ...args);
    }
  }
  debug(message, ...args) {
    if (this.getLevel() <= LogLevel.Debug) {
      console.log("%cDEBUG", "background: #eee; color: #888", message, ...args);
    }
  }
  info(message, ...args) {
    if (this.getLevel() <= LogLevel.Info) {
      console.log("%c INFO", "color: #33f", message, ...args);
    }
  }
  error(message, ...args) {
    if (this.getLevel() <= LogLevel.Error) {
      console.log("%c  ERR", "color: #f33", message, ...args);
    }
  }
  dispose() {
  }
};
var LogService = class extends Disposable {
  constructor(logger) {
    super();
    this.logger = logger;
    this._register(logger);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(message, ...args) {
    this.logger.trace(message, ...args);
  }
  debug(message, ...args) {
    this.logger.debug(message, ...args);
  }
  info(message, ...args) {
    this.logger.info(message, ...args);
  }
  error(message, ...args) {
    this.logger.error(message, ...args);
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js
var Command = class {
  constructor(opts) {
    this.id = opts.id;
    this.precondition = opts.precondition;
    this._kbOpts = opts.kbOpts;
    this._menuOpts = opts.menuOpts;
    this._description = opts.description;
  }
  register() {
    if (Array.isArray(this._menuOpts)) {
      this._menuOpts.forEach(this._registerMenuItem, this);
    } else if (this._menuOpts) {
      this._registerMenuItem(this._menuOpts);
    }
    if (this._kbOpts) {
      const kbOptsArr = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const kbOpts of kbOptsArr) {
        let kbWhen = kbOpts.kbExpr;
        if (this.precondition) {
          if (kbWhen) {
            kbWhen = ContextKeyExpr.and(kbWhen, this.precondition);
          } else {
            kbWhen = this.precondition;
          }
        }
        const desc = {
          id: this.id,
          weight: kbOpts.weight,
          args: kbOpts.args,
          when: kbWhen,
          primary: kbOpts.primary,
          secondary: kbOpts.secondary,
          win: kbOpts.win,
          linux: kbOpts.linux,
          mac: kbOpts.mac
        };
        KeybindingsRegistry.registerKeybindingRule(desc);
      }
    }
    CommandsRegistry.registerCommand({
      id: this.id,
      handler: (accessor, args) => this.runCommand(accessor, args),
      description: this._description
    });
  }
  _registerMenuItem(item) {
    MenuRegistry.appendMenuItem(item.menuId, {
      group: item.group,
      command: {
        id: this.id,
        title: item.title,
        icon: item.icon,
        precondition: this.precondition
      },
      when: item.when,
      order: item.order
    });
  }
};
var MultiCommand = class extends Command {
  constructor() {
    super(...arguments);
    this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(priority, name, implementation) {
    this._implementations.push({ priority, name, implementation });
    this._implementations.sort((a, b) => b.priority - a.priority);
    return {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++) {
          if (this._implementations[i].implementation === implementation) {
            this._implementations.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  runCommand(accessor, args) {
    const logService = accessor.get(ILogService);
    logService.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
    for (const impl of this._implementations) {
      const result = impl.implementation(accessor, args);
      if (result) {
        logService.trace(`Command '${this.id}' was handled by '${impl.name}'.`);
        if (typeof result === "boolean") {
          return;
        }
        return result;
      }
    }
    logService.trace(`The Command '${this.id}' was not handled by any implementation.`);
  }
};
var ProxyCommand = class extends Command {
  constructor(command, opts) {
    super(opts);
    this.command = command;
  }
  runCommand(accessor, args) {
    return this.command.runCommand(accessor, args);
  }
};
var EditorCommand = class _EditorCommand extends Command {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(controllerGetter) {
    return class EditorControllerCommandImpl extends _EditorCommand {
      constructor(opts) {
        super(opts);
        this._callback = opts.handler;
      }
      runEditorCommand(accessor, editor, args) {
        const controller = controllerGetter(editor);
        if (controller) {
          this._callback(controller, args);
        }
      }
    };
  }
  runCommand(accessor, args) {
    const codeEditorService = accessor.get(ICodeEditorService);
    const editor = codeEditorService.getFocusedCodeEditor() || codeEditorService.getActiveCodeEditor();
    if (!editor) {
      return;
    }
    return editor.invokeWithinContext((editorAccessor) => {
      const kbService = editorAccessor.get(IContextKeyService);
      if (!kbService.contextMatchesRules(withNullAsUndefined(this.precondition))) {
        return;
      }
      return this.runEditorCommand(editorAccessor, editor, args);
    });
  }
};
var EditorAction = class _EditorAction extends EditorCommand {
  constructor(opts) {
    super(_EditorAction.convertOptions(opts));
    this.label = opts.label;
    this.alias = opts.alias;
  }
  static convertOptions(opts) {
    let menuOpts;
    if (Array.isArray(opts.menuOpts)) {
      menuOpts = opts.menuOpts;
    } else if (opts.menuOpts) {
      menuOpts = [opts.menuOpts];
    } else {
      menuOpts = [];
    }
    function withDefaults(item) {
      if (!item.menuId) {
        item.menuId = MenuId.EditorContext;
      }
      if (!item.title) {
        item.title = opts.label;
      }
      item.when = ContextKeyExpr.and(opts.precondition, item.when);
      return item;
    }
    if (Array.isArray(opts.contextMenuOpts)) {
      menuOpts.push(...opts.contextMenuOpts.map(withDefaults));
    } else if (opts.contextMenuOpts) {
      menuOpts.push(withDefaults(opts.contextMenuOpts));
    }
    opts.menuOpts = menuOpts;
    return opts;
  }
  runEditorCommand(accessor, editor, args) {
    this.reportTelemetry(accessor, editor);
    return this.run(accessor, editor, args || {});
  }
  reportTelemetry(accessor, editor) {
    accessor.get(ITelemetryService).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
};
var MultiEditorAction = class extends EditorAction {
  constructor() {
    super(...arguments);
    this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(priority, implementation) {
    this._implementations.push([priority, implementation]);
    this._implementations.sort((a, b) => b[0] - a[0]);
    return {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++) {
          if (this._implementations[i][1] === implementation) {
            this._implementations.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  run(accessor, editor, args) {
    for (const impl of this._implementations) {
      const result = impl[1](accessor, editor, args);
      if (result) {
        if (typeof result === "boolean") {
          return;
        }
        return result;
      }
    }
  }
};
function registerEditorCommand(editorCommand) {
  EditorContributionRegistry.INSTANCE.registerEditorCommand(editorCommand);
  return editorCommand;
}
function registerEditorAction(ctor) {
  const action = new ctor();
  EditorContributionRegistry.INSTANCE.registerEditorAction(action);
  return action;
}
function registerMultiEditorAction(action) {
  EditorContributionRegistry.INSTANCE.registerEditorAction(action);
  return action;
}
function registerEditorContribution(id, ctor) {
  EditorContributionRegistry.INSTANCE.registerEditorContribution(id, ctor);
}
var EditorExtensionsRegistry;
(function(EditorExtensionsRegistry2) {
  function getEditorCommand(commandId) {
    return EditorContributionRegistry.INSTANCE.getEditorCommand(commandId);
  }
  EditorExtensionsRegistry2.getEditorCommand = getEditorCommand;
  function getEditorActions() {
    return EditorContributionRegistry.INSTANCE.getEditorActions();
  }
  EditorExtensionsRegistry2.getEditorActions = getEditorActions;
  function getEditorContributions() {
    return EditorContributionRegistry.INSTANCE.getEditorContributions();
  }
  EditorExtensionsRegistry2.getEditorContributions = getEditorContributions;
  function getSomeEditorContributions(ids) {
    return EditorContributionRegistry.INSTANCE.getEditorContributions().filter((c) => ids.indexOf(c.id) >= 0);
  }
  EditorExtensionsRegistry2.getSomeEditorContributions = getSomeEditorContributions;
  function getDiffEditorContributions() {
    return EditorContributionRegistry.INSTANCE.getDiffEditorContributions();
  }
  EditorExtensionsRegistry2.getDiffEditorContributions = getDiffEditorContributions;
})(EditorExtensionsRegistry || (EditorExtensionsRegistry = {}));
var Extensions3 = {
  EditorCommonContributions: "editor.contributions"
};
var EditorContributionRegistry = class {
  constructor() {
    this.editorContributions = [];
    this.diffEditorContributions = [];
    this.editorActions = [];
    this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(id, ctor) {
    this.editorContributions.push({ id, ctor });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(action) {
    action.register();
    this.editorActions.push(action);
  }
  getEditorActions() {
    return this.editorActions.slice(0);
  }
  registerEditorCommand(editorCommand) {
    editorCommand.register();
    this.editorCommands[editorCommand.id] = editorCommand;
  }
  getEditorCommand(commandId) {
    return this.editorCommands[commandId] || null;
  }
};
EditorContributionRegistry.INSTANCE = new EditorContributionRegistry();
Registry.add(Extensions3.EditorCommonContributions, EditorContributionRegistry.INSTANCE);
function registerCommand(command) {
  command.register();
  return command;
}
var UndoCommand = registerCommand(new MultiCommand({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2048 | 56
    /* KeyZ */
  },
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "1_do",
    title: localize({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("undo", "Undo"),
    order: 1
  }]
}));
registerCommand(new ProxyCommand(UndoCommand, { id: "default:undo", precondition: void 0 }));
var RedoCommand = registerCommand(new MultiCommand({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2048 | 55,
    secondary: [
      2048 | 1024 | 56
      /* KeyZ */
    ],
    mac: {
      primary: 2048 | 1024 | 56
      /* KeyZ */
    }
  },
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "1_do",
    title: localize({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("redo", "Redo"),
    order: 1
  }]
}));
registerCommand(new ProxyCommand(RedoCommand, { id: "default:redo", precondition: void 0 }));
var SelectAllCommand = registerCommand(new MultiCommand({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2048 | 31
    /* KeyA */
  },
  menuOpts: [{
    menuId: MenuId.MenubarSelectionMenu,
    group: "1_basic",
    title: localize({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("selectAll", "Select All"),
    order: 1
  }]
}));

// node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js
var EditorContextKeys;
(function(EditorContextKeys2) {
  EditorContextKeys2.editorSimpleInput = new RawContextKey("editorSimpleInput", false, true);
  EditorContextKeys2.editorTextFocus = new RawContextKey("editorTextFocus", false, localize("editorTextFocus", "Whether the editor text has focus (cursor is blinking)"));
  EditorContextKeys2.focus = new RawContextKey("editorFocus", false, localize("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)"));
  EditorContextKeys2.textInputFocus = new RawContextKey("textInputFocus", false, localize("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)"));
  EditorContextKeys2.readOnly = new RawContextKey("editorReadonly", false, localize("editorReadonly", "Whether the editor is read only"));
  EditorContextKeys2.inDiffEditor = new RawContextKey("inDiffEditor", false, localize("inDiffEditor", "Whether the context is a diff editor"));
  EditorContextKeys2.columnSelection = new RawContextKey("editorColumnSelection", false, localize("editorColumnSelection", "Whether `editor.columnSelection` is enabled"));
  EditorContextKeys2.writable = EditorContextKeys2.readOnly.toNegated();
  EditorContextKeys2.hasNonEmptySelection = new RawContextKey("editorHasSelection", false, localize("editorHasSelection", "Whether the editor has text selected"));
  EditorContextKeys2.hasOnlyEmptySelection = EditorContextKeys2.hasNonEmptySelection.toNegated();
  EditorContextKeys2.hasMultipleSelections = new RawContextKey("editorHasMultipleSelections", false, localize("editorHasMultipleSelections", "Whether the editor has multiple selections"));
  EditorContextKeys2.hasSingleSelection = EditorContextKeys2.hasMultipleSelections.toNegated();
  EditorContextKeys2.tabMovesFocus = new RawContextKey("editorTabMovesFocus", false, localize("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor"));
  EditorContextKeys2.tabDoesNotMoveFocus = EditorContextKeys2.tabMovesFocus.toNegated();
  EditorContextKeys2.isInWalkThroughSnippet = new RawContextKey("isInEmbeddedEditor", false, true);
  EditorContextKeys2.canUndo = new RawContextKey("canUndo", false, true);
  EditorContextKeys2.canRedo = new RawContextKey("canRedo", false, true);
  EditorContextKeys2.hoverVisible = new RawContextKey("editorHoverVisible", false, localize("editorHoverVisible", "Whether the editor hover is visible"));
  EditorContextKeys2.inCompositeEditor = new RawContextKey("inCompositeEditor", void 0, localize("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)"));
  EditorContextKeys2.notInCompositeEditor = EditorContextKeys2.inCompositeEditor.toNegated();
  EditorContextKeys2.languageId = new RawContextKey("editorLangId", "", localize("editorLangId", "The language identifier of the editor"));
  EditorContextKeys2.hasCompletionItemProvider = new RawContextKey("editorHasCompletionItemProvider", false, localize("editorHasCompletionItemProvider", "Whether the editor has a completion item provider"));
  EditorContextKeys2.hasCodeActionsProvider = new RawContextKey("editorHasCodeActionsProvider", false, localize("editorHasCodeActionsProvider", "Whether the editor has a code actions provider"));
  EditorContextKeys2.hasCodeLensProvider = new RawContextKey("editorHasCodeLensProvider", false, localize("editorHasCodeLensProvider", "Whether the editor has a code lens provider"));
  EditorContextKeys2.hasDefinitionProvider = new RawContextKey("editorHasDefinitionProvider", false, localize("editorHasDefinitionProvider", "Whether the editor has a definition provider"));
  EditorContextKeys2.hasDeclarationProvider = new RawContextKey("editorHasDeclarationProvider", false, localize("editorHasDeclarationProvider", "Whether the editor has a declaration provider"));
  EditorContextKeys2.hasImplementationProvider = new RawContextKey("editorHasImplementationProvider", false, localize("editorHasImplementationProvider", "Whether the editor has an implementation provider"));
  EditorContextKeys2.hasTypeDefinitionProvider = new RawContextKey("editorHasTypeDefinitionProvider", false, localize("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider"));
  EditorContextKeys2.hasHoverProvider = new RawContextKey("editorHasHoverProvider", false, localize("editorHasHoverProvider", "Whether the editor has a hover provider"));
  EditorContextKeys2.hasDocumentHighlightProvider = new RawContextKey("editorHasDocumentHighlightProvider", false, localize("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider"));
  EditorContextKeys2.hasDocumentSymbolProvider = new RawContextKey("editorHasDocumentSymbolProvider", false, localize("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider"));
  EditorContextKeys2.hasReferenceProvider = new RawContextKey("editorHasReferenceProvider", false, localize("editorHasReferenceProvider", "Whether the editor has a reference provider"));
  EditorContextKeys2.hasRenameProvider = new RawContextKey("editorHasRenameProvider", false, localize("editorHasRenameProvider", "Whether the editor has a rename provider"));
  EditorContextKeys2.hasSignatureHelpProvider = new RawContextKey("editorHasSignatureHelpProvider", false, localize("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider"));
  EditorContextKeys2.hasInlayHintsProvider = new RawContextKey("editorHasInlayHintsProvider", false, localize("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider"));
  EditorContextKeys2.hasDocumentFormattingProvider = new RawContextKey("editorHasDocumentFormattingProvider", false, localize("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider"));
  EditorContextKeys2.hasDocumentSelectionFormattingProvider = new RawContextKey("editorHasDocumentSelectionFormattingProvider", false, localize("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider"));
  EditorContextKeys2.hasMultipleDocumentFormattingProvider = new RawContextKey("editorHasMultipleDocumentFormattingProvider", false, localize("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers"));
  EditorContextKeys2.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey("editorHasMultipleDocumentSelectionFormattingProvider", false, localize("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(EditorContextKeys || (EditorContextKeys = {}));

// node_modules/monaco-editor/esm/vs/base/common/severity.js
var Severity;
(function(Severity2) {
  Severity2[Severity2["Ignore"] = 0] = "Ignore";
  Severity2[Severity2["Info"] = 1] = "Info";
  Severity2[Severity2["Warning"] = 2] = "Warning";
  Severity2[Severity2["Error"] = 3] = "Error";
})(Severity || (Severity = {}));
(function(Severity2) {
  const _error = "error";
  const _warning = "warning";
  const _warn = "warn";
  const _info = "info";
  const _ignore = "ignore";
  function fromValue(value) {
    if (!value) {
      return Severity2.Ignore;
    }
    if (equalsIgnoreCase(_error, value)) {
      return Severity2.Error;
    }
    if (equalsIgnoreCase(_warning, value) || equalsIgnoreCase(_warn, value)) {
      return Severity2.Warning;
    }
    if (equalsIgnoreCase(_info, value)) {
      return Severity2.Info;
    }
    return Severity2.Ignore;
  }
  Severity2.fromValue = fromValue;
  function toString(severity) {
    switch (severity) {
      case Severity2.Error:
        return _error;
      case Severity2.Warning:
        return _warning;
      case Severity2.Info:
        return _info;
      default:
        return _ignore;
    }
  }
  Severity2.toString = toString;
})(Severity || (Severity = {}));
var severity_default = Severity;

// node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js
var INotificationService = createDecorator("notificationService");
var NoOpNotification = class {
};

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js
var IContextViewService = createDecorator("contextViewService");
var IContextMenuService = createDecorator("contextMenuService");

// node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js
var IClipboardService = createDecorator("clipboardService");

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js
var IKeybindingService = createDecorator("keybindingService");

// node_modules/monaco-editor/esm/vs/base/parts/storage/common/storage.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StorageState;
(function(StorageState2) {
  StorageState2[StorageState2["None"] = 0] = "None";
  StorageState2[StorageState2["Initialized"] = 1] = "Initialized";
  StorageState2[StorageState2["Closed"] = 2] = "Closed";
})(StorageState || (StorageState = {}));
var Storage = class _Storage extends Disposable {
  constructor(database, options = /* @__PURE__ */ Object.create(null)) {
    super();
    this.database = database;
    this.options = options;
    this._onDidChangeStorage = this._register(new Emitter());
    this.onDidChangeStorage = this._onDidChangeStorage.event;
    this.state = StorageState.None;
    this.cache = /* @__PURE__ */ new Map();
    this.flushDelayer = new ThrottledDelayer(_Storage.DEFAULT_FLUSH_DELAY);
    this.pendingDeletes = /* @__PURE__ */ new Set();
    this.pendingInserts = /* @__PURE__ */ new Map();
    this.whenFlushedCallbacks = [];
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var _a3, _b;
    (_a3 = e.changed) === null || _a3 === void 0 ? void 0 : _a3.forEach((value, key) => this.accept(key, value));
    (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach((key) => this.accept(key, void 0));
  }
  accept(key, value) {
    if (this.state === StorageState.Closed) {
      return;
    }
    let changed = false;
    if (isUndefinedOrNull(value)) {
      changed = this.cache.delete(key);
    } else {
      const currentValue = this.cache.get(key);
      if (currentValue !== value) {
        this.cache.set(key, value);
        changed = true;
      }
    }
    if (changed) {
      this._onDidChangeStorage.fire(key);
    }
  }
  get(key, fallbackValue) {
    const value = this.cache.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value;
  }
  getBoolean(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value === "true";
  }
  getNumber(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return parseInt(value, 10);
  }
  set(key, value) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this.state === StorageState.Closed) {
        return;
      }
      if (isUndefinedOrNull(value)) {
        return this.delete(key);
      }
      const valueStr = String(value);
      const currentValue = this.cache.get(key);
      if (currentValue === valueStr) {
        return;
      }
      this.cache.set(key, valueStr);
      this.pendingInserts.set(key, valueStr);
      this.pendingDeletes.delete(key);
      this._onDidChangeStorage.fire(key);
      return this.doFlush();
    });
  }
  delete(key) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this.state === StorageState.Closed) {
        return;
      }
      const wasDeleted = this.cache.delete(key);
      if (!wasDeleted) {
        return;
      }
      if (!this.pendingDeletes.has(key)) {
        this.pendingDeletes.add(key);
      }
      this.pendingInserts.delete(key);
      this._onDidChangeStorage.fire(key);
      return this.doFlush();
    });
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  flushPending() {
    return __awaiter3(this, void 0, void 0, function* () {
      if (!this.hasPending) {
        return;
      }
      const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };
      this.pendingDeletes = /* @__PURE__ */ new Set();
      this.pendingInserts = /* @__PURE__ */ new Map();
      return this.database.updateItems(updateRequest).finally(() => {
        var _a3;
        if (!this.hasPending) {
          while (this.whenFlushedCallbacks.length) {
            (_a3 = this.whenFlushedCallbacks.pop()) === null || _a3 === void 0 ? void 0 : _a3();
          }
        }
      });
    });
  }
  doFlush(delay) {
    return __awaiter3(this, void 0, void 0, function* () {
      return this.flushDelayer.trigger(() => this.flushPending(), delay);
    });
  }
  dispose() {
    this.flushDelayer.dispose();
    super.dispose();
  }
};
Storage.DEFAULT_FLUSH_DELAY = 100;
var InMemoryStorageDatabase = class {
  constructor() {
    this.onDidChangeItemsExternal = Event.None;
    this.items = /* @__PURE__ */ new Map();
  }
  updateItems(request) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (request.insert) {
        request.insert.forEach((value, key) => this.items.set(key, value));
      }
      if (request.delete) {
        request.delete.forEach((key) => this.items.delete(key));
      }
    });
  }
};

// node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js
var TARGET_KEY = "__$__targetStorageMarker";
var IStorageService = createDecorator("storageService");
var WillSaveStateReason;
(function(WillSaveStateReason2) {
  WillSaveStateReason2[WillSaveStateReason2["NONE"] = 0] = "NONE";
  WillSaveStateReason2[WillSaveStateReason2["SHUTDOWN"] = 1] = "SHUTDOWN";
})(WillSaveStateReason || (WillSaveStateReason = {}));
var AbstractStorageService = class _AbstractStorageService extends Disposable {
  constructor(options = { flushInterval: _AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {
    super();
    this.options = options;
    this._onDidChangeValue = this._register(new PauseableEmitter());
    this._onDidChangeTarget = this._register(new PauseableEmitter());
    this._onWillSaveState = this._register(new Emitter());
    this.onWillSaveState = this._onWillSaveState.event;
    this._workspaceKeyTargets = void 0;
    this._globalKeyTargets = void 0;
  }
  emitDidChangeValue(scope, key) {
    if (key === TARGET_KEY) {
      if (scope === 0) {
        this._globalKeyTargets = void 0;
      } else if (scope === 1) {
        this._workspaceKeyTargets = void 0;
      }
      this._onDidChangeTarget.fire({ scope });
    } else {
      this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key] });
    }
  }
  get(key, scope, fallbackValue) {
    var _a3;
    return (_a3 = this.getStorage(scope)) === null || _a3 === void 0 ? void 0 : _a3.get(key, fallbackValue);
  }
  getBoolean(key, scope, fallbackValue) {
    var _a3;
    return (_a3 = this.getStorage(scope)) === null || _a3 === void 0 ? void 0 : _a3.getBoolean(key, fallbackValue);
  }
  getNumber(key, scope, fallbackValue) {
    var _a3;
    return (_a3 = this.getStorage(scope)) === null || _a3 === void 0 ? void 0 : _a3.getNumber(key, fallbackValue);
  }
  store(key, value, scope, target) {
    if (isUndefinedOrNull(value)) {
      this.remove(key, scope);
      return;
    }
    this.withPausedEmitters(() => {
      var _a3;
      this.updateKeyTarget(key, scope, target);
      (_a3 = this.getStorage(scope)) === null || _a3 === void 0 ? void 0 : _a3.set(key, value);
    });
  }
  remove(key, scope) {
    this.withPausedEmitters(() => {
      var _a3;
      this.updateKeyTarget(key, scope, void 0);
      (_a3 = this.getStorage(scope)) === null || _a3 === void 0 ? void 0 : _a3.delete(key);
    });
  }
  withPausedEmitters(fn) {
    this._onDidChangeValue.pause();
    this._onDidChangeTarget.pause();
    try {
      fn();
    } finally {
      this._onDidChangeValue.resume();
      this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(key, scope, target) {
    var _a3, _b;
    const keyTargets = this.getKeyTargets(scope);
    if (typeof target === "number") {
      if (keyTargets[key] !== target) {
        keyTargets[key] = target;
        (_a3 = this.getStorage(scope)) === null || _a3 === void 0 ? void 0 : _a3.set(TARGET_KEY, JSON.stringify(keyTargets));
      }
    } else {
      if (typeof keyTargets[key] === "number") {
        delete keyTargets[key];
        (_b = this.getStorage(scope)) === null || _b === void 0 ? void 0 : _b.set(TARGET_KEY, JSON.stringify(keyTargets));
      }
    }
  }
  get workspaceKeyTargets() {
    if (!this._workspaceKeyTargets) {
      this._workspaceKeyTargets = this.loadKeyTargets(
        1
        /* WORKSPACE */
      );
    }
    return this._workspaceKeyTargets;
  }
  get globalKeyTargets() {
    if (!this._globalKeyTargets) {
      this._globalKeyTargets = this.loadKeyTargets(
        0
        /* GLOBAL */
      );
    }
    return this._globalKeyTargets;
  }
  getKeyTargets(scope) {
    return scope === 0 ? this.globalKeyTargets : this.workspaceKeyTargets;
  }
  loadKeyTargets(scope) {
    const keysRaw = this.get(TARGET_KEY, scope);
    if (keysRaw) {
      try {
        return JSON.parse(keysRaw);
      } catch (error) {
      }
    }
    return /* @__PURE__ */ Object.create(null);
  }
};
AbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
var InMemoryStorageService = class extends AbstractStorageService {
  constructor() {
    super();
    this.globalStorage = this._register(new Storage(new InMemoryStorageDatabase()));
    this.workspaceStorage = this._register(new Storage(new InMemoryStorageDatabase()));
    this._register(this.workspaceStorage.onDidChangeStorage((key) => this.emitDidChangeValue(1, key)));
    this._register(this.globalStorage.onDidChangeStorage((key) => this.emitDidChangeValue(0, key)));
  }
  getStorage(scope) {
    return scope === 0 ? this.globalStorage : this.workspaceStorage;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
var DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
var _defaultConfig = {
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
};
function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, wordDefinition, text, textOffset, config);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
      break;
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match) {
      break;
    }
    match = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match) {
    const result = {
      word: match[0],
      startColumn: textOffset + 1 + match.index,
      endColumn: textOffset + 1 + match.index + match[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match;
  while (match = wordDefinition.exec(text)) {
    const matchIndex = match.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/base/common/arrays.js
function tail(array, n = 0) {
  return array[array.length - (1 + n)];
}
function tail2(arr) {
  if (arr.length === 0) {
    throw new Error("Invalid tail call");
  }
  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function binarySearch(array, key, comparator) {
  let low = 0, high = array.length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = comparator(array[mid], key);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
function findFirstInSorted(array, p) {
  let low = 0, high = array.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (p(array[mid])) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  return low;
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
function distinct(array, keyFn = (value) => value) {
  const seen = /* @__PURE__ */ new Set();
  return array.filter((element) => {
    const key = keyFn(element);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
function findLast(arr, predicate) {
  const idx = lastIndex(arr, predicate);
  if (idx === -1) {
    return void 0;
  }
  return arr[idx];
}
function lastIndex(array, fn) {
  for (let i = array.length - 1; i >= 0; i--) {
    const element = array[i];
    if (fn(element)) {
      return i;
    }
  }
  return -1;
}
function firstOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[0] : notFoundValue;
}
function flatten(arr) {
  return [].concat(...arr);
}
function range(arg, to) {
  let from = typeof to === "number" ? arg : 0;
  if (typeof to === "number") {
    from = arg;
  } else {
    from = 0;
    to = arg;
  }
  const result = [];
  if (from <= to) {
    for (let i = from; i < to; i++) {
      result.push(i);
    }
  } else {
    for (let i = from; i > to; i--) {
      result.push(i);
    }
  }
  return result;
}
function arrayInsert(target, insertIndex, insertArr) {
  const before = target.slice(0, insertIndex);
  const after = target.slice(insertIndex);
  return before.concat(insertArr, after);
}
function pushToStart(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
    arr.unshift(value);
  }
}
function pushToEnd(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
    arr.push(value);
  }
}
function insertInto(array, start, newItems) {
  const startIdx = getActualStartIndex(array, start);
  const originalLength = array.length;
  const newItemsLength = newItems.length;
  array.length = originalLength + newItemsLength;
  for (let i = originalLength - 1; i >= startIdx; i--) {
    array[i + newItemsLength] = array[i];
  }
  for (let i = 0; i < newItemsLength; i++) {
    array[i + startIdx] = newItems[i];
  }
}
function splice(array, start, deleteCount, newItems) {
  const index = getActualStartIndex(array, start);
  const result = array.splice(index, deleteCount);
  insertInto(array, index, newItems);
  return result;
}
function getActualStartIndex(array, start) {
  return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
}
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function findMaxBy(items, comparator) {
  if (items.length === 0) {
    return void 0;
  }
  let max = items[0];
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    if (comparator(item, max) > 0) {
      max = item;
    }
  }
  return max;
}
function findLastMaxBy(items, comparator) {
  if (items.length === 0) {
    return void 0;
  }
  let max = items[0];
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    if (comparator(item, max) >= 0) {
      max = item;
    }
  }
  return max;
}
function findMinBy(items, comparator) {
  return findMaxBy(items, (a, b) => -comparator(a, b));
}
var ArrayQueue = class {
  /**
   * Constructs a queue that is backed by the given array. Runtime is O(1).
  */
  constructor(items) {
    this.items = items;
    this.firstIdx = 0;
    this.lastIdx = this.items.length - 1;
  }
  /**
   * Consumes elements from the beginning of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
  */
  takeWhile(predicate) {
    let startIdx = this.firstIdx;
    while (startIdx < this.items.length && predicate(this.items[startIdx])) {
      startIdx++;
    }
    const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
    this.firstIdx = startIdx;
    return result;
  }
  /**
   * Consumes elements from the end of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned.
   * The result has the same order as the underlying array!
  */
  takeFromEndWhile(predicate) {
    let endIdx = this.lastIdx;
    while (endIdx >= 0 && predicate(this.items[endIdx])) {
      endIdx--;
    }
    const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
    this.lastIdx = endIdx;
    return result;
  }
  peek() {
    return this.items[this.firstIdx];
  }
  dequeue() {
    const result = this.items[this.firstIdx];
    this.firstIdx++;
    return result;
  }
  takeCount(count) {
    const result = this.items.slice(this.firstIdx, this.firstIdx + count);
    this.firstIdx += count;
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/objects.js
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    const obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        const prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function mixin(destination, source, overwrite = true) {
  if (!isObject(destination)) {
    return source;
  }
  if (isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (isObject(destination[key]) && isObject(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals2(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals2(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function getOrDefault(obj, fn, defaultValue) {
  const result = fn(obj);
  return typeof result === "undefined" ? defaultValue : result;
}

// node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js
var EDITOR_MODEL_DEFAULTS = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: true,
  detectIndentation: true,
  trimAutoWhitespace: true,
  largeFileOptimizations: true,
  bracketPairColorizationOptions: { enabled: false }
};

// node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
var KeyCodeStrMap = class {
  constructor() {
    this._keyCodeToStr = [];
    this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(keyCode, str) {
    this._keyCodeToStr[keyCode] = str;
    this._strToKeyCode[str.toLowerCase()] = keyCode;
  }
  keyCodeToStr(keyCode) {
    return this._keyCodeToStr[keyCode];
  }
  strToKeyCode(str) {
    return this._strToKeyCode[str.toLowerCase()] || 0;
  }
};
var uiMap = new KeyCodeStrMap();
var userSettingsUSMap = new KeyCodeStrMap();
var userSettingsGeneralMap = new KeyCodeStrMap();
var EVENT_KEY_CODE_MAP = new Array(230);
var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
var scanCodeIntToStr = [];
var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
var IMMUTABLE_CODE_TO_KEY_CODE = [];
var IMMUTABLE_KEY_CODE_TO_CODE = [];
for (let i = 0; i <= 193; i++) {
  IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
}
for (let i = 0; i <= 127; i++) {
  IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
}
(function() {
  const empty = "";
  const mappings = [
    // keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [0, 1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
    [0, 1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
    [0, 1, 2, "Super", 0, empty, 0, empty, empty, empty],
    [0, 1, 3, "Fn", 0, empty, 0, empty, empty, empty],
    [0, 1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
    [0, 1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
    [0, 1, 6, "Resume", 0, empty, 0, empty, empty, empty],
    [0, 1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
    [0, 1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
    [0, 1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
    [31, 0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
    [32, 0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
    [33, 0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
    [34, 0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
    [35, 0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
    [36, 0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
    [37, 0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
    [38, 0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
    [39, 0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
    [40, 0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
    [41, 0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
    [42, 0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
    [43, 0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
    [44, 0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
    [45, 0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
    [46, 0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
    [47, 0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
    [48, 0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
    [49, 0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
    [50, 0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
    [51, 0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
    [52, 0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
    [53, 0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
    [54, 0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
    [55, 0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
    [56, 0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
    [22, 0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
    [23, 0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
    [24, 0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
    [25, 0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
    [26, 0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
    [27, 0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
    [28, 0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
    [29, 0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
    [30, 0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
    [21, 0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
    [3, 1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
    [9, 1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
    [1, 1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
    [2, 1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
    [10, 1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
    [83, 0, 51, "Minus", 83, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [81, 0, 52, "Equal", 81, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [87, 0, 53, "BracketLeft", 87, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [89, 0, 54, "BracketRight", 89, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [88, 0, 55, "Backslash", 88, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
    [80, 0, 57, "Semicolon", 80, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [90, 0, 58, "Quote", 90, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [86, 0, 59, "Backquote", 86, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [82, 0, 60, "Comma", 82, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [84, 0, 61, "Period", 84, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [85, 0, 62, "Slash", 85, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [8, 1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
    [59, 1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
    [60, 1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
    [61, 1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
    [62, 1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
    [63, 1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
    [64, 1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
    [65, 1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
    [66, 1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
    [67, 1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
    [68, 1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
    [69, 1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
    [70, 1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
    [0, 1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
    [79, 1, 77, "ScrollLock", 79, "ScrollLock", 145, "VK_SCROLL", empty, empty],
    [7, 1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
    [19, 1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
    [14, 1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
    [11, 1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
    [20, 1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
    [13, 1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
    [12, 1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
    [17, 1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
    [15, 1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
    [18, 1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
    [16, 1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
    [78, 1, 89, "NumLock", 78, "NumLock", 144, "VK_NUMLOCK", empty, empty],
    [108, 1, 90, "NumpadDivide", 108, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
    [103, 1, 91, "NumpadMultiply", 103, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
    [106, 1, 92, "NumpadSubtract", 106, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
    [104, 1, 93, "NumpadAdd", 104, "NumPad_Add", 107, "VK_ADD", empty, empty],
    [3, 1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
    [94, 1, 95, "Numpad1", 94, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
    [95, 1, 96, "Numpad2", 95, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
    [96, 1, 97, "Numpad3", 96, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
    [97, 1, 98, "Numpad4", 97, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
    [98, 1, 99, "Numpad5", 98, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
    [99, 1, 100, "Numpad6", 99, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
    [100, 1, 101, "Numpad7", 100, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
    [101, 1, 102, "Numpad8", 101, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
    [102, 1, 103, "Numpad9", 102, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
    [93, 1, 104, "Numpad0", 93, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
    [107, 1, 105, "NumpadDecimal", 107, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
    [92, 0, 106, "IntlBackslash", 92, "OEM_102", 226, "VK_OEM_102", empty, empty],
    [58, 1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
    [0, 1, 108, "Power", 0, empty, 0, empty, empty, empty],
    [0, 1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
    [71, 1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
    [72, 1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
    [73, 1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
    [74, 1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
    [75, 1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
    [76, 1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
    [77, 1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
    [0, 1, 117, "F20", 0, empty, 0, "VK_F20", empty, empty],
    [0, 1, 118, "F21", 0, empty, 0, "VK_F21", empty, empty],
    [0, 1, 119, "F22", 0, empty, 0, "VK_F22", empty, empty],
    [0, 1, 120, "F23", 0, empty, 0, "VK_F23", empty, empty],
    [0, 1, 121, "F24", 0, empty, 0, "VK_F24", empty, empty],
    [0, 1, 122, "Open", 0, empty, 0, empty, empty, empty],
    [0, 1, 123, "Help", 0, empty, 0, empty, empty, empty],
    [0, 1, 124, "Select", 0, empty, 0, empty, empty, empty],
    [0, 1, 125, "Again", 0, empty, 0, empty, empty, empty],
    [0, 1, 126, "Undo", 0, empty, 0, empty, empty, empty],
    [0, 1, 127, "Cut", 0, empty, 0, empty, empty, empty],
    [0, 1, 128, "Copy", 0, empty, 0, empty, empty, empty],
    [0, 1, 129, "Paste", 0, empty, 0, empty, empty, empty],
    [0, 1, 130, "Find", 0, empty, 0, empty, empty, empty],
    [0, 1, 131, "AudioVolumeMute", 112, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
    [0, 1, 132, "AudioVolumeUp", 113, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
    [0, 1, 133, "AudioVolumeDown", 114, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
    [105, 1, 134, "NumpadComma", 105, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
    [110, 0, 135, "IntlRo", 110, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
    [0, 1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
    [0, 0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
    [0, 1, 138, "Convert", 0, empty, 0, empty, empty, empty],
    [0, 1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
    [0, 1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
    [0, 1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
    [0, 1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
    [0, 1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
    [0, 1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
    [0, 1, 145, "Abort", 0, empty, 0, empty, empty, empty],
    [0, 1, 146, "Props", 0, empty, 0, empty, empty, empty],
    [0, 1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
    [0, 1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
    [0, 1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
    [0, 1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
    [0, 1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
    [0, 1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
    [0, 1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
    [0, 1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
    [0, 1, 155, "NumpadClear", 126, "Clear", 12, "VK_CLEAR", empty, empty],
    [0, 1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
    [5, 1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
    [4, 1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
    [6, 1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
    [57, 1, 0, empty, 57, "Meta", 0, "VK_COMMAND", empty, empty],
    [5, 1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
    [4, 1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
    [6, 1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
    [57, 1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
    [5, 1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
    [4, 1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
    [6, 1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
    [57, 1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
    [0, 1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
    [0, 1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
    [0, 1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
    [0, 1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
    [0, 1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
    [0, 1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
    [114, 1, 171, "MediaTrackNext", 119, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
    [115, 1, 172, "MediaTrackPrevious", 120, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
    [116, 1, 173, "MediaStop", 121, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
    [0, 1, 174, "Eject", 0, empty, 0, empty, empty, empty],
    [117, 1, 175, "MediaPlayPause", 122, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
    [0, 1, 176, "MediaSelect", 123, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
    [0, 1, 177, "LaunchMail", 124, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
    [0, 1, 178, "LaunchApp2", 125, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
    [0, 1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
    [0, 1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
    [0, 1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
    [0, 1, 182, "BrowserSearch", 115, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
    [0, 1, 183, "BrowserHome", 116, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
    [112, 1, 184, "BrowserBack", 117, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
    [113, 1, 185, "BrowserForward", 118, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
    [0, 1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
    [0, 1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
    [0, 1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
    [0, 1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
    [0, 1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
    [0, 1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
    [0, 1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [109, 1, 0, empty, 109, "KeyInComposition", 229, empty, empty, empty],
    [111, 1, 0, empty, 111, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
    [91, 1, 0, empty, 91, "OEM_8", 223, "VK_OEM_8", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
    [0, 1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
  ];
  let seenKeyCode = [];
  let seenScanCode = [];
  for (const mapping of mappings) {
    const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
    if (!seenScanCode[scanCode]) {
      seenScanCode[scanCode] = true;
      scanCodeIntToStr[scanCode] = scanCodeStr;
      scanCodeStrToInt[scanCodeStr] = scanCode;
      scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
      if (immutable) {
        IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
        if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
          IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
        }
      }
    }
    if (!seenKeyCode[keyCode]) {
      seenKeyCode[keyCode] = true;
      if (!keyCodeStr) {
        throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
      }
      uiMap.define(keyCode, keyCodeStr);
      userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
      userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
    }
    if (eventKeyCode) {
      EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
    }
    if (vkey) {
      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
    }
  }
  IMMUTABLE_KEY_CODE_TO_CODE[
    3
    /* Enter */
  ] = 46;
})();
var KeyCodeUtils;
(function(KeyCodeUtils2) {
  function toString(keyCode) {
    return uiMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toString = toString;
  function fromString(key) {
    return uiMap.strToKeyCode(key);
  }
  KeyCodeUtils2.fromString = fromString;
  function toUserSettingsUS(keyCode) {
    return userSettingsUSMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
  function toUserSettingsGeneral(keyCode) {
    return userSettingsGeneralMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
  function fromUserSettings(key) {
    return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
  }
  KeyCodeUtils2.fromUserSettings = fromUserSettings;
  function toElectronAccelerator(keyCode) {
    if (keyCode >= 93 && keyCode <= 108) {
      return null;
    }
    switch (keyCode) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return uiMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
  const chordPart = (secondPart & 65535) << 16 >>> 0;
  return (firstPart | chordPart) >>> 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/core/range.js
var Range = class _Range {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
      this.startLineNumber = endLineNumber;
      this.startColumn = endColumn;
      this.endLineNumber = startLineNumber;
      this.endColumn = startColumn;
    } else {
      this.startLineNumber = startLineNumber;
      this.startColumn = startColumn;
      this.endLineNumber = endLineNumber;
      this.endColumn = endColumn;
    }
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return _Range.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(range2) {
    return range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(position) {
    return _Range.containsPosition(this, position);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(range2, position) {
    if (position.lineNumber < range2.startLineNumber || position.lineNumber > range2.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range2.startLineNumber && position.column < range2.startColumn) {
      return false;
    }
    if (position.lineNumber === range2.endLineNumber && position.column > range2.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(range2, position) {
    if (position.lineNumber < range2.startLineNumber || position.lineNumber > range2.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range2.startLineNumber && position.column <= range2.startColumn) {
      return false;
    }
    if (position.lineNumber === range2.endLineNumber && position.column >= range2.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(range2) {
    return _Range.containsRange(this, range2);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(range2, otherRange) {
    if (otherRange.startLineNumber < range2.startLineNumber || otherRange.endLineNumber < range2.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range2.endLineNumber || otherRange.endLineNumber > range2.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range2.startLineNumber && otherRange.startColumn < range2.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range2.endLineNumber && otherRange.endColumn > range2.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(range2) {
    return _Range.strictContainsRange(this, range2);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(range2, otherRange) {
    if (otherRange.startLineNumber < range2.startLineNumber || otherRange.endLineNumber < range2.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range2.endLineNumber || otherRange.endLineNumber > range2.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range2.startLineNumber && otherRange.startColumn <= range2.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range2.endLineNumber && otherRange.endColumn >= range2.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(range2) {
    return _Range.plusRange(this, range2);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(a, b) {
    let startLineNumber;
    let startColumn;
    let endLineNumber;
    let endColumn;
    if (b.startLineNumber < a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = b.startColumn;
    } else if (b.startLineNumber === a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = Math.min(b.startColumn, a.startColumn);
    } else {
      startLineNumber = a.startLineNumber;
      startColumn = a.startColumn;
    }
    if (b.endLineNumber > a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = b.endColumn;
    } else if (b.endLineNumber === a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = Math.max(b.endColumn, a.endColumn);
    } else {
      endLineNumber = a.endLineNumber;
      endColumn = a.endColumn;
    }
    return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(range2) {
    return _Range.intersectRanges(this, range2);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(a, b) {
    let resultStartLineNumber = a.startLineNumber;
    let resultStartColumn = a.startColumn;
    let resultEndLineNumber = a.endLineNumber;
    let resultEndColumn = a.endColumn;
    let otherStartLineNumber = b.startLineNumber;
    let otherStartColumn = b.startColumn;
    let otherEndLineNumber = b.endLineNumber;
    let otherEndColumn = b.endColumn;
    if (resultStartLineNumber < otherStartLineNumber) {
      resultStartLineNumber = otherStartLineNumber;
      resultStartColumn = otherStartColumn;
    } else if (resultStartLineNumber === otherStartLineNumber) {
      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
    }
    if (resultEndLineNumber > otherEndLineNumber) {
      resultEndLineNumber = otherEndLineNumber;
      resultEndColumn = otherEndColumn;
    } else if (resultEndLineNumber === otherEndLineNumber) {
      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
    }
    if (resultStartLineNumber > resultEndLineNumber) {
      return null;
    }
    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
      return null;
    }
    return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(other) {
    return _Range.equalsRange(this, other);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(a, b) {
    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return _Range.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(range2) {
    return new Position(range2.endLineNumber, range2.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return _Range.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(range2) {
    return new Position(range2.startLineNumber, range2.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(endLineNumber, endColumn) {
    return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(startLineNumber, startColumn) {
    return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return _Range.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(range2) {
    return new _Range(range2.startLineNumber, range2.startColumn, range2.startLineNumber, range2.startColumn);
  }
  // ---
  static fromPositions(start, end = start) {
    return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  static lift(range2) {
    if (!range2) {
      return null;
    }
    return new _Range(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(obj) {
    return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(a, b) {
    if (a && b) {
      const aStartLineNumber = a.startLineNumber | 0;
      const bStartLineNumber = b.startLineNumber | 0;
      if (aStartLineNumber === bStartLineNumber) {
        const aStartColumn = a.startColumn | 0;
        const bStartColumn = b.startColumn | 0;
        if (aStartColumn === bStartColumn) {
          const aEndLineNumber = a.endLineNumber | 0;
          const bEndLineNumber = b.endLineNumber | 0;
          if (aEndLineNumber === bEndLineNumber) {
            const aEndColumn = a.endColumn | 0;
            const bEndColumn = b.endColumn | 0;
            return aEndColumn - bEndColumn;
          }
          return aEndLineNumber - bEndLineNumber;
        }
        return aStartColumn - bStartColumn;
      }
      return aStartLineNumber - bStartLineNumber;
    }
    const aExists = a ? 1 : 0;
    const bExists = b ? 1 : 0;
    return aExists - bExists;
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(a, b) {
    if (a.endLineNumber === b.endLineNumber) {
      if (a.endColumn === b.endColumn) {
        if (a.startLineNumber === b.startLineNumber) {
          return a.startColumn - b.startColumn;
        }
        return a.startLineNumber - b.startLineNumber;
      }
      return a.endColumn - b.endColumn;
    }
    return a.endLineNumber - b.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(range2) {
    return range2.endLineNumber > range2.startLineNumber;
  }
  toJSON() {
    return this;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
var Selection = class _Selection extends Range {
  constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
    super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
    this.selectionStartLineNumber = selectionStartLineNumber;
    this.selectionStartColumn = selectionStartColumn;
    this.positionLineNumber = positionLineNumber;
    this.positionColumn = positionColumn;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(other) {
    return _Selection.selectionsEqual(this, other);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(a, b) {
    return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
      return 0;
    }
    return 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(endLineNumber, endColumn) {
    if (this.getDirection() === 0) {
      return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new Position(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(startLineNumber, startColumn) {
    if (this.getDirection() === 0) {
      return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(start, end = start) {
    return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(range2, direction) {
    if (direction === 0) {
      return new _Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
    } else {
      return new _Selection(range2.endLineNumber, range2.endColumn, range2.startLineNumber, range2.startColumn);
    }
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(sel) {
    return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(a, b) {
    if (a && !b || !a && b) {
      return false;
    }
    if (!a && !b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
      if (!this.selectionsEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(obj) {
    return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
    if (direction === 0) {
      return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TokenizationRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._factories = /* @__PURE__ */ new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._colorMap = null;
  }
  fire(languages) {
    this._onDidChange.fire({
      changedLanguages: languages,
      changedColorMap: false
    });
  }
  register(language, support) {
    this._map.set(language, support);
    this.fire([language]);
    return toDisposable(() => {
      if (this._map.get(language) !== support) {
        return;
      }
      this._map.delete(language);
      this.fire([language]);
    });
  }
  registerFactory(languageId, factory) {
    var _a3;
    (_a3 = this._factories.get(languageId)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
    const myData = new TokenizationSupportFactoryData(this, languageId, factory);
    this._factories.set(languageId, myData);
    return toDisposable(() => {
      const v = this._factories.get(languageId);
      if (!v || v !== myData) {
        return;
      }
      this._factories.delete(languageId);
      v.dispose();
    });
  }
  getOrCreate(languageId) {
    return __awaiter4(this, void 0, void 0, function* () {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return null;
      }
      yield factory.resolve();
      return this.get(languageId);
    });
  }
  get(language) {
    return this._map.get(language) || null;
  }
  isResolved(languageId) {
    const tokenizationSupport = this.get(languageId);
    if (tokenizationSupport) {
      return true;
    }
    const factory = this._factories.get(languageId);
    if (!factory || factory.isResolved) {
      return true;
    }
    return false;
  }
  setColorMap(colorMap) {
    this._colorMap = colorMap;
    this._onDidChange.fire({
      changedLanguages: Array.from(this._map.keys()),
      changedColorMap: true
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    if (this._colorMap && this._colorMap.length > 2) {
      return this._colorMap[
        2
        /* DefaultBackground */
      ];
    }
    return null;
  }
};
var TokenizationSupportFactoryData = class extends Disposable {
  constructor(_registry2, _languageId, _factory) {
    super();
    this._registry = _registry2;
    this._languageId = _languageId;
    this._factory = _factory;
    this._isDisposed = false;
    this._resolvePromise = null;
    this._isResolved = false;
  }
  get isResolved() {
    return this._isResolved;
  }
  dispose() {
    this._isDisposed = true;
    super.dispose();
  }
  resolve() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._resolvePromise) {
        this._resolvePromise = this._create();
      }
      return this._resolvePromise;
    });
  }
  _create() {
    return __awaiter4(this, void 0, void 0, function* () {
      const value = yield Promise.resolve(this._factory.createTokenizationSupport());
      this._isResolved = true;
      if (value && !this._isDisposed) {
        this._register(this._registry.register(this._languageId, value));
      }
    });
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/languages.js
var TokenMetadata = class {
  static getLanguageId(metadata) {
    return (metadata & 255) >>> 0;
  }
  static getTokenType(metadata) {
    return (metadata & 768) >>> 8;
  }
  static getFontStyle(metadata) {
    return (metadata & 15360) >>> 10;
  }
  static getForeground(metadata) {
    return (metadata & 8372224) >>> 14;
  }
  static getBackground(metadata) {
    return (metadata & 4286578688) >>> 23;
  }
  static getClassNameFromMetadata(metadata) {
    const foreground2 = this.getForeground(metadata);
    let className = "mtk" + foreground2;
    const fontStyle = this.getFontStyle(metadata);
    if (fontStyle & 1) {
      className += " mtki";
    }
    if (fontStyle & 2) {
      className += " mtkb";
    }
    if (fontStyle & 4) {
      className += " mtku";
    }
    if (fontStyle & 8) {
      className += " mtks";
    }
    return className;
  }
  static getInlineStyleFromMetadata(metadata, colorMap) {
    const foreground2 = this.getForeground(metadata);
    const fontStyle = this.getFontStyle(metadata);
    let result = `color: ${colorMap[foreground2]};`;
    if (fontStyle & 1) {
      result += "font-style: italic;";
    }
    if (fontStyle & 2) {
      result += "font-weight: bold;";
    }
    let textDecoration = "";
    if (fontStyle & 4) {
      textDecoration += " underline";
    }
    if (fontStyle & 8) {
      textDecoration += " line-through";
    }
    if (textDecoration) {
      result += `text-decoration:${textDecoration};`;
    }
    return result;
  }
  static getPresentationFromMetadata(metadata) {
    const foreground2 = this.getForeground(metadata);
    const fontStyle = this.getFontStyle(metadata);
    return {
      foreground: foreground2,
      italic: Boolean(
        fontStyle & 1
        /* Italic */
      ),
      bold: Boolean(
        fontStyle & 2
        /* Bold */
      ),
      underline: Boolean(
        fontStyle & 4
        /* Underline */
      ),
      strikethrough: Boolean(
        fontStyle & 8
        /* Strikethrough */
      )
    };
  }
};
var Token = class {
  constructor(offset, type, language) {
    this._tokenBrand = void 0;
    this.offset = offset;
    this.type = type;
    this.language = language;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
var TokenizationResult = class {
  constructor(tokens, endState) {
    this._tokenizationResultBrand = void 0;
    this.tokens = tokens;
    this.endState = endState;
  }
};
var EncodedTokenizationResult = class {
  constructor(tokens, endState) {
    this._encodedTokenizationResultBrand = void 0;
    this.tokens = tokens;
    this.endState = endState;
  }
};
var CompletionItemKinds;
(function(CompletionItemKinds2) {
  const byKind = /* @__PURE__ */ new Map();
  byKind.set(0, Codicon.symbolMethod);
  byKind.set(1, Codicon.symbolFunction);
  byKind.set(2, Codicon.symbolConstructor);
  byKind.set(3, Codicon.symbolField);
  byKind.set(4, Codicon.symbolVariable);
  byKind.set(5, Codicon.symbolClass);
  byKind.set(6, Codicon.symbolStruct);
  byKind.set(7, Codicon.symbolInterface);
  byKind.set(8, Codicon.symbolModule);
  byKind.set(9, Codicon.symbolProperty);
  byKind.set(10, Codicon.symbolEvent);
  byKind.set(11, Codicon.symbolOperator);
  byKind.set(12, Codicon.symbolUnit);
  byKind.set(13, Codicon.symbolValue);
  byKind.set(15, Codicon.symbolEnum);
  byKind.set(14, Codicon.symbolConstant);
  byKind.set(15, Codicon.symbolEnum);
  byKind.set(16, Codicon.symbolEnumMember);
  byKind.set(17, Codicon.symbolKeyword);
  byKind.set(27, Codicon.symbolSnippet);
  byKind.set(18, Codicon.symbolText);
  byKind.set(19, Codicon.symbolColor);
  byKind.set(20, Codicon.symbolFile);
  byKind.set(21, Codicon.symbolReference);
  byKind.set(22, Codicon.symbolCustomColor);
  byKind.set(23, Codicon.symbolFolder);
  byKind.set(24, Codicon.symbolTypeParameter);
  byKind.set(25, Codicon.account);
  byKind.set(26, Codicon.issues);
  function toIcon(kind) {
    let codicon = byKind.get(kind);
    if (!codicon) {
      console.info("No codicon found for CompletionItemKind " + kind);
      codicon = Codicon.symbolProperty;
    }
    return codicon;
  }
  CompletionItemKinds2.toIcon = toIcon;
  const data = /* @__PURE__ */ new Map();
  data.set(
    "method",
    0
    /* Method */
  );
  data.set(
    "function",
    1
    /* Function */
  );
  data.set(
    "constructor",
    2
    /* Constructor */
  );
  data.set(
    "field",
    3
    /* Field */
  );
  data.set(
    "variable",
    4
    /* Variable */
  );
  data.set(
    "class",
    5
    /* Class */
  );
  data.set(
    "struct",
    6
    /* Struct */
  );
  data.set(
    "interface",
    7
    /* Interface */
  );
  data.set(
    "module",
    8
    /* Module */
  );
  data.set(
    "property",
    9
    /* Property */
  );
  data.set(
    "event",
    10
    /* Event */
  );
  data.set(
    "operator",
    11
    /* Operator */
  );
  data.set(
    "unit",
    12
    /* Unit */
  );
  data.set(
    "value",
    13
    /* Value */
  );
  data.set(
    "constant",
    14
    /* Constant */
  );
  data.set(
    "enum",
    15
    /* Enum */
  );
  data.set(
    "enum-member",
    16
    /* EnumMember */
  );
  data.set(
    "enumMember",
    16
    /* EnumMember */
  );
  data.set(
    "keyword",
    17
    /* Keyword */
  );
  data.set(
    "snippet",
    27
    /* Snippet */
  );
  data.set(
    "text",
    18
    /* Text */
  );
  data.set(
    "color",
    19
    /* Color */
  );
  data.set(
    "file",
    20
    /* File */
  );
  data.set(
    "reference",
    21
    /* Reference */
  );
  data.set(
    "customcolor",
    22
    /* Customcolor */
  );
  data.set(
    "folder",
    23
    /* Folder */
  );
  data.set(
    "type-parameter",
    24
    /* TypeParameter */
  );
  data.set(
    "typeParameter",
    24
    /* TypeParameter */
  );
  data.set(
    "account",
    25
    /* User */
  );
  data.set(
    "issue",
    26
    /* Issue */
  );
  function fromString(value, strict) {
    let res = data.get(value);
    if (typeof res === "undefined" && !strict) {
      res = 9;
    }
    return res;
  }
  CompletionItemKinds2.fromString = fromString;
})(CompletionItemKinds || (CompletionItemKinds = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind2) {
  InlineCompletionTriggerKind2[InlineCompletionTriggerKind2["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind2[InlineCompletionTriggerKind2["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SignatureHelpTriggerKind;
(function(SignatureHelpTriggerKind2) {
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2[DocumentHighlightKind2["Text"] = 0] = "Text";
  DocumentHighlightKind2[DocumentHighlightKind2["Read"] = 1] = "Read";
  DocumentHighlightKind2[DocumentHighlightKind2["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var SymbolKinds;
(function(SymbolKinds2) {
  const byKind = /* @__PURE__ */ new Map();
  byKind.set(0, Codicon.symbolFile);
  byKind.set(1, Codicon.symbolModule);
  byKind.set(2, Codicon.symbolNamespace);
  byKind.set(3, Codicon.symbolPackage);
  byKind.set(4, Codicon.symbolClass);
  byKind.set(5, Codicon.symbolMethod);
  byKind.set(6, Codicon.symbolProperty);
  byKind.set(7, Codicon.symbolField);
  byKind.set(8, Codicon.symbolConstructor);
  byKind.set(9, Codicon.symbolEnum);
  byKind.set(10, Codicon.symbolInterface);
  byKind.set(11, Codicon.symbolFunction);
  byKind.set(12, Codicon.symbolVariable);
  byKind.set(13, Codicon.symbolConstant);
  byKind.set(14, Codicon.symbolString);
  byKind.set(15, Codicon.symbolNumber);
  byKind.set(16, Codicon.symbolBoolean);
  byKind.set(17, Codicon.symbolArray);
  byKind.set(18, Codicon.symbolObject);
  byKind.set(19, Codicon.symbolKey);
  byKind.set(20, Codicon.symbolNull);
  byKind.set(21, Codicon.symbolEnumMember);
  byKind.set(22, Codicon.symbolStruct);
  byKind.set(23, Codicon.symbolEvent);
  byKind.set(24, Codicon.symbolOperator);
  byKind.set(25, Codicon.symbolTypeParameter);
  function toIcon(kind) {
    let icon = byKind.get(kind);
    if (!icon) {
      console.info("No codicon found for SymbolKind " + kind);
      icon = Codicon.symbolProperty;
    }
    return icon;
  }
  SymbolKinds2.toIcon = toIcon;
})(SymbolKinds || (SymbolKinds = {}));
var FoldingRangeKind = class {
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(value) {
    this.value = value;
  }
};
FoldingRangeKind.Comment = new FoldingRangeKind("comment");
FoldingRangeKind.Imports = new FoldingRangeKind("imports");
FoldingRangeKind.Region = new FoldingRangeKind("region");
var Command2;
(function(Command3) {
  function is(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return typeof obj.id === "string" && typeof obj.title === "string";
  }
  Command3.is = is;
})(Command2 || (Command2 = {}));
var InlayHintKind;
(function(InlayHintKind2) {
  InlayHintKind2[InlayHintKind2["Type"] = 1] = "Type";
  InlayHintKind2[InlayHintKind2["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
var TokenizationRegistry2 = new TokenizationRegistry();

// node_modules/monaco-editor/esm/vs/editor/common/model.js
var OverviewRulerLane;
(function(OverviewRulerLane2) {
  OverviewRulerLane2[OverviewRulerLane2["Left"] = 1] = "Left";
  OverviewRulerLane2[OverviewRulerLane2["Center"] = 2] = "Center";
  OverviewRulerLane2[OverviewRulerLane2["Right"] = 4] = "Right";
  OverviewRulerLane2[OverviewRulerLane2["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var MinimapPosition;
(function(MinimapPosition2) {
  MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
  MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
var InjectedTextCursorStops;
(function(InjectedTextCursorStops2) {
  InjectedTextCursorStops2[InjectedTextCursorStops2["Both"] = 0] = "Both";
  InjectedTextCursorStops2[InjectedTextCursorStops2["Right"] = 1] = "Right";
  InjectedTextCursorStops2[InjectedTextCursorStops2["Left"] = 2] = "Left";
  InjectedTextCursorStops2[InjectedTextCursorStops2["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
var TextModelResolvedOptions = class {
  /**
   * @internal
   */
  constructor(src) {
    this._textModelResolvedOptionsBrand = void 0;
    this.tabSize = Math.max(1, src.tabSize | 0);
    this.indentSize = src.tabSize | 0;
    this.insertSpaces = Boolean(src.insertSpaces);
    this.defaultEOL = src.defaultEOL | 0;
    this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
    this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;
  }
  /**
   * @internal
   */
  equals(other) {
    return this.tabSize === other.tabSize && this.indentSize === other.indentSize && this.insertSpaces === other.insertSpaces && this.defaultEOL === other.defaultEOL && this.trimAutoWhitespace === other.trimAutoWhitespace && equals2(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions);
  }
  /**
   * @internal
   */
  createChangeEvent(newOpts) {
    return {
      tabSize: this.tabSize !== newOpts.tabSize,
      indentSize: this.indentSize !== newOpts.indentSize,
      insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace
    };
  }
};
var FindMatch = class {
  /**
   * @internal
   */
  constructor(range2, matches) {
    this._findMatchBrand = void 0;
    this.range = range2;
    this.matches = matches;
  }
};
var ValidAnnotatedEditOperation = class {
  constructor(identifier, range2, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {
    this.identifier = identifier;
    this.range = range2;
    this.text = text;
    this.forceMoveMarkers = forceMoveMarkers;
    this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;
    this._isTracked = _isTracked;
  }
};
var SearchData = class {
  constructor(regex, wordSeparators, simpleSearch) {
    this.regex = regex;
    this.wordSeparators = wordSeparators;
    this.simpleSearch = simpleSearch;
  }
};
var ApplyEditsResult = class {
  constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
    this.reverseEdits = reverseEdits;
    this.changes = changes;
    this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
  }
};
function shouldSynchronizeModel(model) {
  return !model.isTooLargeForSyncing() && !model.isForSimpleWidget;
}

// node_modules/monaco-editor/esm/vs/editor/common/languages/language.js
var ILanguageService = createDecorator("languageService");

// node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js
var IndentAction;
(function(IndentAction2) {
  IndentAction2[IndentAction2["None"] = 0] = "None";
  IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
  IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var StandardAutoClosingPairConditional = class {
  constructor(source) {
    this._neutralCharacter = null;
    this._neutralCharacterSearched = false;
    this.open = source.open;
    this.close = source.close;
    this._inString = true;
    this._inComment = true;
    this._inRegEx = true;
    if (Array.isArray(source.notIn)) {
      for (let i = 0, len = source.notIn.length; i < len; i++) {
        const notIn = source.notIn[i];
        switch (notIn) {
          case "string":
            this._inString = false;
            break;
          case "comment":
            this._inComment = false;
            break;
          case "regex":
            this._inRegEx = false;
            break;
        }
      }
    }
  }
  isOK(standardToken) {
    switch (standardToken) {
      case 0:
        return true;
      case 1:
        return this._inComment;
      case 2:
        return this._inString;
      case 3:
        return this._inRegEx;
    }
  }
  shouldAutoClose(context, column) {
    if (context.getTokenCount() === 0) {
      return true;
    }
    const tokenIndex = context.findTokenIndexAtOffset(column - 2);
    const standardTokenType = context.getStandardTokenType(tokenIndex);
    return this.isOK(standardTokenType);
  }
  _findNeutralCharacterInRange(fromCharCode, toCharCode) {
    for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {
      const character = String.fromCharCode(charCode);
      if (!this.open.includes(character) && !this.close.includes(character)) {
        return character;
      }
    }
    return null;
  }
  /**
   * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
   */
  findNeutralCharacter() {
    if (!this._neutralCharacterSearched) {
      this._neutralCharacterSearched = true;
      if (!this._neutralCharacter) {
        this._neutralCharacter = this._findNeutralCharacterInRange(
          48,
          57
          /* Digit9 */
        );
      }
      if (!this._neutralCharacter) {
        this._neutralCharacter = this._findNeutralCharacterInRange(
          97,
          122
          /* z */
        );
      }
      if (!this._neutralCharacter) {
        this._neutralCharacter = this._findNeutralCharacterInRange(
          65,
          90
          /* Z */
        );
      }
    }
    return this._neutralCharacter;
  }
};
var AutoClosingPairs = class {
  constructor(autoClosingPairs) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map();
    this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map();
    this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map();
    this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map();
    this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const pair of autoClosingPairs) {
      appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);
      appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);
      appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);
      appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);
      if (pair.close.length === 1 && pair.open.length === 1) {
        appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
      }
    }
  }
};
function appendEntry(target, key, value) {
  if (target.has(key)) {
    target.get(key).push(value);
  } else {
    target.set(key, [value]);
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js
function createScopedLineTokens(context, offset) {
  const tokenCount = context.getCount();
  const tokenIndex = context.findTokenIndexAtOffset(offset);
  const desiredLanguageId = context.getLanguageId(tokenIndex);
  let lastTokenIndex = tokenIndex;
  while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
    lastTokenIndex++;
  }
  let firstTokenIndex = tokenIndex;
  while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
    firstTokenIndex--;
  }
  return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
}
var ScopedLineTokens = class {
  constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
    this._scopedLineTokensBrand = void 0;
    this._actual = actual;
    this.languageId = languageId;
    this._firstTokenIndex = firstTokenIndex;
    this._lastTokenIndex = lastTokenIndex;
    this.firstCharOffset = firstCharOffset;
    this._lastCharOffset = lastCharOffset;
  }
  getLineContent() {
    const actualLineContent = this._actual.getLineContent();
    return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
  }
  getActualLineContentBefore(offset) {
    const actualLineContent = this._actual.getLineContent();
    return actualLineContent.substring(0, this.firstCharOffset + offset);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(offset) {
    return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(tokenIndex) {
    return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
  }
};
function ignoreBracketsInToken(standardTokenType) {
  return (standardTokenType & 3) !== 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js
var CharacterPairSupport = class _CharacterPairSupport {
  constructor(config) {
    if (config.autoClosingPairs) {
      this._autoClosingPairs = config.autoClosingPairs.map((el) => new StandardAutoClosingPairConditional(el));
    } else if (config.brackets) {
      this._autoClosingPairs = config.brackets.map((b) => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));
    } else {
      this._autoClosingPairs = [];
    }
    if (config.colorizedBracketPairs) {
      this._colorizedBracketPairs = filterValidBrackets(config.colorizedBracketPairs.map((b) => [b[0], b[1]]));
    } else if (config.brackets) {
      this._colorizedBracketPairs = filterValidBrackets(config.brackets.map((b) => [b[0], b[1]]).filter((p) => !(p[0] === "<" && p[1] === ">")));
    } else {
      this._colorizedBracketPairs = [];
    }
    if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {
      const docComment = config.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || "" }));
    }
    this._autoCloseBefore = typeof config.autoCloseBefore === "string" ? config.autoCloseBefore : _CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;
    this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet() {
    return this._autoCloseBefore;
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
  getColorizedBrackets() {
    return this._colorizedBracketPairs;
  }
};
CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ";:.,=}])> \n	";
function filterValidBrackets(bracketPairs) {
  return bracketPairs.filter(([open, close]) => open !== "" && close !== "");
}

// node_modules/monaco-editor/esm/vs/base/common/buffer.js
var hasBuffer = typeof Buffer !== "undefined";
var textDecoder;
var VSBuffer = class _VSBuffer {
  constructor(buffer) {
    this.buffer = buffer;
    this.byteLength = this.buffer.byteLength;
  }
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(actual) {
    if (hasBuffer && !Buffer.isBuffer(actual)) {
      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
    }
    return new _VSBuffer(actual);
  }
  toString() {
    if (hasBuffer) {
      return this.buffer.toString();
    } else {
      if (!textDecoder) {
        textDecoder = new TextDecoder();
      }
      return textDecoder.decode(this.buffer);
    }
  }
};
function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}
function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
}
function readUInt32BE(source, offset) {
  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}

// node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js
var _utf16LE_TextDecoder;
function getUTF16LE_TextDecoder() {
  if (!_utf16LE_TextDecoder) {
    _utf16LE_TextDecoder = new TextDecoder("UTF-16LE");
  }
  return _utf16LE_TextDecoder;
}
var _utf16BE_TextDecoder;
function getUTF16BE_TextDecoder() {
  if (!_utf16BE_TextDecoder) {
    _utf16BE_TextDecoder = new TextDecoder("UTF-16BE");
  }
  return _utf16BE_TextDecoder;
}
var _platformTextDecoder;
function getPlatformTextDecoder() {
  if (!_platformTextDecoder) {
    _platformTextDecoder = isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();
  }
  return _platformTextDecoder;
}
var hasTextDecoder = typeof TextDecoder !== "undefined";
var createStringBuilder;
var decodeUTF16LE;
if (hasTextDecoder) {
  createStringBuilder = (capacity) => new StringBuilder(capacity);
  decodeUTF16LE = standardDecodeUTF16LE;
} else {
  createStringBuilder = (capacity) => new CompatStringBuilder();
  decodeUTF16LE = compatDecodeUTF16LE;
}
function standardDecodeUTF16LE(source, offset, len) {
  const view = new Uint16Array(source.buffer, offset, len);
  if (len > 0 && (view[0] === 65279 || view[0] === 65534)) {
    return compatDecodeUTF16LE(source, offset, len);
  }
  return getUTF16LE_TextDecoder().decode(view);
}
function compatDecodeUTF16LE(source, offset, len) {
  const result = [];
  let resultLen = 0;
  for (let i = 0; i < len; i++) {
    const charCode = readUInt16LE(source, offset);
    offset += 2;
    result[resultLen++] = String.fromCharCode(charCode);
  }
  return result.join("");
}
var StringBuilder = class {
  constructor(capacity) {
    this._capacity = capacity | 0;
    this._buffer = new Uint16Array(this._capacity);
    this._completedStrings = null;
    this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null;
    this._bufferLength = 0;
  }
  build() {
    if (this._completedStrings !== null) {
      this._flushBuffer();
      return this._completedStrings.join("");
    }
    return this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0) {
      return "";
    }
    const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return getPlatformTextDecoder().decode(view);
  }
  _flushBuffer() {
    const bufferString = this._buildBuffer();
    this._bufferLength = 0;
    if (this._completedStrings === null) {
      this._completedStrings = [bufferString];
    } else {
      this._completedStrings[this._completedStrings.length] = bufferString;
    }
  }
  write1(charCode) {
    const remainingSpace = this._capacity - this._bufferLength;
    if (remainingSpace <= 1) {
      if (remainingSpace === 0 || isHighSurrogate(charCode)) {
        this._flushBuffer();
      }
    }
    this._buffer[this._bufferLength++] = charCode;
  }
  appendASCII(charCode) {
    if (this._bufferLength === this._capacity) {
      this._flushBuffer();
    }
    this._buffer[this._bufferLength++] = charCode;
  }
  appendASCIIString(str) {
    const strLen = str.length;
    if (this._bufferLength + strLen >= this._capacity) {
      this._flushBuffer();
      this._completedStrings[this._completedStrings.length] = str;
      return;
    }
    for (let i = 0; i < strLen; i++) {
      this._buffer[this._bufferLength++] = str.charCodeAt(i);
    }
  }
};
var CompatStringBuilder = class {
  constructor() {
    this._pieces = [];
    this._piecesLen = 0;
  }
  reset() {
    this._pieces = [];
    this._piecesLen = 0;
  }
  build() {
    return this._pieces.join("");
  }
  write1(charCode) {
    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
  }
  appendASCII(charCode) {
    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
  }
  appendASCIIString(str) {
    this._pieces[this._piecesLen++] = str;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js
var RichEditBracket = class _RichEditBracket {
  constructor(languageId, index, open, close, forwardRegex, reversedRegex) {
    this._richEditBracketBrand = void 0;
    this.languageId = languageId;
    this.index = index;
    this.open = open;
    this.close = close;
    this.forwardRegex = forwardRegex;
    this.reversedRegex = reversedRegex;
    this._openSet = _RichEditBracket._toSet(this.open);
    this._closeSet = _RichEditBracket._toSet(this.close);
  }
  /**
   * Check if the provided `text` is an open bracket in this group.
   */
  isOpen(text) {
    return this._openSet.has(text);
  }
  /**
   * Check if the provided `text` is a close bracket in this group.
   */
  isClose(text) {
    return this._closeSet.has(text);
  }
  static _toSet(arr) {
    const result = /* @__PURE__ */ new Set();
    for (const element of arr) {
      result.add(element);
    }
    return result;
  }
};
function groupFuzzyBrackets(brackets) {
  const N = brackets.length;
  brackets = brackets.map((b) => [b[0].toLowerCase(), b[1].toLowerCase()]);
  const group = [];
  for (let i = 0; i < N; i++) {
    group[i] = i;
  }
  const areOverlapping = (a, b) => {
    const [aOpen, aClose] = a;
    const [bOpen, bClose] = b;
    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;
  };
  const mergeGroups = (g1, g2) => {
    const newG = Math.min(g1, g2);
    const oldG = Math.max(g1, g2);
    for (let i = 0; i < N; i++) {
      if (group[i] === oldG) {
        group[i] = newG;
      }
    }
  };
  for (let i = 0; i < N; i++) {
    const a = brackets[i];
    for (let j = i + 1; j < N; j++) {
      const b = brackets[j];
      if (areOverlapping(a, b)) {
        mergeGroups(group[i], group[j]);
      }
    }
  }
  const result = [];
  for (let g = 0; g < N; g++) {
    const currentOpen = [];
    const currentClose = [];
    for (let i = 0; i < N; i++) {
      if (group[i] === g) {
        const [open, close] = brackets[i];
        currentOpen.push(open);
        currentClose.push(close);
      }
    }
    if (currentOpen.length > 0) {
      result.push({
        open: currentOpen,
        close: currentClose
      });
    }
  }
  return result;
}
var RichEditBrackets = class {
  constructor(languageId, _brackets) {
    this._richEditBracketsBrand = void 0;
    const brackets = groupFuzzyBrackets(_brackets);
    this.brackets = brackets.map((b, index) => {
      return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));
    });
    this.forwardRegex = getRegexForBrackets(this.brackets);
    this.reversedRegex = getReversedRegexForBrackets(this.brackets);
    this.textIsBracket = {};
    this.textIsOpenBracket = {};
    this.maxBracketLength = 0;
    for (const bracket of this.brackets) {
      for (const open of bracket.open) {
        this.textIsBracket[open] = bracket;
        this.textIsOpenBracket[open] = true;
        this.maxBracketLength = Math.max(this.maxBracketLength, open.length);
      }
      for (const close of bracket.close) {
        this.textIsBracket[close] = bracket;
        this.textIsOpenBracket[close] = false;
        this.maxBracketLength = Math.max(this.maxBracketLength, close.length);
      }
    }
  }
};
function collectSuperstrings(str, brackets, currentIndex, dest) {
  for (let i = 0, len = brackets.length; i < len; i++) {
    if (i === currentIndex) {
      continue;
    }
    const bracket = brackets[i];
    for (const open of bracket.open) {
      if (open.indexOf(str) >= 0) {
        dest.push(open);
      }
    }
    for (const close of bracket.close) {
      if (close.indexOf(str) >= 0) {
        dest.push(close);
      }
    }
  }
}
function lengthcmp(a, b) {
  return a.length - b.length;
}
function unique(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const element of arr) {
    if (seen.has(element)) {
      continue;
    }
    result.push(element);
    seen.add(element);
  }
  return result;
}
function getRegexForBracketPair(open, close, brackets, currentIndex) {
  let pieces = [];
  pieces = pieces.concat(open);
  pieces = pieces.concat(close);
  for (let i = 0, len = pieces.length; i < len; i++) {
    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
  }
  pieces = unique(pieces);
  pieces.sort(lengthcmp);
  pieces.reverse();
  return createBracketOrRegExp(pieces);
}
function getReversedRegexForBracketPair(open, close, brackets, currentIndex) {
  let pieces = [];
  pieces = pieces.concat(open);
  pieces = pieces.concat(close);
  for (let i = 0, len = pieces.length; i < len; i++) {
    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
  }
  pieces = unique(pieces);
  pieces.sort(lengthcmp);
  pieces.reverse();
  return createBracketOrRegExp(pieces.map(toReversedString));
}
function getRegexForBrackets(brackets) {
  let pieces = [];
  for (const bracket of brackets) {
    for (const open of bracket.open) {
      pieces.push(open);
    }
    for (const close of bracket.close) {
      pieces.push(close);
    }
  }
  pieces = unique(pieces);
  return createBracketOrRegExp(pieces);
}
function getReversedRegexForBrackets(brackets) {
  let pieces = [];
  for (const bracket of brackets) {
    for (const open of bracket.open) {
      pieces.push(open);
    }
    for (const close of bracket.close) {
      pieces.push(close);
    }
  }
  pieces = unique(pieces);
  return createBracketOrRegExp(pieces.map(toReversedString));
}
function prepareBracketForRegExp(str) {
  const insertWordBoundaries = /^[\w ]+$/.test(str);
  str = escapeRegExpCharacters(str);
  return insertWordBoundaries ? `\\b${str}\\b` : str;
}
function createBracketOrRegExp(pieces) {
  const regexStr = `(${pieces.map(prepareBracketForRegExp).join(")|(")})`;
  return createRegExp(regexStr, true);
}
var toReversedString = /* @__PURE__ */ function() {
  function reverse(str) {
    if (hasTextDecoder) {
      const arr = new Uint16Array(str.length);
      let offset = 0;
      for (let i = str.length - 1; i >= 0; i--) {
        arr[offset++] = str.charCodeAt(i);
      }
      return getPlatformTextDecoder().decode(arr);
    } else {
      const result = [];
      let resultLen = 0;
      for (let i = str.length - 1; i >= 0; i--) {
        result[resultLen++] = str.charAt(i);
      }
      return result.join("");
    }
  }
  let lastInput = null;
  let lastOutput = null;
  return function toReversedString2(str) {
    if (lastInput !== str) {
      lastInput = str;
      lastOutput = reverse(lastInput);
    }
    return lastOutput;
  };
}();
var BracketsUtils = class {
  static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {
    const m = reversedText.match(reversedBracketRegex);
    if (!m) {
      return null;
    }
    const matchOffset = reversedText.length - (m.index || 0);
    const matchLength = m[0].length;
    const absoluteMatchOffset = offset + matchOffset;
    return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
  }
  static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {
    const reversedLineText = toReversedString(lineText);
    const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);
    return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);
  }
  static findNextBracketInText(bracketRegex, lineNumber, text, offset) {
    const m = text.match(bracketRegex);
    if (!m) {
      return null;
    }
    const matchOffset = m.index || 0;
    const matchLength = m[0].length;
    if (matchLength === 0) {
      return null;
    }
    const absoluteMatchOffset = offset + matchOffset;
    return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
  }
  static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {
    const substr = lineText.substring(startOffset, endOffset);
    return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js
var BracketElectricCharacterSupport = class {
  constructor(richEditBrackets) {
    this._richEditBrackets = richEditBrackets;
  }
  getElectricCharacters() {
    const result = [];
    if (this._richEditBrackets) {
      for (const bracket of this._richEditBrackets.brackets) {
        for (const close of bracket.close) {
          const lastChar = close.charAt(close.length - 1);
          result.push(lastChar);
        }
      }
    }
    return distinct(result);
  }
  onElectricCharacter(character, context, column) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
      return null;
    }
    const tokenIndex = context.findTokenIndexAtOffset(column - 1);
    if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
      return null;
    }
    const reversedBracketRegex = this._richEditBrackets.reversedRegex;
    const text = context.getLineContent().substring(0, column - 1) + character;
    const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);
    if (!r) {
      return null;
    }
    const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
    const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
    if (isOpen) {
      return null;
    }
    const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);
    if (!/^\s*$/.test(textBeforeBracket)) {
      return null;
    }
    return {
      matchOpenBracket: bracketText
    };
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js
function resetGlobalRegex(reg) {
  if (reg.global) {
    reg.lastIndex = 0;
  }
  return true;
}
var IndentRulesSupport = class {
  constructor(indentationRules) {
    this._indentationRules = indentationRules;
  }
  shouldIncrease(text) {
    if (this._indentationRules) {
      if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {
        return true;
      }
    }
    return false;
  }
  shouldDecrease(text) {
    if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {
      return true;
    }
    return false;
  }
  shouldIndentNextLine(text) {
    if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {
      return true;
    }
    return false;
  }
  shouldIgnore(text) {
    if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {
      return true;
    }
    return false;
  }
  getIndentMetadata(text) {
    let ret = 0;
    if (this.shouldIncrease(text)) {
      ret += 1;
    }
    if (this.shouldDecrease(text)) {
      ret += 2;
    }
    if (this.shouldIndentNextLine(text)) {
      ret += 4;
    }
    if (this.shouldIgnore(text)) {
      ret += 8;
    }
    return ret;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js
var OnEnterSupport = class _OnEnterSupport {
  constructor(opts) {
    opts = opts || {};
    opts.brackets = opts.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ];
    this._brackets = [];
    opts.brackets.forEach((bracket) => {
      const openRegExp = _OnEnterSupport._createOpenBracketRegExp(bracket[0]);
      const closeRegExp = _OnEnterSupport._createCloseBracketRegExp(bracket[1]);
      if (openRegExp && closeRegExp) {
        this._brackets.push({
          open: bracket[0],
          openRegExp,
          close: bracket[1],
          closeRegExp
        });
      }
    });
    this._regExpRules = opts.onEnterRules || [];
  }
  onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
    if (autoIndent >= 3) {
      for (let i = 0, len = this._regExpRules.length; i < len; i++) {
        const rule = this._regExpRules[i];
        const regResult = [{
          reg: rule.beforeText,
          text: beforeEnterText
        }, {
          reg: rule.afterText,
          text: afterEnterText
        }, {
          reg: rule.previousLineText,
          text: previousLineText
        }].every((obj) => {
          if (!obj.reg) {
            return true;
          }
          obj.reg.lastIndex = 0;
          return obj.reg.test(obj.text);
        });
        if (regResult) {
          return rule.action;
        }
      }
    }
    if (autoIndent >= 2) {
      if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
        for (let i = 0, len = this._brackets.length; i < len; i++) {
          const bracket = this._brackets[i];
          if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
            return { indentAction: IndentAction.IndentOutdent };
          }
        }
      }
    }
    if (autoIndent >= 2) {
      if (beforeEnterText.length > 0) {
        for (let i = 0, len = this._brackets.length; i < len; i++) {
          const bracket = this._brackets[i];
          if (bracket.openRegExp.test(beforeEnterText)) {
            return { indentAction: IndentAction.Indent };
          }
        }
      }
    }
    return null;
  }
  static _createOpenBracketRegExp(bracket) {
    let str = escapeRegExpCharacters(bracket);
    if (!/\B/.test(str.charAt(0))) {
      str = "\\b" + str;
    }
    str += "\\s*$";
    return _OnEnterSupport._safeRegExp(str);
  }
  static _createCloseBracketRegExp(bracket) {
    let str = escapeRegExpCharacters(bracket);
    if (!/\B/.test(str.charAt(str.length - 1))) {
      str = str + "\\b";
    }
    str = "^\\s*" + str;
    return _OnEnterSupport._safeRegExp(str);
  }
  static _safeRegExp(def) {
    try {
      return new RegExp(def);
    } catch (err) {
      onUnexpectedError(err);
      return null;
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js
var IConfigurationService = createDecorator("configurationService");
function toValuesTree(properties, conflictReporter) {
  const root = /* @__PURE__ */ Object.create(null);
  for (let key in properties) {
    addToValueTree(root, key, properties[key], conflictReporter);
  }
  return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    let s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "undefined":
        obj = curr[s] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object" && curr !== null) {
    try {
      curr[last] = value;
    } catch (e) {
      conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
    }
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).indexOf(first) !== -1) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path2) {
    let current = config2;
    for (const component of path2) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[component];
    }
    return current;
  }
  const path = settingPath.split(".");
  const result = accessSetting(config, path);
  return typeof result === "undefined" ? defaultValue : result;
}

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js
var SyncDescriptor = class {
  constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
    this.ctor = ctor;
    this.staticArguments = staticArguments;
    this.supportsDelayedInstantiation = supportsDelayedInstantiation;
  }
};

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js
var _registry = [];
function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {
  if (!(ctorOrDescriptor instanceof SyncDescriptor)) {
    ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], supportsDelayedInstantiation);
  }
  _registry.push([id, ctorOrDescriptor]);
}
function getSingletonServiceDescriptors() {
  return _registry;
}

// node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LanguageConfigurationServiceChangeEvent = class {
  constructor(languageId) {
    this.languageId = languageId;
  }
  affects(languageId) {
    return !this.languageId ? true : this.languageId === languageId;
  }
};
var ILanguageConfigurationService = createDecorator("languageConfigurationService");
var LanguageConfigurationService = class LanguageConfigurationService2 extends Disposable {
  constructor(configurationService, languageService) {
    super();
    this.configurationService = configurationService;
    this.languageService = languageService;
    this.onDidChangeEmitter = this._register(new Emitter());
    this.onDidChange = this.onDidChangeEmitter.event;
    this.configurations = /* @__PURE__ */ new Map();
    const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));
      const localConfigChanged = e.change.overrides.filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k))).map(([overrideLangName]) => overrideLangName);
      if (globalConfigChanged) {
        this.configurations.clear();
        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(void 0));
      } else {
        for (const languageId of localConfigChanged) {
          if (this.languageService.isRegisteredLanguageId(languageId)) {
            this.configurations.delete(languageId);
            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));
          }
        }
      }
    }));
    this._register(LanguageConfigurationRegistry.onDidChange((e) => {
      this.configurations.delete(e.languageId);
      this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));
    }));
  }
  getLanguageConfiguration(languageId) {
    let result = this.configurations.get(languageId);
    if (!result) {
      result = computeConfig(languageId, this.configurationService, this.languageService);
      this.configurations.set(languageId, result);
    }
    return result;
  }
};
LanguageConfigurationService = __decorate2([
  __param2(0, IConfigurationService),
  __param2(1, ILanguageService)
], LanguageConfigurationService);
function computeConfig(languageId, configurationService, languageService) {
  let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);
  if (!languageConfig) {
    if (!languageService.isRegisteredLanguageId(languageId)) {
      throw new Error(`Language id "${languageId}" is not configured nor known`);
    }
    languageConfig = new ResolvedLanguageConfiguration(languageId, {});
  }
  const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);
  const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);
  const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);
  return config;
}
var customizedLanguageConfigKeys = {
  brackets: "editor.language.brackets",
  colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function getCustomizedLanguageConfig(languageId, configurationService) {
  const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {
    overrideIdentifier: languageId
  });
  const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {
    overrideIdentifier: languageId
  });
  return {
    brackets: validateBracketPairs(brackets),
    colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs)
  };
}
function validateBracketPairs(data) {
  if (!Array.isArray(data)) {
    return void 0;
  }
  return data.map((pair) => {
    if (!Array.isArray(pair) || pair.length !== 2) {
      return void 0;
    }
    return [pair[0], pair[1]];
  }).filter((p) => !!p);
}
var LanguageConfigurationChangeEvent = class {
  constructor(languageId) {
    this.languageId = languageId;
  }
};
var LanguageConfigurationRegistryImpl = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(languageId, configuration, priority = 0) {
    let entries = this._entries.get(languageId);
    if (!entries) {
      entries = new ComposedLanguageConfiguration(languageId);
      this._entries.set(languageId, entries);
    }
    const disposable = entries.register(configuration, priority);
    this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
    return toDisposable(() => {
      disposable.dispose();
      this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
    });
  }
  getLanguageConfiguration(languageId) {
    const entries = this._entries.get(languageId);
    return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;
  }
  getComments(languageId) {
    const value = this.getLanguageConfiguration(languageId);
    if (!value) {
      return null;
    }
    return value.comments || null;
  }
  // begin Indent Rules
  getIndentRulesSupport(languageId) {
    const value = this.getLanguageConfiguration(languageId);
    if (!value) {
      return null;
    }
    return value.indentRulesSupport || null;
  }
  /**
   * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.
   * Result:
   * -1: run into the boundary of embedded languages
   * 0: every line above are invalid
   * else: nearest preceding line of the same language
   */
  getPrecedingValidLine(model, lineNumber, indentRulesSupport) {
    const languageId = model.getLanguageIdAtPosition(lineNumber, 0);
    if (lineNumber > 1) {
      let lastLineNumber;
      let resultLineNumber = -1;
      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
        if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {
          return resultLineNumber;
        }
        const text = model.getLineContent(lastLineNumber);
        if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === "") {
          resultLineNumber = lastLineNumber;
          continue;
        }
        return lastLineNumber;
      }
    }
    return -1;
  }
  /**
   * Get inherited indentation from above lines.
   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
   * 3. If this line doesn't match any indent rules
   *   a. check whether the line above it matches indentNextLinePattern
   *   b. If not, the indent level of this line is the result
   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
   *
   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
   */
  getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {
    if (autoIndent < 4) {
      return null;
    }
    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());
    if (!indentRulesSupport) {
      return null;
    }
    if (lineNumber <= 1) {
      return {
        indentation: "",
        action: null
      };
    }
    const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);
    if (precedingUnIgnoredLine < 0) {
      return null;
    } else if (precedingUnIgnoredLine < 1) {
      return {
        indentation: "",
        action: null
      };
    }
    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);
    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {
      return {
        indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
        action: IndentAction.Indent,
        line: precedingUnIgnoredLine
      };
    } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {
      return {
        indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
        action: null,
        line: precedingUnIgnoredLine
      };
    } else {
      if (precedingUnIgnoredLine === 1) {
        return {
          indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
          action: null,
          line: precedingUnIgnoredLine
        };
      }
      const previousLine = precedingUnIgnoredLine - 1;
      const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));
      if (!(previousLineIndentMetadata & (1 | 2)) && previousLineIndentMetadata & 4) {
        let stopLine = 0;
        for (let i = previousLine - 1; i > 0; i--) {
          if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
            continue;
          }
          stopLine = i;
          break;
        }
        return {
          indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
          action: null,
          line: stopLine + 1
        };
      }
      if (honorIntentialIndent) {
        return {
          indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
          action: null,
          line: precedingUnIgnoredLine
        };
      } else {
        for (let i = precedingUnIgnoredLine; i > 0; i--) {
          const lineContent = model.getLineContent(i);
          if (indentRulesSupport.shouldIncrease(lineContent)) {
            return {
              indentation: getLeadingWhitespace(lineContent),
              action: IndentAction.Indent,
              line: i
            };
          } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
            let stopLine = 0;
            for (let j = i - 1; j > 0; j--) {
              if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                continue;
              }
              stopLine = j;
              break;
            }
            return {
              indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
              action: null,
              line: stopLine + 1
            };
          } else if (indentRulesSupport.shouldDecrease(lineContent)) {
            return {
              indentation: getLeadingWhitespace(lineContent),
              action: null,
              line: i
            };
          }
        }
        return {
          indentation: getLeadingWhitespace(model.getLineContent(1)),
          action: null,
          line: 1
        };
      }
    }
  }
  getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {
    if (autoIndent < 4) {
      return null;
    }
    const richEditSupport = this.getLanguageConfiguration(languageId);
    if (!richEditSupport) {
      return null;
    }
    const indentRulesSupport = this.getIndentRulesSupport(languageId);
    if (!indentRulesSupport) {
      return null;
    }
    const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);
    const lineContent = virtualModel.getLineContent(lineNumber);
    if (indent) {
      const inheritLine = indent.line;
      if (inheritLine !== void 0) {
        const enterResult = richEditSupport.onEnter(autoIndent, "", virtualModel.getLineContent(inheritLine), "");
        if (enterResult) {
          let indentation = getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
          if (enterResult.removeText) {
            indentation = indentation.substring(0, indentation.length - enterResult.removeText);
          }
          if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {
            indentation = indentConverter.shiftIndent(indentation);
          } else if (enterResult.indentAction === IndentAction.Outdent) {
            indentation = indentConverter.unshiftIndent(indentation);
          }
          if (indentRulesSupport.shouldDecrease(lineContent)) {
            indentation = indentConverter.unshiftIndent(indentation);
          }
          if (enterResult.appendText) {
            indentation += enterResult.appendText;
          }
          return getLeadingWhitespace(indentation);
        }
      }
      if (indentRulesSupport.shouldDecrease(lineContent)) {
        if (indent.action === IndentAction.Indent) {
          return indent.indentation;
        } else {
          return indentConverter.unshiftIndent(indent.indentation);
        }
      } else {
        if (indent.action === IndentAction.Indent) {
          return indentConverter.shiftIndent(indent.indentation);
        } else {
          return indent.indentation;
        }
      }
    }
    return null;
  }
  getIndentForEnter(autoIndent, model, range2, indentConverter) {
    if (autoIndent < 4) {
      return null;
    }
    model.forceTokenization(range2.startLineNumber);
    const lineTokens = model.getLineTokens(range2.startLineNumber);
    const scopedLineTokens = createScopedLineTokens(lineTokens, range2.startColumn - 1);
    const scopedLineText = scopedLineTokens.getLineContent();
    let embeddedLanguage = false;
    let beforeEnterText;
    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
      embeddedLanguage = true;
      beforeEnterText = scopedLineText.substr(0, range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      beforeEnterText = lineTokens.getLineContent().substring(0, range2.startColumn - 1);
    }
    let afterEnterText;
    if (range2.isEmpty()) {
      afterEnterText = scopedLineText.substr(range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      const endScopedLineTokens = this.getScopedLineTokens(model, range2.endLineNumber, range2.endColumn);
      afterEnterText = endScopedLineTokens.getLineContent().substr(range2.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
    if (!indentRulesSupport) {
      return null;
    }
    const beforeEnterResult = beforeEnterText;
    const beforeEnterIndent = getLeadingWhitespace(beforeEnterText);
    const virtualModel = {
      getLineTokens: (lineNumber) => {
        return model.getLineTokens(lineNumber);
      },
      getLanguageId: () => {
        return model.getLanguageId();
      },
      getLanguageIdAtPosition: (lineNumber, column) => {
        return model.getLanguageIdAtPosition(lineNumber, column);
      },
      getLineContent: (lineNumber) => {
        if (lineNumber === range2.startLineNumber) {
          return beforeEnterResult;
        } else {
          return model.getLineContent(lineNumber);
        }
      }
    };
    const currentLineIndent = getLeadingWhitespace(lineTokens.getLineContent());
    const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range2.startLineNumber + 1);
    if (!afterEnterAction) {
      const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
      return {
        beforeEnter,
        afterEnter: beforeEnter
      };
    }
    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
    if (afterEnterAction.action === IndentAction.Indent) {
      afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
    }
    if (indentRulesSupport.shouldDecrease(afterEnterText)) {
      afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
    }
    return {
      beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
      afterEnter: afterEnterIndent
    };
  }
  /**
   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
   */
  getIndentActionForType(autoIndent, model, range2, ch, indentConverter) {
    if (autoIndent < 4) {
      return null;
    }
    const scopedLineTokens = this.getScopedLineTokens(model, range2.startLineNumber, range2.startColumn);
    if (scopedLineTokens.firstCharOffset) {
      return null;
    }
    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
    if (!indentRulesSupport) {
      return null;
    }
    const scopedLineText = scopedLineTokens.getLineContent();
    const beforeTypeText = scopedLineText.substr(0, range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    let afterTypeText;
    if (range2.isEmpty()) {
      afterTypeText = scopedLineText.substr(range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      const endScopedLineTokens = this.getScopedLineTokens(model, range2.endLineNumber, range2.endColumn);
      afterTypeText = endScopedLineTokens.getLineContent().substr(range2.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
      const r = this.getInheritIndentForLine(autoIndent, model, range2.startLineNumber, false);
      if (!r) {
        return null;
      }
      let indentation = r.indentation;
      if (r.action !== IndentAction.Indent) {
        indentation = indentConverter.unshiftIndent(indentation);
      }
      return indentation;
    }
    return null;
  }
  getIndentMetadata(model, lineNumber) {
    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());
    if (!indentRulesSupport) {
      return null;
    }
    if (lineNumber < 1 || lineNumber > model.getLineCount()) {
      return null;
    }
    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));
  }
  // end Indent Rules
  // begin onEnter
  getEnterAction(autoIndent, model, range2) {
    const scopedLineTokens = this.getScopedLineTokens(model, range2.startLineNumber, range2.startColumn);
    const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);
    if (!richEditSupport) {
      return null;
    }
    const scopedLineText = scopedLineTokens.getLineContent();
    const beforeEnterText = scopedLineText.substr(0, range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    let afterEnterText;
    if (range2.isEmpty()) {
      afterEnterText = scopedLineText.substr(range2.startColumn - 1 - scopedLineTokens.firstCharOffset);
    } else {
      const endScopedLineTokens = this.getScopedLineTokens(model, range2.endLineNumber, range2.endColumn);
      afterEnterText = endScopedLineTokens.getLineContent().substr(range2.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    let previousLineText = "";
    if (range2.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
      const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range2.startLineNumber - 1);
      if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
        previousLineText = oneLineAboveScopedLineTokens.getLineContent();
      }
    }
    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);
    if (!enterResult) {
      return null;
    }
    const indentAction = enterResult.indentAction;
    let appendText = enterResult.appendText;
    const removeText = enterResult.removeText || 0;
    if (!appendText) {
      if (indentAction === IndentAction.Indent || indentAction === IndentAction.IndentOutdent) {
        appendText = "	";
      } else {
        appendText = "";
      }
    } else if (indentAction === IndentAction.Indent) {
      appendText = "	" + appendText;
    }
    let indentation = this.getIndentationAtPosition(model, range2.startLineNumber, range2.startColumn);
    if (removeText) {
      indentation = indentation.substring(0, indentation.length - removeText);
    }
    return {
      indentAction,
      appendText,
      removeText,
      indentation
    };
  }
  getIndentationAtPosition(model, lineNumber, column) {
    const lineText = model.getLineContent(lineNumber);
    let indentation = getLeadingWhitespace(lineText);
    if (indentation.length > column - 1) {
      indentation = indentation.substring(0, column - 1);
    }
    return indentation;
  }
  getScopedLineTokens(model, lineNumber, columnNumber) {
    model.forceTokenization(lineNumber);
    const lineTokens = model.getLineTokens(lineNumber);
    const column = typeof columnNumber === "undefined" ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;
    return createScopedLineTokens(lineTokens, column);
  }
};
var LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
var ComposedLanguageConfiguration = class {
  constructor(languageId) {
    this.languageId = languageId;
    this._resolved = null;
    this._entries = [];
    this._order = 0;
    this._resolved = null;
  }
  register(configuration, priority) {
    const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);
    this._entries.push(entry);
    this._resolved = null;
    return toDisposable(() => {
      for (let i = 0; i < this._entries.length; i++) {
        if (this._entries[i] === entry) {
          this._entries.splice(i, 1);
          this._resolved = null;
          break;
        }
      }
    });
  }
  getResolvedConfiguration() {
    if (!this._resolved) {
      const config = this._resolve();
      if (config) {
        this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);
      }
    }
    return this._resolved;
  }
  _resolve() {
    if (this._entries.length === 0) {
      return null;
    }
    this._entries.sort(LanguageConfigurationContribution.cmp);
    return combineLanguageConfigurations(this._entries.map((e) => e.configuration));
  }
};
function combineLanguageConfigurations(configs) {
  let result = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const entry of configs) {
    result = {
      comments: entry.comments || result.comments,
      brackets: entry.brackets || result.brackets,
      wordPattern: entry.wordPattern || result.wordPattern,
      indentationRules: entry.indentationRules || result.indentationRules,
      onEnterRules: entry.onEnterRules || result.onEnterRules,
      autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,
      surroundingPairs: entry.surroundingPairs || result.surroundingPairs,
      autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,
      folding: entry.folding || result.folding,
      colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,
      __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport
    };
  }
  return result;
}
var LanguageConfigurationContribution = class {
  constructor(configuration, priority, order) {
    this.configuration = configuration;
    this.priority = priority;
    this.order = order;
  }
  static cmp(a, b) {
    if (a.priority === b.priority) {
      return a.order - b.order;
    }
    return a.priority - b.priority;
  }
};
var ResolvedLanguageConfiguration = class _ResolvedLanguageConfiguration {
  constructor(languageId, underlyingConfig) {
    this.languageId = languageId;
    this.underlyingConfig = underlyingConfig;
    this._brackets = null;
    this._electricCharacter = null;
    this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new OnEnterSupport(this.underlyingConfig) : null;
    this.comments = _ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);
    this.characterPair = new CharacterPairSupport(this.underlyingConfig);
    this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;
    this.indentationRules = this.underlyingConfig.indentationRules;
    if (this.underlyingConfig.indentationRules) {
      this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);
    } else {
      this.indentRulesSupport = null;
    }
    this.foldingRules = this.underlyingConfig.folding || {};
  }
  getWordDefinition() {
    return ensureValidWordDefinition(this.wordDefinition);
  }
  get brackets() {
    if (!this._brackets && this.underlyingConfig.brackets) {
      this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);
    }
    return this._brackets;
  }
  get electricCharacter() {
    if (!this._electricCharacter) {
      this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);
    }
    return this._electricCharacter;
  }
  onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
    if (!this._onEnterSupport) {
      return null;
    }
    return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);
  }
  getAutoClosingPairs() {
    return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());
  }
  getAutoCloseBeforeSet() {
    return this.characterPair.getAutoCloseBeforeSet();
  }
  getSurroundingPairs() {
    return this.characterPair.getSurroundingPairs();
  }
  static _handleComments(conf) {
    const commentRule = conf.comments;
    if (!commentRule) {
      return null;
    }
    const comments = {};
    if (commentRule.lineComment) {
      comments.lineCommentToken = commentRule.lineComment;
    }
    if (commentRule.blockComment) {
      const [blockStart, blockEnd] = commentRule.blockComment;
      comments.blockCommentStartToken = blockStart;
      comments.blockCommentEndToken = blockEnd;
    }
    return comments;
  }
};
registerSingleton(ILanguageConfigurationService, LanguageConfigurationService);

// node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js
var NullState = new class {
  clone() {
    return this;
  }
  equals(other) {
    return this === other;
  }
}();
function nullTokenize(languageId, state) {
  return new TokenizationResult([new Token(0, "", languageId)], state);
}
function nullTokenizeEncoded(languageId, state) {
  const tokens = new Uint32Array(2);
  tokens[0] = 0;
  tokens[1] = (languageId << 0 | 0 << 8 | 0 << 10 | 1 << 14 | 2 << 23) >>> 0;
  return new EncodedTokenizationResult(tokens, state === null ? NullState : state);
}

// node_modules/monaco-editor/esm/vs/base/common/uint.js
function toUint8(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 255) {
    return 255;
  }
  return v | 0;
}
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 4294967295) {
    return 4294967295;
  }
  return v | 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
var CharacterClassifier = class _CharacterClassifier {
  constructor(_defaultValue) {
    const defaultValue = toUint8(_defaultValue);
    this._defaultValue = defaultValue;
    this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
    this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(defaultValue) {
    const asciiMap = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      asciiMap[i] = defaultValue;
    }
    return asciiMap;
  }
  set(charCode, _value) {
    const value = toUint8(_value);
    if (charCode >= 0 && charCode < 256) {
      this._asciiMap[charCode] = value;
    } else {
      this._map.set(charCode, value);
    }
  }
  get(charCode) {
    if (charCode >= 0 && charCode < 256) {
      return this._asciiMap[charCode];
    } else {
      return this._map.get(charCode) || this._defaultValue;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
var WordCharacterClassifier = class extends CharacterClassifier {
  constructor(wordSeparators) {
    super(
      0
      /* Regular */
    );
    for (let i = 0, len = wordSeparators.length; i < len; i++) {
      this.set(
        wordSeparators.charCodeAt(i),
        2
        /* WordSeparator */
      );
    }
    this.set(
      32,
      1
      /* Whitespace */
    );
    this.set(
      9,
      1
      /* Whitespace */
    );
  }
};
function once2(computeFn) {
  const cache = {};
  return (input) => {
    if (!cache.hasOwnProperty(input)) {
      cache[input] = computeFn(input);
    }
    return cache[input];
  };
}
var getMapForWordSeparators = once2((input) => new WordCharacterClassifier(input));

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
var LIMIT_FIND_COUNT = 999;
var SearchParams = class {
  constructor(searchString, isRegex, matchCase, wordSeparators) {
    this.searchString = searchString;
    this.isRegex = isRegex;
    this.matchCase = matchCase;
    this.wordSeparators = wordSeparators;
  }
  parseSearchRequest() {
    if (this.searchString === "") {
      return null;
    }
    let multiline;
    if (this.isRegex) {
      multiline = isMultilineRegexSource(this.searchString);
    } else {
      multiline = this.searchString.indexOf("\n") >= 0;
    }
    let regex = null;
    try {
      regex = createRegExp(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: false,
        multiline,
        global: true,
        unicode: true
      });
    } catch (err) {
      return null;
    }
    if (!regex) {
      return null;
    }
    let canUseSimpleSearch = !this.isRegex && !multiline;
    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
      canUseSimpleSearch = this.matchCase;
    }
    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);
  }
};
function isMultilineRegexSource(searchString) {
  if (!searchString || searchString.length === 0) {
    return false;
  }
  for (let i = 0, len = searchString.length; i < len; i++) {
    const chCode = searchString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = searchString.charCodeAt(i);
      if (nextChCode === 110 || nextChCode === 114 || nextChCode === 87) {
        return true;
      }
    }
  }
  return false;
}
function createFindMatch(range2, rawMatches, captureMatches) {
  if (!captureMatches) {
    return new FindMatch(range2, null);
  }
  const matches = [];
  for (let i = 0, len = rawMatches.length; i < len; i++) {
    matches[i] = rawMatches[i];
  }
  return new FindMatch(range2, matches);
}
var LineFeedCounter = class {
  constructor(text) {
    const lineFeedsOffsets = [];
    let lineFeedsOffsetsLen = 0;
    for (let i = 0, textLen = text.length; i < textLen; i++) {
      if (text.charCodeAt(i) === 10) {
        lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
      }
    }
    this._lineFeedsOffsets = lineFeedsOffsets;
  }
  findLineFeedCountBeforeOffset(offset) {
    const lineFeedsOffsets = this._lineFeedsOffsets;
    let min = 0;
    let max = lineFeedsOffsets.length - 1;
    if (max === -1) {
      return 0;
    }
    if (offset <= lineFeedsOffsets[0]) {
      return 0;
    }
    while (min < max) {
      const mid = min + ((max - min) / 2 >> 0);
      if (lineFeedsOffsets[mid] >= offset) {
        max = mid - 1;
      } else {
        if (lineFeedsOffsets[mid + 1] >= offset) {
          min = mid;
          max = mid;
        } else {
          min = mid + 1;
        }
      }
    }
    return min + 1;
  }
};
var TextModelSearch = class {
  static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return [];
    }
    if (searchData.regex.multiline) {
      return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
    }
    return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {
    let startOffset;
    let lineFeedCountBeforeMatch = 0;
    if (lfCounter) {
      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch;
    } else {
      startOffset = deltaOffset + matchIndex;
    }
    let endOffset;
    if (lfCounter) {
      const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
      const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
      endOffset = startOffset + match0.length + lineFeedCountInMatch;
    } else {
      endOffset = startOffset + match0.length;
    }
    const startPosition = model.getPositionAt(startOffset);
    const endPosition = model.getPositionAt(endOffset);
    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
  }
  static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {
    const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
    const text = model.getValueInRange(
      searchRange,
      1
      /* LF */
    );
    const lfCounter = model.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
    const result = [];
    let counter = 0;
    let m;
    searcher.reset(0);
    while (m = searcher.next(text)) {
      result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
      if (counter >= limitResultCount) {
        return result;
      }
    }
    return result;
  }
  static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {
    const result = [];
    let resultLen = 0;
    if (searchRange.startLineNumber === searchRange.endLineNumber) {
      const text2 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, text2, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
      return result;
    }
    const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
    resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
    for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
      resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
    }
    if (resultLen < limitResultCount) {
      const text2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, text2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
    }
    return result;
  }
  static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
          if (resultLen >= limitResultCount) {
            return resultLen;
          }
        }
      }
      return resultLen;
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  static findNextMatch(model, searchParams, searchStart, captureMatches) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return null;
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    if (searchData.regex.multiline) {
      return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);
    }
    return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
  }
  static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {
    const searchTextStart = new Position(searchStart.lineNumber, 1);
    const deltaOffset = model.getOffsetAt(searchTextStart);
    const lineCount = model.getLineCount();
    const text = model.getValueInRange(
      new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)),
      1
      /* LF */
    );
    const lfCounter = model.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
    searcher.reset(searchStart.column - 1);
    let m = searcher.next(text);
    if (m) {
      return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
    }
    if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
      return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);
    }
    return null;
  }
  static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {
    const lineCount = model.getLineCount();
    const startLineNumber = searchStart.lineNumber;
    const text = model.getLineContent(startLineNumber);
    const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
    if (r) {
      return r;
    }
    for (let i = 1; i <= lineCount; i++) {
      const lineIndex = (startLineNumber + i - 1) % lineCount;
      const text2 = model.getLineContent(lineIndex + 1);
      const r2 = this._findFirstMatchInLine(searcher, text2, lineIndex + 1, 1, captureMatches);
      if (r2) {
        return r2;
      }
    }
    return null;
  }
  static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {
    searcher.reset(fromColumn - 1);
    const m = searcher.next(text);
    if (m) {
      return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
    }
    return null;
  }
  static findPreviousMatch(model, searchParams, searchStart, captureMatches) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return null;
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    if (searchData.regex.multiline) {
      return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);
    }
    return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
  }
  static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {
    const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
    if (matches.length > 0) {
      return matches[matches.length - 1];
    }
    const lineCount = model.getLineCount();
    if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
      return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);
    }
    return null;
  }
  static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {
    const lineCount = model.getLineCount();
    const startLineNumber = searchStart.lineNumber;
    const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
    const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
    if (r) {
      return r;
    }
    for (let i = 1; i <= lineCount; i++) {
      const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
      const text2 = model.getLineContent(lineIndex + 1);
      const r2 = this._findLastMatchInLine(searcher, text2, lineIndex + 1, captureMatches);
      if (r2) {
        return r2;
      }
    }
    return null;
  }
  static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {
    let bestResult = null;
    let m;
    searcher.reset(0);
    while (m = searcher.next(text)) {
      bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
    }
    return bestResult;
  }
};
function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex === 0) {
    return true;
  }
  const charBefore = text.charCodeAt(matchStartIndex - 1);
  if (wordSeparators.get(charBefore) !== 0) {
    return true;
  }
  if (charBefore === 13 || charBefore === 10) {
    return true;
  }
  if (matchLength > 0) {
    const firstCharInMatch = text.charCodeAt(matchStartIndex);
    if (wordSeparators.get(firstCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex + matchLength === textLength) {
    return true;
  }
  const charAfter = text.charCodeAt(matchStartIndex + matchLength);
  if (wordSeparators.get(charAfter) !== 0) {
    return true;
  }
  if (charAfter === 13 || charAfter === 10) {
    return true;
  }
  if (matchLength > 0) {
    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
    if (wordSeparators.get(lastCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
}
var Searcher = class {
  constructor(wordSeparators, searchRegex) {
    this._wordSeparators = wordSeparators;
    this._searchRegex = searchRegex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  reset(lastIndex2) {
    this._searchRegex.lastIndex = lastIndex2;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  next(text) {
    const textLength = text.length;
    let m;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
        return null;
      }
      m = this._searchRegex.exec(text);
      if (!m) {
        return null;
      }
      const matchStartIndex = m.index;
      const matchLength = m[0].length;
      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
        if (matchLength === 0) {
          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
            this._searchRegex.lastIndex += 2;
          } else {
            this._searchRegex.lastIndex += 1;
          }
          continue;
        }
        return null;
      }
      this._prevMatchStartIndex = matchStartIndex;
      this._prevMatchLength = matchLength;
      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
        return m;
      }
    } while (m);
    return null;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/browser.js
var browser_exports = {};
__export(browser_exports, {
  PixelRatio: () => PixelRatio,
  getZoomFactor: () => getZoomFactor,
  isAndroid: () => isAndroid2,
  isChrome: () => isChrome2,
  isElectron: () => isElectron,
  isFirefox: () => isFirefox2,
  isSafari: () => isSafari2,
  isStandalone: () => isStandalone,
  isWebKit: () => isWebKit,
  isWebkitWebView: () => isWebkitWebView
});
var WindowManager = class {
  constructor() {
    this._zoomFactor = 1;
  }
  getZoomFactor() {
    return this._zoomFactor;
  }
};
WindowManager.INSTANCE = new WindowManager();
var DevicePixelRatioMonitor = class extends Disposable {
  constructor() {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._listener = () => this._handleChange(true);
    this._mediaQueryList = null;
    this._handleChange(false);
  }
  _handleChange(fireEvent) {
    if (this._mediaQueryList) {
      this._mediaQueryList.removeEventListener("change", this._listener);
    }
    this._mediaQueryList = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
    this._mediaQueryList.addEventListener("change", this._listener);
    if (fireEvent) {
      this._onDidChange.fire();
    }
  }
};
var PixelRatioImpl = class extends Disposable {
  constructor() {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._value = this._getPixelRatio();
    const dprMonitor = this._register(new DevicePixelRatioMonitor());
    this._register(dprMonitor.onDidChange(() => {
      this._value = this._getPixelRatio();
      this._onDidChange.fire(this._value);
    }));
  }
  get value() {
    return this._value;
  }
  _getPixelRatio() {
    const ctx = document.createElement("canvas").getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    const bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
    return dpr / bsr;
  }
};
var PixelRatioFacade = class {
  constructor() {
    this._pixelRatioMonitor = null;
  }
  _getOrCreatePixelRatioMonitor() {
    if (!this._pixelRatioMonitor) {
      this._pixelRatioMonitor = new PixelRatioImpl();
    }
    return this._pixelRatioMonitor;
  }
  /**
   * Get the current value.
   */
  get value() {
    return this._getOrCreatePixelRatioMonitor().value;
  }
  /**
   * Listen for changes.
   */
  get onDidChange() {
    return this._getOrCreatePixelRatioMonitor().onDidChange;
  }
};
var PixelRatio = new PixelRatioFacade();
function getZoomFactor() {
  return WindowManager.INSTANCE.getZoomFactor();
}
var userAgent2 = navigator.userAgent;
var isFirefox2 = userAgent2.indexOf("Firefox") >= 0;
var isWebKit = userAgent2.indexOf("AppleWebKit") >= 0;
var isChrome2 = userAgent2.indexOf("Chrome") >= 0;
var isSafari2 = !isChrome2 && userAgent2.indexOf("Safari") >= 0;
var isWebkitWebView = !isChrome2 && !isSafari2 && isWebKit;
var isElectron = userAgent2.indexOf("Electron/") >= 0;
var isAndroid2 = userAgent2.indexOf("Android") >= 0;
var isStandalone = window.matchMedia && window.matchMedia("(display-mode: standalone)").matches;

// node_modules/monaco-editor/esm/vs/base/browser/canIUse.js
var BrowserFeatures = {
  clipboard: {
    writeText: isNative || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: isNative || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  keyboard: (() => {
    if (isNative || isStandalone) {
      return 0;
    }
    if (navigator.keyboard || isSafari2) {
      return 1;
    }
    return 2;
  })(),
  // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be
  // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast
  touch: "ontouchstart" in window || navigator.maxTouchPoints > 0,
  pointerEvents: window.PointerEvent && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0)
};

// node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js
function extractKeyCode(e) {
  if (e.charCode) {
    let char = String.fromCharCode(e.charCode).toUpperCase();
    return KeyCodeUtils.fromString(char);
  }
  const keyCode = e.keyCode;
  if (keyCode === 3) {
    return 7;
  } else if (isFirefox2) {
    if (keyCode === 59) {
      return 80;
    } else if (keyCode === 107) {
      return 81;
    } else if (keyCode === 109) {
      return 83;
    } else if (isMacintosh && keyCode === 224) {
      return 57;
    }
  } else if (isWebKit) {
    if (keyCode === 91) {
      return 57;
    } else if (isMacintosh && keyCode === 93) {
      return 57;
    } else if (!isMacintosh && keyCode === 92) {
      return 57;
    }
  }
  return EVENT_KEY_CODE_MAP[keyCode] || 0;
}
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var altKeyMod = 512;
var shiftKeyMod = 1024;
var metaKeyMod = isMacintosh ? 2048 : 256;
var StandardKeyboardEvent = class {
  constructor(source) {
    this._standardKeyboardEventBrand = true;
    let e = source;
    this.browserEvent = e;
    this.target = e.target;
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    this.keyCode = extractKeyCode(e);
    this.code = e.code;
    this.ctrlKey = this.ctrlKey || this.keyCode === 5;
    this.altKey = this.altKey || this.keyCode === 6;
    this.shiftKey = this.shiftKey || this.keyCode === 4;
    this.metaKey = this.metaKey || this.keyCode === 57;
    this._asKeybinding = this._computeKeybinding();
    this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
  }
  preventDefault() {
    if (this.browserEvent && this.browserEvent.preventDefault) {
      this.browserEvent.preventDefault();
    }
  }
  stopPropagation() {
    if (this.browserEvent && this.browserEvent.stopPropagation) {
      this.browserEvent.stopPropagation();
    }
  }
  toKeybinding() {
    return this._asRuntimeKeybinding;
  }
  equals(other) {
    return this._asKeybinding === other;
  }
  _computeKeybinding() {
    let key = 0;
    if (this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57) {
      key = this.keyCode;
    }
    let result = 0;
    if (this.ctrlKey) {
      result |= ctrlKeyMod;
    }
    if (this.altKey) {
      result |= altKeyMod;
    }
    if (this.shiftKey) {
      result |= shiftKeyMod;
    }
    if (this.metaKey) {
      result |= metaKeyMod;
    }
    result |= key;
    return result;
  }
  _computeRuntimeKeybinding() {
    let key = 0;
    if (this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57) {
      key = this.keyCode;
    }
    return new SimpleKeybinding(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/iframe.js
var hasDifferentOriginAncestorFlag = false;
var sameOriginWindowChainCache = null;
function getParentWindowIfSameOrigin(w) {
  if (!w.parent || w.parent === w) {
    return null;
  }
  try {
    let location = w.location;
    let parentLocation = w.parent.location;
    if (location.origin !== "null" && parentLocation.origin !== "null" && location.origin !== parentLocation.origin) {
      hasDifferentOriginAncestorFlag = true;
      return null;
    }
  } catch (e) {
    hasDifferentOriginAncestorFlag = true;
    return null;
  }
  return w.parent;
}
var IframeUtils = class {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
   */
  static getSameOriginWindowChain() {
    if (!sameOriginWindowChainCache) {
      sameOriginWindowChainCache = [];
      let w = window;
      let parent;
      do {
        parent = getParentWindowIfSameOrigin(w);
        if (parent) {
          sameOriginWindowChainCache.push({
            window: w,
            iframeElement: w.frameElement || null
          });
        } else {
          sameOriginWindowChainCache.push({
            window: w,
            iframeElement: null
          });
        }
        w = parent;
      } while (w);
    }
    return sameOriginWindowChainCache.slice(0);
  }
  /**
   * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
   * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
   */
  static hasDifferentOriginAncestor() {
    if (!sameOriginWindowChainCache) {
      this.getSameOriginWindowChain();
    }
    return hasDifferentOriginAncestorFlag;
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {
    if (!ancestorWindow || childWindow === ancestorWindow) {
      return {
        top: 0,
        left: 0
      };
    }
    let top = 0, left = 0;
    let windowChain = this.getSameOriginWindowChain();
    for (const windowChainEl of windowChain) {
      top += windowChainEl.window.scrollY;
      left += windowChainEl.window.scrollX;
      if (windowChainEl.window === ancestorWindow) {
        break;
      }
      if (!windowChainEl.iframeElement) {
        break;
      }
      let boundingRect = windowChainEl.iframeElement.getBoundingClientRect();
      top += boundingRect.top;
      left += boundingRect.left;
    }
    return {
      top,
      left
    };
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js
var StandardMouseEvent = class {
  constructor(e) {
    this.timestamp = Date.now();
    this.browserEvent = e;
    this.leftButton = e.button === 0;
    this.middleButton = e.button === 1;
    this.rightButton = e.button === 2;
    this.buttons = e.buttons;
    this.target = e.target;
    this.detail = e.detail || 1;
    if (e.type === "dblclick") {
      this.detail = 2;
    }
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    if (typeof e.pageX === "number") {
      this.posx = e.pageX;
      this.posy = e.pageY;
    } else {
      this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    let iframeOffsets = IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
    this.posx -= iframeOffsets.left;
    this.posy -= iframeOffsets.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
};
var StandardWheelEvent = class {
  constructor(e, deltaX = 0, deltaY = 0) {
    this.browserEvent = e || null;
    this.target = e ? e.target || e.targetNode || e.srcElement : null;
    this.deltaY = deltaY;
    this.deltaX = deltaX;
    if (e) {
      let e1 = e;
      let e2 = e;
      if (typeof e1.wheelDeltaY !== "undefined") {
        this.deltaY = e1.wheelDeltaY / 120;
      } else if (typeof e2.VERTICAL_AXIS !== "undefined" && e2.axis === e2.VERTICAL_AXIS) {
        this.deltaY = -e2.detail / 3;
      } else if (e.type === "wheel") {
        const ev = e;
        if (ev.deltaMode === ev.DOM_DELTA_LINE) {
          if (isFirefox2 && !isMacintosh) {
            this.deltaY = -e.deltaY / 3;
          } else {
            this.deltaY = -e.deltaY;
          }
        } else {
          this.deltaY = -e.deltaY / 40;
        }
      }
      if (typeof e1.wheelDeltaX !== "undefined") {
        if (isSafari2 && isWindows) {
          this.deltaX = -(e1.wheelDeltaX / 120);
        } else {
          this.deltaX = e1.wheelDeltaX / 120;
        }
      } else if (typeof e2.HORIZONTAL_AXIS !== "undefined" && e2.axis === e2.HORIZONTAL_AXIS) {
        this.deltaX = -e.detail / 3;
      } else if (e.type === "wheel") {
        const ev = e;
        if (ev.deltaMode === ev.DOM_DELTA_LINE) {
          if (isFirefox2 && !isMacintosh) {
            this.deltaX = -e.deltaX / 3;
          } else {
            this.deltaX = -e.deltaX;
          }
        } else {
          this.deltaX = -e.deltaX / 40;
        }
      }
      if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {
        this.deltaY = e.wheelDelta / 120;
      }
    }
  }
  preventDefault() {
    if (this.browserEvent) {
      this.browserEvent.preventDefault();
    }
  }
  stopPropagation() {
    if (this.browserEvent) {
      this.browserEvent.stopPropagation();
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/common/network.js
var Schemas;
(function(Schemas2) {
  Schemas2.inMemory = "inmemory";
  Schemas2.vscode = "vscode";
  Schemas2.internal = "private";
  Schemas2.walkThrough = "walkThrough";
  Schemas2.walkThroughSnippet = "walkThroughSnippet";
  Schemas2.http = "http";
  Schemas2.https = "https";
  Schemas2.file = "file";
  Schemas2.mailto = "mailto";
  Schemas2.untitled = "untitled";
  Schemas2.data = "data";
  Schemas2.command = "command";
  Schemas2.vscodeRemote = "vscode-remote";
  Schemas2.vscodeRemoteResource = "vscode-remote-resource";
  Schemas2.userData = "vscode-userdata";
  Schemas2.vscodeCustomEditor = "vscode-custom-editor";
  Schemas2.vscodeNotebook = "vscode-notebook";
  Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
  Schemas2.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
  Schemas2.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
  Schemas2.vscodeInteractive = "vscode-interactive";
  Schemas2.vscodeInteractiveInput = "vscode-interactive-input";
  Schemas2.vscodeSettings = "vscode-settings";
  Schemas2.vscodeWorkspaceTrust = "vscode-workspace-trust";
  Schemas2.vscodeTerminal = "vscode-terminal";
  Schemas2.webviewPanel = "webview-panel";
  Schemas2.vscodeWebview = "vscode-webview";
  Schemas2.extension = "extension";
  Schemas2.vscodeFileResource = "vscode-file";
  Schemas2.tmp = "tmp";
  Schemas2.vsls = "vsls";
})(Schemas || (Schemas = {}));
var connectionTokenQueryName = "tkn";
var RemoteAuthoritiesImpl = class {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null);
    this._ports = /* @__PURE__ */ Object.create(null);
    this._connectionTokens = /* @__PURE__ */ Object.create(null);
    this._preferredWebSchema = "http";
    this._delegate = null;
  }
  setPreferredWebSchema(schema) {
    this._preferredWebSchema = schema;
  }
  rewrite(uri) {
    if (this._delegate) {
      return this._delegate(uri);
    }
    const authority = uri.authority;
    let host = this._hosts[authority];
    if (host && host.indexOf(":") !== -1) {
      host = `[${host}]`;
    }
    const port = this._ports[authority];
    const connectionToken = this._connectionTokens[authority];
    let query = `path=${encodeURIComponent(uri.path)}`;
    if (typeof connectionToken === "string") {
      query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
    }
    return URI.from({
      scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
      authority: `${host}:${port}`,
      path: `/vscode-remote-resource`,
      query
    });
  }
};
var RemoteAuthorities = new RemoteAuthoritiesImpl();
var FileAccessImpl = class _FileAccessImpl {
  asBrowserUri(uriOrModule, moduleIdToUrl) {
    const uri = this.toUri(uriOrModule, moduleIdToUrl);
    if (uri.scheme === Schemas.vscodeRemote) {
      return RemoteAuthorities.rewrite(uri);
    }
    if (
      // ...only ever for `file` resources
      uri.scheme === Schemas.file && // ...and we run in native environments
      (isNative || // ...or web worker extensions on desktop
      isWebWorker && globals.origin === `${Schemas.vscodeFileResource}://${_FileAccessImpl.FALLBACK_AUTHORITY}`)
    ) {
      return uri.with({
        scheme: Schemas.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: uri.authority || _FileAccessImpl.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      });
    }
    return uri;
  }
  toUri(uriOrModule, moduleIdToUrl) {
    if (URI.isUri(uriOrModule)) {
      return uriOrModule;
    }
    return URI.parse(moduleIdToUrl.toUrl(uriOrModule));
  }
};
FileAccessImpl.FALLBACK_AUTHORITY = "vscode-app";
var FileAccess = new FileAccessImpl();

// node_modules/monaco-editor/esm/vs/base/browser/dom.js
function clearNode(node) {
  while (node.firstChild) {
    node.firstChild.remove();
  }
}
function isInDOM(node) {
  var _a3;
  return (_a3 = node === null || node === void 0 ? void 0 : node.isConnected) !== null && _a3 !== void 0 ? _a3 : false;
}
var DomListener = class {
  constructor(node, type, handler, options) {
    this._node = node;
    this._type = type;
    this._handler = handler;
    this._options = options || false;
    this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    if (!this._handler) {
      return;
    }
    this._node.removeEventListener(this._type, this._handler, this._options);
    this._node = null;
    this._handler = null;
  }
};
function addDisposableListener(node, type, handler, useCaptureOrOptions) {
  return new DomListener(node, type, handler, useCaptureOrOptions);
}
function _wrapAsStandardMouseEvent(handler) {
  return function(e) {
    return handler(new StandardMouseEvent(e));
  };
}
function _wrapAsStandardKeyboardEvent(handler) {
  return function(e) {
    return handler(new StandardKeyboardEvent(e));
  };
}
var addStandardDisposableListener = function addStandardDisposableListener2(node, type, handler, useCapture) {
  let wrapHandler = handler;
  if (type === "click" || type === "mousedown") {
    wrapHandler = _wrapAsStandardMouseEvent(handler);
  } else if (type === "keydown" || type === "keypress" || type === "keyup") {
    wrapHandler = _wrapAsStandardKeyboardEvent(handler);
  }
  return addDisposableListener(node, type, wrapHandler, useCapture);
};
function addDisposableNonBubblingMouseOutListener(node, handler) {
  return addDisposableListener(node, "mouseout", (e) => {
    let toElement = e.relatedTarget;
    while (toElement && toElement !== node) {
      toElement = toElement.parentNode;
    }
    if (toElement === node) {
      return;
    }
    handler(e);
  });
}
function addDisposableNonBubblingPointerOutListener(node, handler) {
  return addDisposableListener(node, "pointerout", (e) => {
    let toElement = e.relatedTarget;
    while (toElement && toElement !== node) {
      toElement = toElement.parentNode;
    }
    if (toElement === node) {
      return;
    }
    handler(e);
  });
}
function createEventEmitter(target, type, options) {
  let domListener = null;
  const handler = (e) => result.fire(e);
  const onFirstListenerAdd = () => {
    if (!domListener) {
      domListener = new DomListener(target, type, handler, options);
    }
  };
  const onLastListenerRemove = () => {
    if (domListener) {
      domListener.dispose();
      domListener = null;
    }
  };
  const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
  return result;
}
var _animationFrame = null;
function doRequestAnimationFrame(callback) {
  if (!_animationFrame) {
    const emulatedRequestAnimationFrame = (callback2) => {
      return setTimeout(() => callback2((/* @__PURE__ */ new Date()).getTime()), 0);
    };
    _animationFrame = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || emulatedRequestAnimationFrame;
  }
  return _animationFrame.call(self, callback);
}
var runAtThisOrScheduleAtNextAnimationFrame;
var scheduleAtNextAnimationFrame;
var AnimationFrameQueueItem = class {
  constructor(runner, priority = 0) {
    this._runner = runner;
    this.priority = priority;
    this._canceled = false;
  }
  dispose() {
    this._canceled = true;
  }
  execute() {
    if (this._canceled) {
      return;
    }
    try {
      this._runner();
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  // Sort by priority (largest to lowest)
  static sort(a, b) {
    return b.priority - a.priority;
  }
};
(function() {
  let NEXT_QUEUE = [];
  let CURRENT_QUEUE = null;
  let animFrameRequested = false;
  let inAnimationFrameRunner = false;
  let animationFrameRunner = () => {
    animFrameRequested = false;
    CURRENT_QUEUE = NEXT_QUEUE;
    NEXT_QUEUE = [];
    inAnimationFrameRunner = true;
    while (CURRENT_QUEUE.length > 0) {
      CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
      let top = CURRENT_QUEUE.shift();
      top.execute();
    }
    inAnimationFrameRunner = false;
  };
  scheduleAtNextAnimationFrame = (runner, priority = 0) => {
    let item = new AnimationFrameQueueItem(runner, priority);
    NEXT_QUEUE.push(item);
    if (!animFrameRequested) {
      animFrameRequested = true;
      doRequestAnimationFrame(animationFrameRunner);
    }
    return item;
  };
  runAtThisOrScheduleAtNextAnimationFrame = (runner, priority) => {
    if (inAnimationFrameRunner) {
      let item = new AnimationFrameQueueItem(runner, priority);
      CURRENT_QUEUE.push(item);
      return item;
    } else {
      return scheduleAtNextAnimationFrame(runner, priority);
    }
  };
})();
var MINIMUM_TIME_MS = 8;
var DEFAULT_EVENT_MERGER = function(lastEvent, currentEvent) {
  return currentEvent;
};
var TimeoutThrottledDomListener = class extends Disposable {
  constructor(node, type, handler, eventMerger = DEFAULT_EVENT_MERGER, minimumTimeMs = MINIMUM_TIME_MS) {
    super();
    let lastEvent = null;
    let lastHandlerTime = 0;
    let timeout2 = this._register(new TimeoutTimer());
    let invokeHandler = () => {
      lastHandlerTime = (/* @__PURE__ */ new Date()).getTime();
      handler(lastEvent);
      lastEvent = null;
    };
    this._register(addDisposableListener(node, type, (e) => {
      lastEvent = eventMerger(lastEvent, e);
      let elapsedTime = (/* @__PURE__ */ new Date()).getTime() - lastHandlerTime;
      if (elapsedTime >= minimumTimeMs) {
        timeout2.cancel();
        invokeHandler();
      } else {
        timeout2.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
      }
    }));
  }
};
function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
  return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
}
function getComputedStyle(el) {
  return document.defaultView.getComputedStyle(el, null);
}
function getClientArea(element) {
  if (element !== document.body) {
    return new Dimension(element.clientWidth, element.clientHeight);
  }
  if (isIOS && window.visualViewport) {
    return new Dimension(window.visualViewport.width, window.visualViewport.height);
  }
  if (window.innerWidth && window.innerHeight) {
    return new Dimension(window.innerWidth, window.innerHeight);
  }
  if (document.body && document.body.clientWidth && document.body.clientHeight) {
    return new Dimension(document.body.clientWidth, document.body.clientHeight);
  }
  if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {
    return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);
  }
  throw new Error("Unable to figure out browser width and height");
}
var SizeUtils = class _SizeUtils {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(element, value) {
    return parseFloat(value) || 0;
  }
  static getDimension(element, cssPropertyName, jsPropertyName) {
    let computedStyle = getComputedStyle(element);
    let value = "0";
    if (computedStyle) {
      if (computedStyle.getPropertyValue) {
        value = computedStyle.getPropertyValue(cssPropertyName);
      } else {
        value = computedStyle.getAttribute(jsPropertyName);
      }
    }
    return _SizeUtils.convertToPixels(element, value);
  }
  static getBorderLeftWidth(element) {
    return _SizeUtils.getDimension(element, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(element) {
    return _SizeUtils.getDimension(element, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(element) {
    return _SizeUtils.getDimension(element, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(element) {
    return _SizeUtils.getDimension(element, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(element) {
    return _SizeUtils.getDimension(element, "padding-left", "paddingLeft");
  }
  static getPaddingRight(element) {
    return _SizeUtils.getDimension(element, "padding-right", "paddingRight");
  }
  static getPaddingTop(element) {
    return _SizeUtils.getDimension(element, "padding-top", "paddingTop");
  }
  static getPaddingBottom(element) {
    return _SizeUtils.getDimension(element, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(element) {
    return _SizeUtils.getDimension(element, "margin-left", "marginLeft");
  }
  static getMarginTop(element) {
    return _SizeUtils.getDimension(element, "margin-top", "marginTop");
  }
  static getMarginRight(element) {
    return _SizeUtils.getDimension(element, "margin-right", "marginRight");
  }
  static getMarginBottom(element) {
    return _SizeUtils.getDimension(element, "margin-bottom", "marginBottom");
  }
};
var Dimension = class _Dimension {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  with(width = this.width, height = this.height) {
    if (width !== this.width || height !== this.height) {
      return new _Dimension(width, height);
    } else {
      return this;
    }
  }
  static is(obj) {
    return typeof obj === "object" && typeof obj.height === "number" && typeof obj.width === "number";
  }
  static lift(obj) {
    if (obj instanceof _Dimension) {
      return obj;
    } else {
      return new _Dimension(obj.width, obj.height);
    }
  }
  static equals(a, b) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return a.width === b.width && a.height === b.height;
  }
};
Dimension.None = new Dimension(0, 0);
function getTopLeftOffset(element) {
  let offsetParent = element.offsetParent;
  let top = element.offsetTop;
  let left = element.offsetLeft;
  while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
    top -= element.scrollTop;
    const c = isShadowRoot(element) ? null : getComputedStyle(element);
    if (c) {
      left -= c.direction !== "rtl" ? element.scrollLeft : -element.scrollLeft;
    }
    if (element === offsetParent) {
      left += SizeUtils.getBorderLeftWidth(element);
      top += SizeUtils.getBorderTopWidth(element);
      top += element.offsetTop;
      left += element.offsetLeft;
      offsetParent = element.offsetParent;
    }
  }
  return {
    left,
    top
  };
}
function getDomNodePagePosition(domNode) {
  let bb = domNode.getBoundingClientRect();
  return {
    left: bb.left + StandardWindow.scrollX,
    top: bb.top + StandardWindow.scrollY,
    width: bb.width,
    height: bb.height
  };
}
var StandardWindow = new class {
  get scrollX() {
    if (typeof window.scrollX === "number") {
      return window.scrollX;
    } else {
      return document.body.scrollLeft + document.documentElement.scrollLeft;
    }
  }
  get scrollY() {
    if (typeof window.scrollY === "number") {
      return window.scrollY;
    } else {
      return document.body.scrollTop + document.documentElement.scrollTop;
    }
  }
}();
function getTotalWidth(element) {
  let margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
  return element.offsetWidth + margin;
}
function getContentWidth(element) {
  let border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element);
  let padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
  return element.offsetWidth - border - padding;
}
function getContentHeight(element) {
  let border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element);
  let padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);
  return element.offsetHeight - border - padding;
}
function getTotalHeight(element) {
  let margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
  return element.offsetHeight + margin;
}
function isAncestor(testChild, testAncestor) {
  while (testChild) {
    if (testChild === testAncestor) {
      return true;
    }
    testChild = testChild.parentNode;
  }
  return false;
}
function findParentWithClass(node, clazz, stopAtClazzOrNode) {
  while (node && node.nodeType === node.ELEMENT_NODE) {
    if (node.classList.contains(clazz)) {
      return node;
    }
    if (stopAtClazzOrNode) {
      if (typeof stopAtClazzOrNode === "string") {
        if (node.classList.contains(stopAtClazzOrNode)) {
          return null;
        }
      } else {
        if (node === stopAtClazzOrNode) {
          return null;
        }
      }
    }
    node = node.parentNode;
  }
  return null;
}
function hasParentWithClass(node, clazz, stopAtClazzOrNode) {
  return !!findParentWithClass(node, clazz, stopAtClazzOrNode);
}
function isShadowRoot(node) {
  return node && !!node.host && !!node.mode;
}
function isInShadowDOM(domNode) {
  return !!getShadowRoot(domNode);
}
function getShadowRoot(domNode) {
  while (domNode.parentNode) {
    if (domNode === document.body) {
      return null;
    }
    domNode = domNode.parentNode;
  }
  return isShadowRoot(domNode) ? domNode : null;
}
function getActiveElement() {
  let result = document.activeElement;
  while (result === null || result === void 0 ? void 0 : result.shadowRoot) {
    result = result.shadowRoot.activeElement;
  }
  return result;
}
function createStyleSheet(container = document.getElementsByTagName("head")[0]) {
  let style = document.createElement("style");
  style.type = "text/css";
  style.media = "screen";
  container.appendChild(style);
  return style;
}
var _sharedStyleSheet = null;
function getSharedStyleSheet() {
  if (!_sharedStyleSheet) {
    _sharedStyleSheet = createStyleSheet();
  }
  return _sharedStyleSheet;
}
function createCSSRule(selector, cssText, style = getSharedStyleSheet()) {
  if (!style || !cssText) {
    return;
  }
  style.sheet.insertRule(selector + "{" + cssText + "}", 0);
}
function isHTMLElement(o) {
  if (typeof HTMLElement === "object") {
    return o instanceof HTMLElement;
  }
  return o && typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === "string";
}
var EventType = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  CONTEXT_MENU: "contextmenu",
  WHEEL: "wheel",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_PRESS: "keypress",
  KEY_UP: "keyup",
  // HTML Document
  LOAD: "load",
  BEFORE_UNLOAD: "beforeunload",
  UNLOAD: "unload",
  PAGE_SHOW: "pageshow",
  PAGE_HIDE: "pagehide",
  ABORT: "abort",
  ERROR: "error",
  RESIZE: "resize",
  SCROLL: "scroll",
  FULLSCREEN_CHANGE: "fullscreenchange",
  WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
  // Form
  SELECT: "select",
  CHANGE: "change",
  SUBMIT: "submit",
  RESET: "reset",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Local Storage
  STORAGE: "storage",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend",
  // Animation
  ANIMATION_START: isWebKit ? "webkitAnimationStart" : "animationstart",
  ANIMATION_END: isWebKit ? "webkitAnimationEnd" : "animationend",
  ANIMATION_ITERATION: isWebKit ? "webkitAnimationIteration" : "animationiteration"
};
var EventHelper = {
  stop: function(e, cancelBubble) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
    if (cancelBubble) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
  }
};
function saveParentsScrollTop(node) {
  let r = [];
  for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
    r[i] = node.scrollTop;
    node = node.parentNode;
  }
  return r;
}
function restoreParentsScrollTop(node, state) {
  for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
    if (node.scrollTop !== state[i]) {
      node.scrollTop = state[i];
    }
    node = node.parentNode;
  }
}
var FocusTracker = class _FocusTracker extends Disposable {
  constructor(element) {
    super();
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    let hasFocus = _FocusTracker.hasFocusWithin(element);
    let loosingFocus = false;
    const onFocus = () => {
      loosingFocus = false;
      if (!hasFocus) {
        hasFocus = true;
        this._onDidFocus.fire();
      }
    };
    const onBlur = () => {
      if (hasFocus) {
        loosingFocus = true;
        window.setTimeout(() => {
          if (loosingFocus) {
            loosingFocus = false;
            hasFocus = false;
            this._onDidBlur.fire();
          }
        }, 0);
      }
    };
    this._refreshStateHandler = () => {
      let currentNodeHasFocus = _FocusTracker.hasFocusWithin(element);
      if (currentNodeHasFocus !== hasFocus) {
        if (hasFocus) {
          onBlur();
        } else {
          onFocus();
        }
      }
    };
    this._register(addDisposableListener(element, EventType.FOCUS, onFocus, true));
    this._register(addDisposableListener(element, EventType.BLUR, onBlur, true));
    this._register(addDisposableListener(element, EventType.FOCUS_IN, () => this._refreshStateHandler()));
    this._register(addDisposableListener(element, EventType.FOCUS_OUT, () => this._refreshStateHandler()));
  }
  static hasFocusWithin(element) {
    const shadowRoot = getShadowRoot(element);
    const activeElement = shadowRoot ? shadowRoot.activeElement : document.activeElement;
    return isAncestor(activeElement, element);
  }
};
function trackFocus(element) {
  return new FocusTracker(element);
}
function append(parent, ...children) {
  parent.append(...children);
  if (children.length === 1 && typeof children[0] !== "string") {
    return children[0];
  }
}
function reset(parent, ...children) {
  parent.innerText = "";
  append(parent, ...children);
}
var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var Namespace;
(function(Namespace2) {
  Namespace2["HTML"] = "http://www.w3.org/1999/xhtml";
  Namespace2["SVG"] = "http://www.w3.org/2000/svg";
})(Namespace || (Namespace = {}));
function _$(namespace, description, attrs, ...children) {
  let match = SELECTOR_REGEX.exec(description);
  if (!match) {
    throw new Error("Bad use of emmet");
  }
  attrs = Object.assign({}, attrs || {});
  let tagName = match[1] || "div";
  let result;
  if (namespace !== Namespace.HTML) {
    result = document.createElementNS(namespace, tagName);
  } else {
    result = document.createElement(tagName);
  }
  if (match[3]) {
    result.id = match[3];
  }
  if (match[4]) {
    result.className = match[4].replace(/\./g, " ").trim();
  }
  Object.keys(attrs).forEach((name) => {
    const value = attrs[name];
    if (typeof value === "undefined") {
      return;
    }
    if (/^on\w+$/.test(name)) {
      result[name] = value;
    } else if (name === "selected") {
      if (value) {
        result.setAttribute(name, "true");
      }
    } else {
      result.setAttribute(name, value);
    }
  });
  result.append(...children);
  return result;
}
function $(description, attrs, ...children) {
  return _$(Namespace.HTML, description, attrs, ...children);
}
$.SVG = function(description, attrs, ...children) {
  return _$(Namespace.SVG, description, attrs, ...children);
};
function show(...elements) {
  for (let element of elements) {
    element.style.display = "";
    element.removeAttribute("aria-hidden");
  }
}
function hide(...elements) {
  for (let element of elements) {
    element.style.display = "none";
    element.setAttribute("aria-hidden", "true");
  }
}
function getElementsByTagName(tag) {
  return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);
}
function computeScreenAwareSize(cssPx) {
  const screenPx = window.devicePixelRatio * cssPx;
  return Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;
}
function windowOpenNoOpener(url) {
  window.open(url, "_blank", "noopener");
}
function animate(fn) {
  const step = () => {
    fn();
    stepDisposable = scheduleAtNextAnimationFrame(step);
  };
  let stepDisposable = scheduleAtNextAnimationFrame(step);
  return toDisposable(() => stepDisposable.dispose());
}
RemoteAuthorities.setPreferredWebSchema(/^https:/.test(window.location.href) ? "https" : "http");
function asCSSUrl(uri) {
  if (!uri) {
    return `url('')`;
  }
  return `url('${FileAccess.asBrowserUri(uri).toString(true).replace(/'/g, "%27")}')`;
}
function asCSSPropertyValue(value) {
  return `'${value.replace(/'/g, "%27")}'`;
}
var ModifierKeyEmitter = class _ModifierKeyEmitter extends Emitter {
  constructor() {
    super();
    this._subscriptions = new DisposableStore();
    this._keyStatus = {
      altKey: false,
      shiftKey: false,
      ctrlKey: false,
      metaKey: false
    };
    this._subscriptions.add(addDisposableListener(window, "keydown", (e) => {
      if (e.defaultPrevented) {
        return;
      }
      const event = new StandardKeyboardEvent(e);
      if (event.keyCode === 6 && e.repeat) {
        return;
      }
      if (e.altKey && !this._keyStatus.altKey) {
        this._keyStatus.lastKeyPressed = "alt";
      } else if (e.ctrlKey && !this._keyStatus.ctrlKey) {
        this._keyStatus.lastKeyPressed = "ctrl";
      } else if (e.metaKey && !this._keyStatus.metaKey) {
        this._keyStatus.lastKeyPressed = "meta";
      } else if (e.shiftKey && !this._keyStatus.shiftKey) {
        this._keyStatus.lastKeyPressed = "shift";
      } else if (event.keyCode !== 6) {
        this._keyStatus.lastKeyPressed = void 0;
      } else {
        return;
      }
      this._keyStatus.altKey = e.altKey;
      this._keyStatus.ctrlKey = e.ctrlKey;
      this._keyStatus.metaKey = e.metaKey;
      this._keyStatus.shiftKey = e.shiftKey;
      if (this._keyStatus.lastKeyPressed) {
        this._keyStatus.event = e;
        this.fire(this._keyStatus);
      }
    }, true));
    this._subscriptions.add(addDisposableListener(window, "keyup", (e) => {
      if (e.defaultPrevented) {
        return;
      }
      if (!e.altKey && this._keyStatus.altKey) {
        this._keyStatus.lastKeyReleased = "alt";
      } else if (!e.ctrlKey && this._keyStatus.ctrlKey) {
        this._keyStatus.lastKeyReleased = "ctrl";
      } else if (!e.metaKey && this._keyStatus.metaKey) {
        this._keyStatus.lastKeyReleased = "meta";
      } else if (!e.shiftKey && this._keyStatus.shiftKey) {
        this._keyStatus.lastKeyReleased = "shift";
      } else {
        this._keyStatus.lastKeyReleased = void 0;
      }
      if (this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased) {
        this._keyStatus.lastKeyPressed = void 0;
      }
      this._keyStatus.altKey = e.altKey;
      this._keyStatus.ctrlKey = e.ctrlKey;
      this._keyStatus.metaKey = e.metaKey;
      this._keyStatus.shiftKey = e.shiftKey;
      if (this._keyStatus.lastKeyReleased) {
        this._keyStatus.event = e;
        this.fire(this._keyStatus);
      }
    }, true));
    this._subscriptions.add(addDisposableListener(document.body, "mousedown", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, true));
    this._subscriptions.add(addDisposableListener(document.body, "mouseup", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, true));
    this._subscriptions.add(addDisposableListener(document.body, "mousemove", (e) => {
      if (e.buttons) {
        this._keyStatus.lastKeyPressed = void 0;
      }
    }, true));
    this._subscriptions.add(addDisposableListener(window, "blur", () => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus();
    this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: false,
      shiftKey: false,
      ctrlKey: false,
      metaKey: false
    };
  }
  static getInstance() {
    if (!_ModifierKeyEmitter.instance) {
      _ModifierKeyEmitter.instance = new _ModifierKeyEmitter();
    }
    return _ModifierKeyEmitter.instance;
  }
  dispose() {
    super.dispose();
    this._subscriptions.dispose();
  }
};
function addMatchMediaChangeListener(query, callback) {
  const mediaQueryList = window.matchMedia(query);
  mediaQueryList.addEventListener("change", callback);
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js
import "/home/ubuntu/project/s/front2.0/node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.css";
var MAX_MESSAGE_LENGTH = 2e4;
var ariaContainer;
var alertContainer;
var alertContainer2;
var statusContainer;
var statusContainer2;
function setARIAContainer(parent) {
  ariaContainer = document.createElement("div");
  ariaContainer.className = "monaco-aria-container";
  const createAlertContainer = () => {
    const element = document.createElement("div");
    element.className = "monaco-alert";
    element.setAttribute("role", "alert");
    element.setAttribute("aria-atomic", "true");
    ariaContainer.appendChild(element);
    return element;
  };
  alertContainer = createAlertContainer();
  alertContainer2 = createAlertContainer();
  const createStatusContainer = () => {
    const element = document.createElement("div");
    element.className = "monaco-status";
    element.setAttribute("role", "complementary");
    element.setAttribute("aria-live", "polite");
    element.setAttribute("aria-atomic", "true");
    ariaContainer.appendChild(element);
    return element;
  };
  statusContainer = createStatusContainer();
  statusContainer2 = createStatusContainer();
  parent.appendChild(ariaContainer);
}
function alert(msg) {
  if (!ariaContainer) {
    return;
  }
  if (alertContainer.textContent !== msg) {
    clearNode(alertContainer2);
    insertMessage(alertContainer, msg);
  } else {
    clearNode(alertContainer);
    insertMessage(alertContainer2, msg);
  }
}
function status(msg) {
  if (!ariaContainer) {
    return;
  }
  if (isMacintosh) {
    alert(msg);
  } else {
    if (statusContainer.textContent !== msg) {
      clearNode(statusContainer2);
      insertMessage(statusContainer, msg);
    } else {
      clearNode(statusContainer);
      insertMessage(statusContainer2, msg);
    }
  }
}
function insertMessage(target, msg) {
  clearNode(target);
  if (msg.length > MAX_MESSAGE_LENGTH) {
    msg = msg.substr(0, MAX_MESSAGE_LENGTH);
  }
  target.textContent = msg;
  target.style.visibility = "hidden";
  target.style.visibility = "visible";
}

// node_modules/monaco-editor/esm/vs/base/common/color.js
function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}
var RGBA = class {
  constructor(r, g, b, a = 1) {
    this._rgbaBrand = void 0;
    this.r = Math.min(255, Math.max(0, r)) | 0;
    this.g = Math.min(255, Math.max(0, g)) | 0;
    this.b = Math.min(255, Math.max(0, b)) | 0;
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }
  static equals(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
  }
};
var HSLA = class _HSLA {
  constructor(h, s, l, a) {
    this._hslaBrand = void 0;
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }
  static equals(a, b) {
    return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const a = rgba.a;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (min + max) / 2;
    const chroma = max - min;
    if (chroma > 0) {
      s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
      switch (max) {
        case r:
          h = (g - b) / chroma + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / chroma + 2;
          break;
        case b:
          h = (r - g) / chroma + 4;
          break;
      }
      h *= 60;
      h = Math.round(h);
    }
    return new _HSLA(h, s, l, a);
  }
  static _hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(hsla) {
    const h = hsla.h / 360;
    const { s, l, a } = hsla;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = _HSLA._hue2rgb(p, q, h + 1 / 3);
      g = _HSLA._hue2rgb(p, q, h);
      b = _HSLA._hue2rgb(p, q, h - 1 / 3);
    }
    return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
  }
};
var HSVA = class _HSVA {
  constructor(h, s, v, a) {
    this._hsvaBrand = void 0;
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }
  static equals(a, b) {
    return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const cmax = Math.max(r, g, b);
    const cmin = Math.min(r, g, b);
    const delta = cmax - cmin;
    const s = cmax === 0 ? 0 : delta / cmax;
    let m;
    if (delta === 0) {
      m = 0;
    } else if (cmax === r) {
      m = ((g - b) / delta % 6 + 6) % 6;
    } else if (cmax === g) {
      m = (b - r) / delta + 2;
    } else {
      m = (r - g) / delta + 4;
    }
    return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(hsva) {
    const { h, s, v, a } = hsva;
    const c = v * s;
    const x = c * (1 - Math.abs(h / 60 % 2 - 1));
    const m = v - c;
    let [r, g, b] = [0, 0, 0];
    if (h < 60) {
      r = c;
      g = x;
    } else if (h < 120) {
      r = x;
      g = c;
    } else if (h < 180) {
      g = c;
      b = x;
    } else if (h < 240) {
      g = x;
      b = c;
    } else if (h < 300) {
      r = x;
      b = c;
    } else if (h <= 360) {
      r = c;
      b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return new RGBA(r, g, b, a);
  }
};
var Color = class _Color {
  constructor(arg) {
    if (!arg) {
      throw new Error("Color needs a value");
    } else if (arg instanceof RGBA) {
      this.rgba = arg;
    } else if (arg instanceof HSLA) {
      this._hsla = arg;
      this.rgba = HSLA.toRGBA(arg);
    } else if (arg instanceof HSVA) {
      this._hsva = arg;
      this.rgba = HSVA.toRGBA(arg);
    } else {
      throw new Error("Invalid color ctor argument");
    }
  }
  static fromHex(hex) {
    return _Color.Format.CSS.parseHex(hex) || _Color.red;
  }
  get hsla() {
    if (this._hsla) {
      return this._hsla;
    } else {
      return HSLA.fromRGBA(this.rgba);
    }
  }
  get hsva() {
    if (this._hsva) {
      return this._hsva;
    }
    return HSVA.fromRGBA(this.rgba);
  }
  equals(other) {
    return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const R = _Color._relativeLuminanceForComponent(this.rgba.r);
    const G = _Color._relativeLuminanceForComponent(this.rgba.g);
    const B = _Color._relativeLuminanceForComponent(this.rgba.b);
    const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    return roundFloat(luminance, 4);
  }
  static _relativeLuminanceForComponent(color) {
    const c = color / 255;
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
    return yiq >= 128;
  }
  isLighterThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 > lum2;
  }
  isDarkerThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 < lum2;
  }
  lighten(factor2) {
    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor2, this.hsla.a));
  }
  darken(factor2) {
    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor2, this.hsla.a));
  }
  transparent(factor2) {
    const { r, g, b, a } = this.rgba;
    return new _Color(new RGBA(r, g, b, a * factor2));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  toString() {
    if (!this._toString) {
      this._toString = _Color.Format.CSS.format(this);
    }
    return this._toString;
  }
  static getLighterColor(of, relative2, factor2) {
    if (of.isLighterThan(relative2)) {
      return of;
    }
    factor2 = factor2 ? factor2 : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative2.getRelativeLuminance();
    factor2 = factor2 * (lum2 - lum1) / lum2;
    return of.lighten(factor2);
  }
  static getDarkerColor(of, relative2, factor2) {
    if (of.isDarkerThan(relative2)) {
      return of;
    }
    factor2 = factor2 ? factor2 : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative2.getRelativeLuminance();
    factor2 = factor2 * (lum1 - lum2) / lum1;
    return of.darken(factor2);
  }
};
Color.white = new Color(new RGBA(255, 255, 255, 1));
Color.black = new Color(new RGBA(0, 0, 0, 1));
Color.red = new Color(new RGBA(255, 0, 0, 1));
Color.blue = new Color(new RGBA(0, 0, 255, 1));
Color.green = new Color(new RGBA(0, 255, 0, 1));
Color.cyan = new Color(new RGBA(0, 255, 255, 1));
Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
Color.transparent = new Color(new RGBA(0, 0, 0, 0));
(function(Color2) {
  let Format;
  (function(Format2) {
    let CSS;
    (function(CSS2) {
      function formatRGB(color) {
        if (color.rgba.a === 1) {
          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
        }
        return Color2.Format.CSS.formatRGBA(color);
      }
      CSS2.formatRGB = formatRGB;
      function formatRGBA(color) {
        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
      }
      CSS2.formatRGBA = formatRGBA;
      function formatHSL(color) {
        if (color.hsla.a === 1) {
          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
        }
        return Color2.Format.CSS.formatHSLA(color);
      }
      CSS2.formatHSL = formatHSL;
      function formatHSLA(color) {
        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
      }
      CSS2.formatHSLA = formatHSLA;
      function _toTwoDigitHex(n) {
        const r = n.toString(16);
        return r.length !== 2 ? "0" + r : r;
      }
      function formatHex(color) {
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
      }
      CSS2.formatHex = formatHex;
      function formatHexA(color, compact = false) {
        if (compact && color.rgba.a === 1) {
          return Color2.Format.CSS.formatHex(color);
        }
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
      }
      CSS2.formatHexA = formatHexA;
      function format2(color) {
        if (color.isOpaque()) {
          return Color2.Format.CSS.formatHex(color);
        }
        return Color2.Format.CSS.formatRGBA(color);
      }
      CSS2.format = format2;
      function parseHex(hex) {
        const length = hex.length;
        if (length === 0) {
          return null;
        }
        if (hex.charCodeAt(0) !== 35) {
          return null;
        }
        if (length === 7) {
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          return new Color2(new RGBA(r, g, b, 1));
        }
        if (length === 9) {
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
          return new Color2(new RGBA(r, g, b, a / 255));
        }
        if (length === 4) {
          const r = _parseHexDigit(hex.charCodeAt(1));
          const g = _parseHexDigit(hex.charCodeAt(2));
          const b = _parseHexDigit(hex.charCodeAt(3));
          return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
        }
        if (length === 5) {
          const r = _parseHexDigit(hex.charCodeAt(1));
          const g = _parseHexDigit(hex.charCodeAt(2));
          const b = _parseHexDigit(hex.charCodeAt(3));
          const a = _parseHexDigit(hex.charCodeAt(4));
          return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
        }
        return null;
      }
      CSS2.parseHex = parseHex;
      function _parseHexDigit(charCode) {
        switch (charCode) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(CSS = Format2.CSS || (Format2.CSS = {}));
  })(Format = Color2.Format || (Color2.Format = {}));
})(Color || (Color = {}));

// node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js
var Extensions4 = {
  JSONContribution: "base.contributions.json"
};
function normalizeId(id) {
  if (id.length > 0 && id.charAt(id.length - 1) === "#") {
    return id.substring(0, id.length - 1);
  }
  return id;
}
var JSONContributionRegistry = class {
  constructor() {
    this._onDidChangeSchema = new Emitter();
    this.schemasById = {};
  }
  registerSchema(uri, unresolvedSchemaContent) {
    this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
    this._onDidChangeSchema.fire(uri);
  }
  notifySchemaChanged(uri) {
    this._onDidChangeSchema.fire(uri);
  }
};
var jsonContributionRegistry = new JSONContributionRegistry();
Registry.add(Extensions4.JSONContribution, jsonContributionRegistry);

// node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js
function asCssVariableName(colorIdent) {
  return `--vscode-${colorIdent.replace(/\./g, "-")}`;
}
var Extensions5 = {
  ColorContribution: "base.contributions.colors"
};
var ColorRegistry = class {
  constructor() {
    this._onDidChangeSchema = new Emitter();
    this.onDidChangeSchema = this._onDidChangeSchema.event;
    this.colorSchema = { type: "object", properties: {} };
    this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] };
    this.colorsById = {};
  }
  registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {
    let colorContribution = { id, description, defaults, needsTransparency, deprecationMessage };
    this.colorsById[id] = colorContribution;
    let propertySchema = { type: "string", description, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    if (deprecationMessage) {
      propertySchema.deprecationMessage = deprecationMessage;
    }
    this.colorSchema.properties[id] = propertySchema;
    this.colorReferenceSchema.enum.push(id);
    this.colorReferenceSchema.enumDescriptions.push(description);
    this._onDidChangeSchema.fire();
    return id;
  }
  getColors() {
    return Object.keys(this.colorsById).map((id) => this.colorsById[id]);
  }
  resolveDefaultColor(id, theme) {
    const colorDesc = this.colorsById[id];
    if (colorDesc && colorDesc.defaults) {
      const colorValue = colorDesc.defaults[theme.type];
      return resolveColorValue(colorValue, theme);
    }
    return void 0;
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    let sorter2 = (a, b) => {
      let cat1 = a.indexOf(".") === -1 ? 0 : 1;
      let cat2 = b.indexOf(".") === -1 ? 0 : 1;
      if (cat1 !== cat2) {
        return cat1 - cat2;
      }
      return a.localeCompare(b);
    };
    return Object.keys(this.colorsById).sort(sorter2).map((k) => `- \`${k}\`: ${this.colorsById[k].description}`).join("\n");
  }
};
var colorRegistry = new ColorRegistry();
Registry.add(Extensions5.ColorContribution, colorRegistry);
function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {
  return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);
}
var foreground = registerColor("foreground", { dark: "#CCCCCC", light: "#616161", hc: "#FFFFFF" }, localize("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
var errorForeground = registerColor("errorForeground", { dark: "#F48771", light: "#A1260D", hc: "#F48771" }, localize("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
var descriptionForeground = registerColor("descriptionForeground", { light: "#717171", dark: transparent(foreground, 0.7), hc: transparent(foreground, 0.7) }, localize("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
var iconForeground = registerColor("icon.foreground", { dark: "#C5C5C5", light: "#424242", hc: "#FFFFFF" }, localize("iconForeground", "The default color for icons in the workbench."));
var focusBorder = registerColor("focusBorder", { dark: "#007FD4", light: "#0090F1", hc: "#F38518" }, localize("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component."));
var contrastBorder = registerColor("contrastBorder", { light: null, dark: null, hc: "#6FC3DF" }, localize("contrastBorder", "An extra border around elements to separate them from others for greater contrast."));
var activeContrastBorder = registerColor("contrastActiveBorder", { light: null, dark: null, hc: focusBorder }, localize("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
var selectionBackground = registerColor("selection.background", { light: null, dark: null, hc: null }, localize("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
var textSeparatorForeground = registerColor("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hc: Color.black }, localize("textSeparatorForeground", "Color for text separators."));
var textLinkForeground = registerColor("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hc: "#3794FF" }, localize("textLinkForeground", "Foreground color for links in text."));
var textLinkActiveForeground = registerColor("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hc: "#3794FF" }, localize("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
var textPreformatForeground = registerColor("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hc: "#D7BA7D" }, localize("textPreformatForeground", "Foreground color for preformatted text segments."));
var textBlockQuoteBackground = registerColor("textBlockQuote.background", { light: "#7f7f7f1a", dark: "#7f7f7f1a", hc: null }, localize("textBlockQuoteBackground", "Background color for block quotes in text."));
var textBlockQuoteBorder = registerColor("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hc: Color.white }, localize("textBlockQuoteBorder", "Border color for block quotes in text."));
var textCodeBlockBackground = registerColor("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hc: Color.black }, localize("textCodeBlockBackground", "Background color for code blocks in text."));
var widgetShadow = registerColor("widget.shadow", { dark: transparent(Color.black, 0.36), light: transparent(Color.black, 0.16), hc: null }, localize("widgetShadow", "Shadow color of widgets such as find/replace inside the editor."));
var inputBackground = registerColor("input.background", { dark: "#3C3C3C", light: Color.white, hc: Color.black }, localize("inputBoxBackground", "Input box background."));
var inputForeground = registerColor("input.foreground", { dark: foreground, light: foreground, hc: foreground }, localize("inputBoxForeground", "Input box foreground."));
var inputBorder = registerColor("input.border", { dark: null, light: null, hc: contrastBorder }, localize("inputBoxBorder", "Input box border."));
var inputActiveOptionBorder = registerColor("inputOption.activeBorder", { dark: "#007ACC00", light: "#007ACC00", hc: contrastBorder }, localize("inputBoxActiveOptionBorder", "Border color of activated options in input fields."));
var inputActiveOptionHoverBackground = registerColor("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hc: null }, localize("inputOption.hoverBackground", "Background color of activated options in input fields."));
var inputActiveOptionBackground = registerColor("inputOption.activeBackground", { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hc: Color.transparent }, localize("inputOption.activeBackground", "Background hover color of options in input fields."));
var inputActiveOptionForeground = registerColor("inputOption.activeForeground", { dark: Color.white, light: Color.black, hc: null }, localize("inputOption.activeForeground", "Foreground color of activated options in input fields."));
var inputPlaceholderForeground = registerColor("input.placeholderForeground", { light: transparent(foreground, 0.5), dark: transparent(foreground, 0.5), hc: transparent(foreground, 0.7) }, localize("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
var inputValidationInfoBackground = registerColor("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hc: Color.black }, localize("inputValidationInfoBackground", "Input validation background color for information severity."));
var inputValidationInfoForeground = registerColor("inputValidation.infoForeground", { dark: null, light: null, hc: null }, localize("inputValidationInfoForeground", "Input validation foreground color for information severity."));
var inputValidationInfoBorder = registerColor("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hc: contrastBorder }, localize("inputValidationInfoBorder", "Input validation border color for information severity."));
var inputValidationWarningBackground = registerColor("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hc: Color.black }, localize("inputValidationWarningBackground", "Input validation background color for warning severity."));
var inputValidationWarningForeground = registerColor("inputValidation.warningForeground", { dark: null, light: null, hc: null }, localize("inputValidationWarningForeground", "Input validation foreground color for warning severity."));
var inputValidationWarningBorder = registerColor("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hc: contrastBorder }, localize("inputValidationWarningBorder", "Input validation border color for warning severity."));
var inputValidationErrorBackground = registerColor("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hc: Color.black }, localize("inputValidationErrorBackground", "Input validation background color for error severity."));
var inputValidationErrorForeground = registerColor("inputValidation.errorForeground", { dark: null, light: null, hc: null }, localize("inputValidationErrorForeground", "Input validation foreground color for error severity."));
var inputValidationErrorBorder = registerColor("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hc: contrastBorder }, localize("inputValidationErrorBorder", "Input validation border color for error severity."));
var selectBackground = registerColor("dropdown.background", { dark: "#3C3C3C", light: Color.white, hc: Color.black }, localize("dropdownBackground", "Dropdown background."));
var selectListBackground = registerColor("dropdown.listBackground", { dark: null, light: null, hc: Color.black }, localize("dropdownListBackground", "Dropdown list background."));
var selectForeground = registerColor("dropdown.foreground", { dark: "#F0F0F0", light: null, hc: Color.white }, localize("dropdownForeground", "Dropdown foreground."));
var selectBorder = registerColor("dropdown.border", { dark: selectBackground, light: "#CECECE", hc: contrastBorder }, localize("dropdownBorder", "Dropdown border."));
var simpleCheckboxBackground = registerColor("checkbox.background", { dark: selectBackground, light: selectBackground, hc: selectBackground }, localize("checkbox.background", "Background color of checkbox widget."));
var simpleCheckboxForeground = registerColor("checkbox.foreground", { dark: selectForeground, light: selectForeground, hc: selectForeground }, localize("checkbox.foreground", "Foreground color of checkbox widget."));
var simpleCheckboxBorder = registerColor("checkbox.border", { dark: selectBorder, light: selectBorder, hc: selectBorder }, localize("checkbox.border", "Border color of checkbox widget."));
var buttonForeground = registerColor("button.foreground", { dark: Color.white, light: Color.white, hc: Color.white }, localize("buttonForeground", "Button foreground color."));
var buttonBackground = registerColor("button.background", { dark: "#0E639C", light: "#007ACC", hc: null }, localize("buttonBackground", "Button background color."));
var buttonHoverBackground = registerColor("button.hoverBackground", { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hc: null }, localize("buttonHoverBackground", "Button background color when hovering."));
var buttonBorder = registerColor("button.border", { dark: contrastBorder, light: contrastBorder, hc: contrastBorder }, localize("buttonBorder", "Button border color."));
var buttonSecondaryForeground = registerColor("button.secondaryForeground", { dark: Color.white, light: Color.white, hc: Color.white }, localize("buttonSecondaryForeground", "Secondary button foreground color."));
var buttonSecondaryBackground = registerColor("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hc: null }, localize("buttonSecondaryBackground", "Secondary button background color."));
var buttonSecondaryHoverBackground = registerColor("button.secondaryHoverBackground", { dark: lighten(buttonSecondaryBackground, 0.2), light: darken(buttonSecondaryBackground, 0.2), hc: null }, localize("buttonSecondaryHoverBackground", "Secondary button background color when hovering."));
var badgeBackground = registerColor("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hc: Color.black }, localize("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count."));
var badgeForeground = registerColor("badge.foreground", { dark: Color.white, light: "#333", hc: Color.white }, localize("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count."));
var scrollbarShadow = registerColor("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hc: null }, localize("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled."));
var scrollbarSliderBackground = registerColor("scrollbarSlider.background", { dark: Color.fromHex("#797979").transparent(0.4), light: Color.fromHex("#646464").transparent(0.4), hc: transparent(contrastBorder, 0.6) }, localize("scrollbarSliderBackground", "Scrollbar slider background color."));
var scrollbarSliderHoverBackground = registerColor("scrollbarSlider.hoverBackground", { dark: Color.fromHex("#646464").transparent(0.7), light: Color.fromHex("#646464").transparent(0.7), hc: transparent(contrastBorder, 0.8) }, localize("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering."));
var scrollbarSliderActiveBackground = registerColor("scrollbarSlider.activeBackground", { dark: Color.fromHex("#BFBFBF").transparent(0.4), light: Color.fromHex("#000000").transparent(0.6), hc: contrastBorder }, localize("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on."));
var progressBarBackground = registerColor("progressBar.background", { dark: Color.fromHex("#0E70C0"), light: Color.fromHex("#0E70C0"), hc: contrastBorder }, localize("progressBarBackground", "Background color of the progress bar that can show for long running operations."));
var editorErrorBackground = registerColor("editorError.background", { dark: null, light: null, hc: null }, localize("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
var editorErrorForeground = registerColor("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hc: null }, localize("editorError.foreground", "Foreground color of error squigglies in the editor."));
var editorErrorBorder = registerColor("editorError.border", { dark: null, light: null, hc: Color.fromHex("#E47777").transparent(0.8) }, localize("errorBorder", "Border color of error boxes in the editor."));
var editorWarningBackground = registerColor("editorWarning.background", { dark: null, light: null, hc: null }, localize("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWarningForeground = registerColor("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hc: null }, localize("editorWarning.foreground", "Foreground color of warning squigglies in the editor."));
var editorWarningBorder = registerColor("editorWarning.border", { dark: null, light: null, hc: Color.fromHex("#FFCC00").transparent(0.8) }, localize("warningBorder", "Border color of warning boxes in the editor."));
var editorInfoBackground = registerColor("editorInfo.background", { dark: null, light: null, hc: null }, localize("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
var editorInfoForeground = registerColor("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hc: "#3794FF" }, localize("editorInfo.foreground", "Foreground color of info squigglies in the editor."));
var editorInfoBorder = registerColor("editorInfo.border", { dark: null, light: null, hc: Color.fromHex("#3794FF").transparent(0.8) }, localize("infoBorder", "Border color of info boxes in the editor."));
var editorHintForeground = registerColor("editorHint.foreground", { dark: Color.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hc: null }, localize("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
var editorHintBorder = registerColor("editorHint.border", { dark: null, light: null, hc: Color.fromHex("#eeeeee").transparent(0.8) }, localize("hintBorder", "Border color of hint boxes in the editor."));
var sashHoverBorder = registerColor("sash.hoverBorder", { dark: focusBorder, light: focusBorder, hc: focusBorder }, localize("sashActiveBorder", "Border color of active sashes."));
var editorBackground = registerColor("editor.background", { light: "#fffffe", dark: "#1E1E1E", hc: Color.black }, localize("editorBackground", "Editor background color."));
var editorForeground = registerColor("editor.foreground", { light: "#333333", dark: "#BBBBBB", hc: Color.white }, localize("editorForeground", "Editor default foreground color."));
var editorWidgetBackground = registerColor("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hc: "#0C141F" }, localize("editorWidgetBackground", "Background color of editor widgets, such as find/replace."));
var editorWidgetForeground = registerColor("editorWidget.foreground", { dark: foreground, light: foreground, hc: foreground }, localize("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace."));
var editorWidgetBorder = registerColor("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hc: contrastBorder }, localize("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
var editorWidgetResizeBorder = registerColor("editorWidget.resizeBorder", { light: null, dark: null, hc: null }, localize("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
var quickInputBackground = registerColor("quickInput.background", { dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground }, localize("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette."));
var quickInputForeground = registerColor("quickInput.foreground", { dark: editorWidgetForeground, light: editorWidgetForeground, hc: editorWidgetForeground }, localize("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette."));
var quickInputTitleBackground = registerColor("quickInputTitle.background", { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hc: "#000000" }, localize("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette."));
var pickerGroupForeground = registerColor("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hc: Color.white }, localize("pickerGroupForeground", "Quick picker color for grouping labels."));
var pickerGroupBorder = registerColor("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hc: Color.white }, localize("pickerGroupBorder", "Quick picker color for grouping borders."));
var keybindingLabelBackground = registerColor("keybindingLabel.background", { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hc: Color.transparent }, localize("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut."));
var keybindingLabelForeground = registerColor("keybindingLabel.foreground", { dark: Color.fromHex("#CCCCCC"), light: Color.fromHex("#555555"), hc: Color.white }, localize("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut."));
var keybindingLabelBorder = registerColor("keybindingLabel.border", { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hc: new Color(new RGBA(111, 195, 223)) }, localize("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut."));
var keybindingLabelBottomBorder = registerColor("keybindingLabel.bottomBorder", { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hc: new Color(new RGBA(111, 195, 223)) }, localize("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut."));
var editorSelectionBackground = registerColor("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hc: "#f3f518" }, localize("editorSelectionBackground", "Color of the editor selection."));
var editorSelectionForeground = registerColor("editor.selectionForeground", { light: null, dark: null, hc: "#000000" }, localize("editorSelectionForeground", "Color of the selected text for high contrast."));
var editorInactiveSelection = registerColor("editor.inactiveSelectionBackground", { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hc: transparent(editorSelectionBackground, 0.5) }, localize("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), true);
var editorSelectionHighlight = registerColor("editor.selectionHighlightBackground", { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hc: null }, localize("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), true);
var editorSelectionHighlightBorder = registerColor("editor.selectionHighlightBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
var editorFindMatch = registerColor("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hc: null }, localize("editorFindMatch", "Color of the current search match."));
var editorFindMatchHighlight = registerColor("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hc: null }, localize("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), true);
var editorFindRangeHighlight = registerColor("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hc: null }, localize("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
var editorFindMatchBorder = registerColor("editor.findMatchBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("editorFindMatchBorder", "Border color of the current search match."));
var editorFindMatchHighlightBorder = registerColor("editor.findMatchHighlightBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("findMatchHighlightBorder", "Border color of the other search matches."));
var editorFindRangeHighlightBorder = registerColor("editor.findRangeHighlightBorder", { dark: null, light: null, hc: transparent(activeContrastBorder, 0.4) }, localize("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
var searchEditorFindMatch = registerColor("searchEditor.findMatchBackground", { light: transparent(editorFindMatchHighlight, 0.66), dark: transparent(editorFindMatchHighlight, 0.66), hc: editorFindMatchHighlight }, localize("searchEditor.queryMatch", "Color of the Search Editor query matches."));
var searchEditorFindMatchBorder = registerColor("searchEditor.findMatchBorder", { light: transparent(editorFindMatchHighlightBorder, 0.66), dark: transparent(editorFindMatchHighlightBorder, 0.66), hc: editorFindMatchHighlightBorder }, localize("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
var editorHoverHighlight = registerColor("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hc: "#ADD6FF26" }, localize("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), true);
var editorHoverBackground = registerColor("editorHoverWidget.background", { light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground }, localize("hoverBackground", "Background color of the editor hover."));
var editorHoverForeground = registerColor("editorHoverWidget.foreground", { light: editorWidgetForeground, dark: editorWidgetForeground, hc: editorWidgetForeground }, localize("hoverForeground", "Foreground color of the editor hover."));
var editorHoverBorder = registerColor("editorHoverWidget.border", { light: editorWidgetBorder, dark: editorWidgetBorder, hc: editorWidgetBorder }, localize("hoverBorder", "Border color of the editor hover."));
var editorHoverStatusBarBackground = registerColor("editorHoverWidget.statusBarBackground", { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hc: editorWidgetBackground }, localize("statusBarBackground", "Background color of the editor hover status bar."));
var editorActiveLinkForeground = registerColor("editorLink.activeForeground", { dark: "#4E94CE", light: Color.blue, hc: Color.cyan }, localize("activeLinkForeground", "Color of active links."));
var editorInlayHintForeground = registerColor("editorInlayHint.foreground", { dark: transparent(badgeForeground, 0.8), light: transparent(badgeForeground, 0.8), hc: badgeForeground }, localize("editorInlayHintForeground", "Foreground color of inline hints"));
var editorInlayHintBackground = registerColor("editorInlayHint.background", { dark: transparent(badgeBackground, 0.6), light: transparent(badgeBackground, 0.3), hc: badgeBackground }, localize("editorInlayHintBackground", "Background color of inline hints"));
var editorInlayHintTypeForeground = registerColor("editorInlayHint.typeForeground", { dark: editorInlayHintForeground, light: editorInlayHintForeground, hc: editorInlayHintForeground }, localize("editorInlayHintForegroundTypes", "Foreground color of inline hints for types"));
var editorInlayHintTypeBackground = registerColor("editorInlayHint.typeBackground", { dark: editorInlayHintBackground, light: editorInlayHintBackground, hc: editorInlayHintBackground }, localize("editorInlayHintBackgroundTypes", "Background color of inline hints for types"));
var editorInlayHintParameterForeground = registerColor("editorInlayHint.parameterForeground", { dark: editorInlayHintForeground, light: editorInlayHintForeground, hc: editorInlayHintForeground }, localize("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters"));
var editorInlayHintParameterBackground = registerColor("editorInlayHint.parameterBackground", { dark: editorInlayHintBackground, light: editorInlayHintBackground, hc: editorInlayHintBackground }, localize("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters"));
var editorLightBulbForeground = registerColor("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hc: "#FFCC00" }, localize("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
var editorLightBulbAutoFixForeground = registerColor("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hc: "#75BEFF" }, localize("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
var defaultInsertColor = new Color(new RGBA(155, 185, 85, 0.2));
var defaultRemoveColor = new Color(new RGBA(255, 0, 0, 0.2));
var diffInserted = registerColor("diffEditor.insertedTextBackground", { dark: defaultInsertColor, light: defaultInsertColor, hc: null }, localize("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), true);
var diffRemoved = registerColor("diffEditor.removedTextBackground", { dark: defaultRemoveColor, light: defaultRemoveColor, hc: null }, localize("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
var diffInsertedLine = registerColor("diffEditor.insertedLineBackground", { dark: null, light: null, hc: null }, localize("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), true);
var diffRemovedLine = registerColor("diffEditor.removedLineBackground", { dark: null, light: null, hc: null }, localize("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
var diffInsertedLineGutter = registerColor("diffEditorGutter.insertedLineBackground", { dark: null, light: null, hc: null }, localize("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
var diffRemovedLineGutter = registerColor("diffEditorGutter.removedLineBackground", { dark: null, light: null, hc: null }, localize("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
var diffOverviewRulerInserted = registerColor("diffEditorOverview.insertedForeground", { dark: null, light: null, hc: null }, localize("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content."));
var diffOverviewRulerRemoved = registerColor("diffEditorOverview.removedForeground", { dark: null, light: null, hc: null }, localize("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
var diffInsertedOutline = registerColor("diffEditor.insertedTextBorder", { dark: null, light: null, hc: "#33ff2eff" }, localize("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
var diffRemovedOutline = registerColor("diffEditor.removedTextBorder", { dark: null, light: null, hc: "#FF008F" }, localize("diffEditorRemovedOutline", "Outline color for text that got removed."));
var diffBorder = registerColor("diffEditor.border", { dark: null, light: null, hc: contrastBorder }, localize("diffEditorBorder", "Border color between the two text editors."));
var diffDiagonalFill = registerColor("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hc: null }, localize("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
var listFocusBackground = registerColor("list.focusBackground", { dark: null, light: null, hc: null }, localize("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listFocusForeground = registerColor("list.focusForeground", { dark: null, light: null, hc: null }, localize("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listFocusOutline = registerColor("list.focusOutline", { dark: focusBorder, light: focusBorder, hc: activeContrastBorder }, localize("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionBackground = registerColor("list.activeSelectionBackground", { dark: "#094771", light: "#0060C0", hc: null }, localize("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionForeground = registerColor("list.activeSelectionForeground", { dark: Color.white, light: Color.white, hc: null }, localize("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listActiveSelectionIconForeground = registerColor("list.activeSelectionIconForeground", { dark: null, light: null, hc: null }, localize("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionBackground = registerColor("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hc: null }, localize("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionForeground = registerColor("list.inactiveSelectionForeground", { dark: null, light: null, hc: null }, localize("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveSelectionIconForeground = registerColor("list.inactiveSelectionIconForeground", { dark: null, light: null, hc: null }, localize("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveFocusBackground = registerColor("list.inactiveFocusBackground", { dark: null, light: null, hc: null }, localize("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listInactiveFocusOutline = registerColor("list.inactiveFocusOutline", { dark: null, light: null, hc: null }, localize("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
var listHoverBackground = registerColor("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hc: null }, localize("listHoverBackground", "List/Tree background when hovering over items using the mouse."));
var listHoverForeground = registerColor("list.hoverForeground", { dark: null, light: null, hc: null }, localize("listHoverForeground", "List/Tree foreground when hovering over items using the mouse."));
var listDropBackground = registerColor("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hc: null }, localize("listDropBackground", "List/Tree drag and drop background when moving items around using the mouse."));
var listHighlightForeground = registerColor("list.highlightForeground", { dark: "#18A3FF", light: "#0066BF", hc: focusBorder }, localize("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
var listFocusHighlightForeground = registerColor("list.focusHighlightForeground", { dark: listHighlightForeground, light: ifDefinedThenElse(listActiveSelectionBackground, listHighlightForeground, "#9DDDFF"), hc: listHighlightForeground }, localize("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
var listInvalidItemForeground = registerColor("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hc: "#B89500" }, localize("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
var listErrorForeground = registerColor("list.errorForeground", { dark: "#F88070", light: "#B01011", hc: null }, localize("listErrorForeground", "Foreground color of list items containing errors."));
var listWarningForeground = registerColor("list.warningForeground", { dark: "#CCA700", light: "#855F00", hc: null }, localize("listWarningForeground", "Foreground color of list items containing warnings."));
var listFilterWidgetBackground = registerColor("listFilterWidget.background", { light: "#efc1ad", dark: "#653723", hc: Color.black }, localize("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees."));
var listFilterWidgetOutline = registerColor("listFilterWidget.outline", { dark: Color.transparent, light: Color.transparent, hc: "#f38518" }, localize("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees."));
var listFilterWidgetNoMatchesOutline = registerColor("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hc: contrastBorder }, localize("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches."));
var listFilterMatchHighlight = registerColor("list.filterMatchBackground", { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hc: null }, localize("listFilterMatchHighlight", "Background color of the filtered match."));
var listFilterMatchHighlightBorder = registerColor("list.filterMatchBorder", { dark: editorFindMatchHighlightBorder, light: editorFindMatchHighlightBorder, hc: contrastBorder }, localize("listFilterMatchHighlightBorder", "Border color of the filtered match."));
var treeIndentGuidesStroke = registerColor("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hc: "#a9a9a9" }, localize("treeIndentGuidesStroke", "Tree stroke color for the indentation guides."));
var tableColumnsBorder = registerColor("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hc: null }, localize("tableColumnsBorder", "Table border color between columns."));
var tableOddRowsBackgroundColor = registerColor("tree.tableOddRowsBackground", { dark: transparent(foreground, 0.04), light: transparent(foreground, 0.04), hc: null }, localize("tableOddRowsBackgroundColor", "Background color for odd table rows."));
var listDeemphasizedForeground = registerColor("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hc: "#A7A8A9" }, localize("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized. "));
var _deprecatedQuickInputListFocusBackground = registerColor("quickInput.list.focusBackground", { dark: null, light: null, hc: null }, "", void 0, localize("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead"));
var quickInputListFocusForeground = registerColor("quickInputList.focusForeground", { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hc: listActiveSelectionForeground }, localize("quickInput.listFocusForeground", "Quick picker foreground color for the focused item."));
var quickInputListFocusIconForeground = registerColor("quickInputList.focusIconForeground", { dark: listActiveSelectionIconForeground, light: listActiveSelectionIconForeground, hc: listActiveSelectionIconForeground }, localize("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item."));
var quickInputListFocusBackground = registerColor("quickInputList.focusBackground", { dark: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), light: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), hc: null }, localize("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
var menuBorder = registerColor("menu.border", { dark: null, light: null, hc: contrastBorder }, localize("menuBorder", "Border color of menus."));
var menuForeground = registerColor("menu.foreground", { dark: selectForeground, light: foreground, hc: selectForeground }, localize("menuForeground", "Foreground color of menu items."));
var menuBackground = registerColor("menu.background", { dark: selectBackground, light: selectBackground, hc: selectBackground }, localize("menuBackground", "Background color of menu items."));
var menuSelectionForeground = registerColor("menu.selectionForeground", { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hc: listActiveSelectionForeground }, localize("menuSelectionForeground", "Foreground color of the selected menu item in menus."));
var menuSelectionBackground = registerColor("menu.selectionBackground", { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hc: listActiveSelectionBackground }, localize("menuSelectionBackground", "Background color of the selected menu item in menus."));
var menuSelectionBorder = registerColor("menu.selectionBorder", { dark: null, light: null, hc: activeContrastBorder }, localize("menuSelectionBorder", "Border color of the selected menu item in menus."));
var menuSeparatorBackground = registerColor("menu.separatorBackground", { dark: "#BBBBBB", light: "#888888", hc: contrastBorder }, localize("menuSeparatorBackground", "Color of a separator menu item in menus."));
var toolbarHoverBackground = registerColor("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hc: null }, localize("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
var toolbarHoverOutline = registerColor("toolbar.hoverOutline", { dark: null, light: null, hc: activeContrastBorder }, localize("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
var toolbarActiveBackground = registerColor("toolbar.activeBackground", { dark: lighten(toolbarHoverBackground, 0.1), light: darken(toolbarHoverBackground, 0.1), hc: null }, localize("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
var snippetTabstopHighlightBackground = registerColor("editor.snippetTabstopHighlightBackground", { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hc: new Color(new RGBA(124, 124, 124, 0.3)) }, localize("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
var snippetTabstopHighlightBorder = registerColor("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hc: null }, localize("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
var snippetFinalTabstopHighlightBackground = registerColor("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hc: null }, localize("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
var snippetFinalTabstopHighlightBorder = registerColor("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new Color(new RGBA(10, 50, 100, 0.5)), hc: "#525252" }, localize("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
var breadcrumbsForeground = registerColor("breadcrumb.foreground", { light: transparent(foreground, 0.8), dark: transparent(foreground, 0.8), hc: transparent(foreground, 0.8) }, localize("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
var breadcrumbsBackground = registerColor("breadcrumb.background", { light: editorBackground, dark: editorBackground, hc: editorBackground }, localize("breadcrumbsBackground", "Background color of breadcrumb items."));
var breadcrumbsFocusForeground = registerColor("breadcrumb.focusForeground", { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hc: lighten(foreground, 0.1) }, localize("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
var breadcrumbsActiveSelectionForeground = registerColor("breadcrumb.activeSelectionForeground", { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hc: lighten(foreground, 0.1) }, localize("breadcrumbsSelectedForegound", "Color of selected breadcrumb items."));
var breadcrumbsPickerBackground = registerColor("breadcrumbPicker.background", { light: editorWidgetBackground, dark: editorWidgetBackground, hc: editorWidgetBackground }, localize("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
var headerTransparency = 0.5;
var currentBaseColor = Color.fromHex("#40C8AE").transparent(headerTransparency);
var incomingBaseColor = Color.fromHex("#40A6FF").transparent(headerTransparency);
var commonBaseColor = Color.fromHex("#606060").transparent(0.4);
var contentTransparency = 0.4;
var rulerTransparency = 1;
var mergeCurrentHeaderBackground = registerColor("merge.currentHeaderBackground", { dark: currentBaseColor, light: currentBaseColor, hc: null }, localize("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
var mergeCurrentContentBackground = registerColor("merge.currentContentBackground", { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hc: transparent(mergeCurrentHeaderBackground, contentTransparency) }, localize("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
var mergeIncomingHeaderBackground = registerColor("merge.incomingHeaderBackground", { dark: incomingBaseColor, light: incomingBaseColor, hc: null }, localize("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
var mergeIncomingContentBackground = registerColor("merge.incomingContentBackground", { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hc: transparent(mergeIncomingHeaderBackground, contentTransparency) }, localize("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
var mergeCommonHeaderBackground = registerColor("merge.commonHeaderBackground", { dark: commonBaseColor, light: commonBaseColor, hc: null }, localize("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
var mergeCommonContentBackground = registerColor("merge.commonContentBackground", { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hc: transparent(mergeCommonHeaderBackground, contentTransparency) }, localize("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
var mergeBorder = registerColor("merge.border", { dark: null, light: null, hc: "#C3DF6F" }, localize("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
var overviewRulerCurrentContentForeground = registerColor("editorOverviewRuler.currentContentForeground", { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hc: mergeBorder }, localize("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
var overviewRulerIncomingContentForeground = registerColor("editorOverviewRuler.incomingContentForeground", { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hc: mergeBorder }, localize("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
var overviewRulerCommonContentForeground = registerColor("editorOverviewRuler.commonContentForeground", { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hc: mergeBorder }, localize("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
var overviewRulerFindMatchForeground = registerColor("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hc: "#AB5A00" }, localize("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerSelectionHighlightForeground = registerColor("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, localize("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var minimapFindMatch = registerColor("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hc: "#AB5A00" }, localize("minimapFindMatchHighlight", "Minimap marker color for find matches."), true);
var minimapSelectionOccurrenceHighlight = registerColor("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hc: "#ffffff" }, localize("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), true);
var minimapSelection = registerColor("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hc: "#ffffff" }, localize("minimapSelectionHighlight", "Minimap marker color for the editor selection."), true);
var minimapError = registerColor("minimap.errorHighlight", { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, localize("minimapError", "Minimap marker color for errors."));
var minimapWarning = registerColor("minimap.warningHighlight", { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder }, localize("overviewRuleWarning", "Minimap marker color for warnings."));
var minimapBackground = registerColor("minimap.background", { dark: null, light: null, hc: null }, localize("minimapBackground", "Minimap background color."));
var minimapForegroundOpacity = registerColor("minimap.foregroundOpacity", { dark: Color.fromHex("#000f"), light: Color.fromHex("#000f"), hc: Color.fromHex("#000f") }, localize("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
var minimapSliderBackground = registerColor("minimapSlider.background", { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hc: transparent(scrollbarSliderBackground, 0.5) }, localize("minimapSliderBackground", "Minimap slider background color."));
var minimapSliderHoverBackground = registerColor("minimapSlider.hoverBackground", { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hc: transparent(scrollbarSliderHoverBackground, 0.5) }, localize("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
var minimapSliderActiveBackground = registerColor("minimapSlider.activeBackground", { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hc: transparent(scrollbarSliderActiveBackground, 0.5) }, localize("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
var problemsErrorIconForeground = registerColor("problemsErrorIcon.foreground", { dark: editorErrorForeground, light: editorErrorForeground, hc: editorErrorForeground }, localize("problemsErrorIconForeground", "The color used for the problems error icon."));
var problemsWarningIconForeground = registerColor("problemsWarningIcon.foreground", { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningForeground }, localize("problemsWarningIconForeground", "The color used for the problems warning icon."));
var problemsInfoIconForeground = registerColor("problemsInfoIcon.foreground", { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoForeground }, localize("problemsInfoIconForeground", "The color used for the problems info icon."));
var chartsForeground = registerColor("charts.foreground", { dark: foreground, light: foreground, hc: foreground }, localize("chartsForeground", "The foreground color used in charts."));
var chartsLines = registerColor("charts.lines", { dark: transparent(foreground, 0.5), light: transparent(foreground, 0.5), hc: transparent(foreground, 0.5) }, localize("chartsLines", "The color used for horizontal lines in charts."));
var chartsRed = registerColor("charts.red", { dark: editorErrorForeground, light: editorErrorForeground, hc: editorErrorForeground }, localize("chartsRed", "The red color used in chart visualizations."));
var chartsBlue = registerColor("charts.blue", { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoForeground }, localize("chartsBlue", "The blue color used in chart visualizations."));
var chartsYellow = registerColor("charts.yellow", { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningForeground }, localize("chartsYellow", "The yellow color used in chart visualizations."));
var chartsOrange = registerColor("charts.orange", { dark: minimapFindMatch, light: minimapFindMatch, hc: minimapFindMatch }, localize("chartsOrange", "The orange color used in chart visualizations."));
var chartsGreen = registerColor("charts.green", { dark: "#89D185", light: "#388A34", hc: "#89D185" }, localize("chartsGreen", "The green color used in chart visualizations."));
var chartsPurple = registerColor("charts.purple", { dark: "#B180D7", light: "#652D90", hc: "#B180D7" }, localize("chartsPurple", "The purple color used in chart visualizations."));
function executeTransform(transform, theme) {
  var _a3, _b, _c;
  switch (transform.op) {
    case 0:
      return (_a3 = resolveColorValue(transform.value, theme)) === null || _a3 === void 0 ? void 0 : _a3.darken(transform.factor);
    case 1:
      return (_b = resolveColorValue(transform.value, theme)) === null || _b === void 0 ? void 0 : _b.lighten(transform.factor);
    case 2:
      return (_c = resolveColorValue(transform.value, theme)) === null || _c === void 0 ? void 0 : _c.transparent(transform.factor);
    case 3:
      for (const candidate of transform.values) {
        const color = resolveColorValue(candidate, theme);
        if (color) {
          return color;
        }
      }
      return void 0;
    case 5:
      return resolveColorValue(theme.defines(transform.if) ? transform.then : transform.else, theme);
    case 4: {
      const from = resolveColorValue(transform.value, theme);
      if (!from) {
        return void 0;
      }
      const backgroundColor = resolveColorValue(transform.background, theme);
      if (!backgroundColor) {
        return from.transparent(transform.factor * transform.transparency);
      }
      return from.isDarkerThan(backgroundColor) ? Color.getLighterColor(from, backgroundColor, transform.factor).transparent(transform.transparency) : Color.getDarkerColor(from, backgroundColor, transform.factor).transparent(transform.transparency);
    }
    default:
      throw assertNever(transform);
  }
}
function darken(colorValue, factor2) {
  return { op: 0, value: colorValue, factor: factor2 };
}
function lighten(colorValue, factor2) {
  return { op: 1, value: colorValue, factor: factor2 };
}
function transparent(colorValue, factor2) {
  return { op: 2, value: colorValue, factor: factor2 };
}
function oneOf(...colorValues) {
  return { op: 3, values: colorValues };
}
function ifDefinedThenElse(ifArg, thenArg, elseArg) {
  return { op: 5, if: ifArg, then: thenArg, else: elseArg };
}
function lessProminent(colorValue, backgroundColorValue, factor2, transparency) {
  return { op: 4, value: colorValue, background: backgroundColorValue, factor: factor2, transparency };
}
function resolveColorValue(colorValue, theme) {
  if (colorValue === null) {
    return void 0;
  } else if (typeof colorValue === "string") {
    if (colorValue[0] === "#") {
      return Color.fromHex(colorValue);
    }
    return theme.getColor(colorValue);
  } else if (colorValue instanceof Color) {
    return colorValue;
  } else if (typeof colorValue === "object") {
    return executeTransform(colorValue, theme);
  }
  return void 0;
}
var workbenchColorsSchemaId = "vscode://schemas/workbench-colors";
var schemaRegistry = Registry.as(Extensions4.JSONContribution);
schemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());
var delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);
colorRegistry.onDidChangeSchema(() => {
  if (!delayer.isScheduled()) {
    delayer.schedule();
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/commands/replaceCommand.js
var ReplaceCommand = class {
  constructor(range2, text, insertsAutoWhitespace = false) {
    this._range = range2;
    this._text = text;
    this.insertsAutoWhitespace = insertsAutoWhitespace;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    return Selection.fromPositions(srcRange.getEndPosition());
  }
};
var ReplaceCommandWithoutChangingPosition = class {
  constructor(range2, text, insertsAutoWhitespace = false) {
    this._range = range2;
    this._text = text;
    this.insertsAutoWhitespace = insertsAutoWhitespace;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    return Selection.fromPositions(srcRange.getStartPosition());
  }
};
var ReplaceCommandWithOffsetCursorState = class {
  constructor(range2, text, lineNumberDeltaOffset, columnDeltaOffset, insertsAutoWhitespace = false) {
    this._range = range2;
    this._text = text;
    this._columnDeltaOffset = columnDeltaOffset;
    this._lineNumberDeltaOffset = lineNumberDeltaOffset;
    this.insertsAutoWhitespace = insertsAutoWhitespace;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    return Selection.fromPositions(srcRange.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
  }
};
var ReplaceCommandThatPreservesSelection = class {
  constructor(editRange, text, initialSelection, forceMoveMarkers = false) {
    this._range = editRange;
    this._text = text;
    this._initialSelection = initialSelection;
    this._forceMoveMarkers = forceMoveMarkers;
    this._selectionId = null;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers);
    this._selectionId = builder.trackSelection(this._initialSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};

// node_modules/monaco-editor/esm/vs/base/common/decorators.js
function memoize(_target, key, descriptor) {
  let fnKey = null;
  let fn = null;
  if (typeof descriptor.value === "function") {
    fnKey = "value";
    fn = descriptor.value;
    if (fn.length !== 0) {
      console.warn("Memoize should only be used in functions with zero parameters");
    }
  } else if (typeof descriptor.get === "function") {
    fnKey = "get";
    fn = descriptor.get;
  }
  if (!fn) {
    throw new Error("not supported");
  }
  const memoizeKey = `$memoize$${key}`;
  descriptor[fnKey] = function(...args) {
    if (!this.hasOwnProperty(memoizeKey)) {
      Object.defineProperty(this, memoizeKey, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: fn.apply(this, args)
      });
    }
    return this[memoizeKey];
  };
}

// node_modules/monaco-editor/esm/vs/base/browser/touch.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EventType2;
(function(EventType3) {
  EventType3.Tap = "-monaco-gesturetap";
  EventType3.Change = "-monaco-gesturechange";
  EventType3.Start = "-monaco-gesturestart";
  EventType3.End = "-monaco-gesturesend";
  EventType3.Contextmenu = "-monaco-gesturecontextmenu";
})(EventType2 || (EventType2 = {}));
var Gesture = class _Gesture extends Disposable {
  constructor() {
    super();
    this.dispatched = false;
    this.activeTouches = {};
    this.handle = null;
    this.targets = [];
    this.ignoreTargets = [];
    this._lastSetTapCountTime = 0;
    this._register(addDisposableListener(document, "touchstart", (e) => this.onTouchStart(e), { passive: false }));
    this._register(addDisposableListener(document, "touchend", (e) => this.onTouchEnd(e)));
    this._register(addDisposableListener(document, "touchmove", (e) => this.onTouchMove(e), { passive: false }));
  }
  static addTarget(element) {
    if (!_Gesture.isTouchDevice()) {
      return Disposable.None;
    }
    if (!_Gesture.INSTANCE) {
      _Gesture.INSTANCE = new _Gesture();
    }
    _Gesture.INSTANCE.targets.push(element);
    return {
      dispose: () => {
        _Gesture.INSTANCE.targets = _Gesture.INSTANCE.targets.filter((t) => t !== element);
      }
    };
  }
  static ignoreTarget(element) {
    if (!_Gesture.isTouchDevice()) {
      return Disposable.None;
    }
    if (!_Gesture.INSTANCE) {
      _Gesture.INSTANCE = new _Gesture();
    }
    _Gesture.INSTANCE.ignoreTargets.push(element);
    return {
      dispose: () => {
        _Gesture.INSTANCE.ignoreTargets = _Gesture.INSTANCE.ignoreTargets.filter((t) => t !== element);
      }
    };
  }
  static isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  dispose() {
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    super.dispose();
  }
  onTouchStart(e) {
    let timestamp = Date.now();
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    for (let i = 0, len = e.targetTouches.length; i < len; i++) {
      let touch = e.targetTouches.item(i);
      this.activeTouches[touch.identifier] = {
        id: touch.identifier,
        initialTarget: touch.target,
        initialTimeStamp: timestamp,
        initialPageX: touch.pageX,
        initialPageY: touch.pageY,
        rollingTimestamps: [timestamp],
        rollingPageX: [touch.pageX],
        rollingPageY: [touch.pageY]
      };
      let evt = this.newGestureEvent(EventType2.Start, touch.target);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
  onTouchEnd(e) {
    let timestamp = Date.now();
    let activeTouchCount = Object.keys(this.activeTouches).length;
    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      let touch = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn("move of an UNKNOWN touch", touch);
        continue;
      }
      let data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
      if (holdTime < _Gesture.HOLD_DELAY && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
        let evt = this.newGestureEvent(EventType2.Tap, data.initialTarget);
        evt.pageX = tail(data.rollingPageX);
        evt.pageY = tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (holdTime >= _Gesture.HOLD_DELAY && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
        let evt = this.newGestureEvent(EventType2.Contextmenu, data.initialTarget);
        evt.pageX = tail(data.rollingPageX);
        evt.pageY = tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (activeTouchCount === 1) {
        let finalX = tail(data.rollingPageX);
        let finalY = tail(data.rollingPageY);
        let deltaT = tail(data.rollingTimestamps) - data.rollingTimestamps[0];
        let deltaX = finalX - data.rollingPageX[0];
        let deltaY = finalY - data.rollingPageY[0];
        const dispatchTo = this.targets.filter((t) => data.initialTarget instanceof Node && t.contains(data.initialTarget));
        this.inertia(
          dispatchTo,
          timestamp,
          // time now
          Math.abs(deltaX) / deltaT,
          // speed
          deltaX > 0 ? 1 : -1,
          // x direction
          finalX,
          // x now
          Math.abs(deltaY) / deltaT,
          // y speed
          deltaY > 0 ? 1 : -1,
          // y direction
          finalY
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(EventType2.End, data.initialTarget));
      delete this.activeTouches[touch.identifier];
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
  newGestureEvent(type, initialTarget) {
    let event = document.createEvent("CustomEvent");
    event.initEvent(type, false, true);
    event.initialTarget = initialTarget;
    event.tapCount = 0;
    return event;
  }
  dispatchEvent(event) {
    if (event.type === EventType2.Tap) {
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      let setTapCount = 0;
      if (currentTime - this._lastSetTapCountTime > _Gesture.CLEAR_TAP_COUNT_TIME) {
        setTapCount = 1;
      } else {
        setTapCount = 2;
      }
      this._lastSetTapCountTime = currentTime;
      event.tapCount = setTapCount;
    } else if (event.type === EventType2.Change || event.type === EventType2.Contextmenu) {
      this._lastSetTapCountTime = 0;
    }
    for (let i = 0; i < this.ignoreTargets.length; i++) {
      if (event.initialTarget instanceof Node && this.ignoreTargets[i].contains(event.initialTarget)) {
        return;
      }
    }
    this.targets.forEach((target) => {
      if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {
        target.dispatchEvent(event);
        this.dispatched = true;
      }
    });
  }
  inertia(dispatchTo, t1, vX, dirX, x, vY, dirY, y) {
    this.handle = scheduleAtNextAnimationFrame(() => {
      let now = Date.now();
      let deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;
      vX += _Gesture.SCROLL_FRICTION * deltaT;
      vY += _Gesture.SCROLL_FRICTION * deltaT;
      if (vX > 0) {
        stopped = false;
        delta_pos_x = dirX * vX * deltaT;
      }
      if (vY > 0) {
        stopped = false;
        delta_pos_y = dirY * vY * deltaT;
      }
      let evt = this.newGestureEvent(EventType2.Change);
      evt.translationX = delta_pos_x;
      evt.translationY = delta_pos_y;
      dispatchTo.forEach((d) => d.dispatchEvent(evt));
      if (!stopped) {
        this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
      }
    });
  }
  onTouchMove(e) {
    let timestamp = Date.now();
    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      let touch = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn("end of an UNKNOWN touch", touch);
        continue;
      }
      let data = this.activeTouches[touch.identifier];
      let evt = this.newGestureEvent(EventType2.Change, data.initialTarget);
      evt.translationX = touch.pageX - tail(data.rollingPageX);
      evt.translationY = touch.pageY - tail(data.rollingPageY);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
      if (data.rollingPageX.length > 3) {
        data.rollingPageX.shift();
        data.rollingPageY.shift();
        data.rollingTimestamps.shift();
      }
      data.rollingPageX.push(touch.pageX);
      data.rollingPageY.push(touch.pageY);
      data.rollingTimestamps.push(timestamp);
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
};
Gesture.SCROLL_FRICTION = -5e-3;
Gesture.HOLD_DELAY = 700;
Gesture.CLEAR_TAP_COUNT_TIME = 400;
__decorate3([
  memoize
], Gesture, "isTouchDevice", null);

// node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js
var Widget = class extends Disposable {
  onclick(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.CLICK, (e) => listener(new StandardMouseEvent(e))));
  }
  onmousedown(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_DOWN, (e) => listener(new StandardMouseEvent(e))));
  }
  onmouseover(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_OVER, (e) => listener(new StandardMouseEvent(e))));
  }
  onnonbubblingmouseout(domNode, listener) {
    this._register(addDisposableNonBubblingMouseOutListener(domNode, (e) => listener(new StandardMouseEvent(e))));
  }
  onkeydown(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => listener(new StandardKeyboardEvent(e))));
  }
  onkeyup(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.KEY_UP, (e) => listener(new StandardKeyboardEvent(e))));
  }
  oninput(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.INPUT, listener));
  }
  onblur(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.BLUR, listener));
  }
  onfocus(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.FOCUS, listener));
  }
  ignoreGesture(domNode) {
    Gesture.ignoreTarget(domNode);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/event.js
var DomEmitter = class {
  constructor(element, type, useCapture) {
    const fn = (e) => this.emitter.fire(e);
    this.emitter = new Emitter({
      onFirstListenerAdd: () => element.addEventListener(type, fn, useCapture),
      onLastListenerRemove: () => element.removeEventListener(type, fn, useCapture)
    });
  }
  get event() {
    return this.emitter.event;
  }
  dispose() {
    this.emitter.dispose();
  }
};
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
  return event;
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js
import "/home/ubuntu/project/s/front2.0/node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.css";
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DEBUG = false;
var OrthogonalEdge;
(function(OrthogonalEdge2) {
  OrthogonalEdge2["North"] = "north";
  OrthogonalEdge2["South"] = "south";
  OrthogonalEdge2["East"] = "east";
  OrthogonalEdge2["West"] = "west";
})(OrthogonalEdge || (OrthogonalEdge = {}));
var globalSize = 4;
var onDidChangeGlobalSize = new Emitter();
var globalHoverDelay = 300;
var onDidChangeHoverDelay = new Emitter();
var MouseEventFactory = class {
  constructor() {
    this.disposables = new DisposableStore();
  }
  get onPointerMove() {
    return this.disposables.add(new DomEmitter(window, "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new DomEmitter(window, "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
};
__decorate4([
  memoize
], MouseEventFactory.prototype, "onPointerMove", null);
__decorate4([
  memoize
], MouseEventFactory.prototype, "onPointerUp", null);
var GestureEventFactory = class {
  constructor(el) {
    this.el = el;
    this.disposables = new DisposableStore();
  }
  get onPointerMove() {
    return this.disposables.add(new DomEmitter(this.el, EventType2.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new DomEmitter(this.el, EventType2.End)).event;
  }
  dispose() {
    this.disposables.dispose();
  }
};
__decorate4([
  memoize
], GestureEventFactory.prototype, "onPointerMove", null);
__decorate4([
  memoize
], GestureEventFactory.prototype, "onPointerUp", null);
var OrthogonalPointerEventFactory = class {
  constructor(factory) {
    this.factory = factory;
  }
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  dispose() {
  }
};
__decorate4([
  memoize
], OrthogonalPointerEventFactory.prototype, "onPointerMove", null);
__decorate4([
  memoize
], OrthogonalPointerEventFactory.prototype, "onPointerUp", null);
var PointerEventsDisabledCssClass = "pointer-events-disabled";
var Sash = class _Sash extends Disposable {
  constructor(container, layoutProvider, options) {
    super();
    this.hoverDelay = globalHoverDelay;
    this.hoverDelayer = this._register(new Delayer(this.hoverDelay));
    this._state = 3;
    this.onDidEnablementChange = this._register(new Emitter());
    this._onDidStart = this._register(new Emitter());
    this._onDidChange = this._register(new Emitter());
    this._onDidReset = this._register(new Emitter());
    this._onDidEnd = this._register(new Emitter());
    this.orthogonalStartSashDisposables = this._register(new DisposableStore());
    this.orthogonalStartDragHandleDisposables = this._register(new DisposableStore());
    this.orthogonalEndSashDisposables = this._register(new DisposableStore());
    this.orthogonalEndDragHandleDisposables = this._register(new DisposableStore());
    this.onDidStart = this._onDidStart.event;
    this.onDidChange = this._onDidChange.event;
    this.onDidReset = this._onDidReset.event;
    this.onDidEnd = this._onDidEnd.event;
    this.linkedSash = void 0;
    this.el = append(container, $(".monaco-sash"));
    if (options.orthogonalEdge) {
      this.el.classList.add(`orthogonal-edge-${options.orthogonalEdge}`);
    }
    if (isMacintosh) {
      this.el.classList.add("mac");
    }
    const onMouseDown = this._register(new DomEmitter(this.el, "mousedown")).event;
    this._register(onMouseDown((e) => this.onPointerStart(e, new MouseEventFactory()), this));
    const onMouseDoubleClick = this._register(new DomEmitter(this.el, "dblclick")).event;
    this._register(onMouseDoubleClick(this.onPointerDoublePress, this));
    const onMouseEnter = this._register(new DomEmitter(this.el, "mouseenter")).event;
    this._register(onMouseEnter(() => _Sash.onMouseEnter(this)));
    const onMouseLeave = this._register(new DomEmitter(this.el, "mouseleave")).event;
    this._register(onMouseLeave(() => _Sash.onMouseLeave(this)));
    this._register(Gesture.addTarget(this.el));
    const onTouchStart = Event.map(this._register(new DomEmitter(this.el, EventType2.Start)).event, (e) => {
      var _a3;
      return Object.assign(Object.assign({}, e), { target: (_a3 = e.initialTarget) !== null && _a3 !== void 0 ? _a3 : null });
    });
    this._register(onTouchStart((e) => this.onPointerStart(e, new GestureEventFactory(this.el)), this));
    const onTap = this._register(new DomEmitter(this.el, EventType2.Tap)).event;
    const onDoubleTap = Event.map(Event.filter(Event.debounce(onTap, (res, event) => {
      var _a3;
      return { event, count: ((_a3 = res === null || res === void 0 ? void 0 : res.count) !== null && _a3 !== void 0 ? _a3 : 0) + 1 };
    }, 250), ({ count }) => count === 2), ({ event }) => {
      var _a3;
      return Object.assign(Object.assign({}, event), { target: (_a3 = event.initialTarget) !== null && _a3 !== void 0 ? _a3 : null });
    });
    this._register(onDoubleTap(this.onPointerDoublePress, this));
    if (typeof options.size === "number") {
      this.size = options.size;
      if (options.orientation === 0) {
        this.el.style.width = `${this.size}px`;
      } else {
        this.el.style.height = `${this.size}px`;
      }
    } else {
      this.size = globalSize;
      this._register(onDidChangeGlobalSize.event((size) => {
        this.size = size;
        this.layout();
      }));
    }
    this._register(onDidChangeHoverDelay.event((delay) => this.hoverDelay = delay));
    this.layoutProvider = layoutProvider;
    this.orthogonalStartSash = options.orthogonalStartSash;
    this.orthogonalEndSash = options.orthogonalEndSash;
    this.orientation = options.orientation || 0;
    if (this.orientation === 1) {
      this.el.classList.add("horizontal");
      this.el.classList.remove("vertical");
    } else {
      this.el.classList.remove("horizontal");
      this.el.classList.add("vertical");
    }
    this.el.classList.toggle("debug", DEBUG);
    this.layout();
  }
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */
  set state(state) {
    if (this._state === state) {
      return;
    }
    this.el.classList.toggle(
      "disabled",
      state === 0
      /* Disabled */
    );
    this.el.classList.toggle(
      "minimum",
      state === 1
      /* AtMinimum */
    );
    this.el.classList.toggle(
      "maximum",
      state === 2
      /* AtMaximum */
    );
    this._state = state;
    this.onDidEnablementChange.fire(state);
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */
  set orthogonalStartSash(sash) {
    this.orthogonalStartDragHandleDisposables.clear();
    this.orthogonalStartSashDisposables.clear();
    if (sash) {
      const onChange = (state) => {
        this.orthogonalStartDragHandleDisposables.clear();
        if (state !== 0) {
          this._orthogonalStartDragHandle = append(this.el, $(".orthogonal-drag-handle.start"));
          this.orthogonalStartDragHandleDisposables.add(toDisposable(() => this._orthogonalStartDragHandle.remove()));
          this.orthogonalStartDragHandleDisposables.add(new DomEmitter(this._orthogonalStartDragHandle, "mouseenter")).event(() => _Sash.onMouseEnter(sash), void 0, this.orthogonalStartDragHandleDisposables);
          this.orthogonalStartDragHandleDisposables.add(new DomEmitter(this._orthogonalStartDragHandle, "mouseleave")).event(() => _Sash.onMouseLeave(sash), void 0, this.orthogonalStartDragHandleDisposables);
        }
      };
      this.orthogonalStartSashDisposables.add(sash.onDidEnablementChange.event(onChange, this));
      onChange(sash.state);
    }
    this._orthogonalStartSash = sash;
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */
  set orthogonalEndSash(sash) {
    this.orthogonalEndDragHandleDisposables.clear();
    this.orthogonalEndSashDisposables.clear();
    if (sash) {
      const onChange = (state) => {
        this.orthogonalEndDragHandleDisposables.clear();
        if (state !== 0) {
          this._orthogonalEndDragHandle = append(this.el, $(".orthogonal-drag-handle.end"));
          this.orthogonalEndDragHandleDisposables.add(toDisposable(() => this._orthogonalEndDragHandle.remove()));
          this.orthogonalEndDragHandleDisposables.add(new DomEmitter(this._orthogonalEndDragHandle, "mouseenter")).event(() => _Sash.onMouseEnter(sash), void 0, this.orthogonalEndDragHandleDisposables);
          this.orthogonalEndDragHandleDisposables.add(new DomEmitter(this._orthogonalEndDragHandle, "mouseleave")).event(() => _Sash.onMouseLeave(sash), void 0, this.orthogonalEndDragHandleDisposables);
        }
      };
      this.orthogonalEndSashDisposables.add(sash.onDidEnablementChange.event(onChange, this));
      onChange(sash.state);
    }
    this._orthogonalEndSash = sash;
  }
  onPointerStart(event, pointerEventFactory) {
    EventHelper.stop(event);
    let isMultisashResize = false;
    if (!event.__orthogonalSashEvent) {
      const orthogonalSash = this.getOrthogonalSash(event);
      if (orthogonalSash) {
        isMultisashResize = true;
        event.__orthogonalSashEvent = true;
        orthogonalSash.onPointerStart(event, new OrthogonalPointerEventFactory(pointerEventFactory));
      }
    }
    if (this.linkedSash && !event.__linkedSashEvent) {
      event.__linkedSashEvent = true;
      this.linkedSash.onPointerStart(event, new OrthogonalPointerEventFactory(pointerEventFactory));
    }
    if (!this.state) {
      return;
    }
    const iframes = getElementsByTagName("iframe");
    for (const iframe of iframes) {
      iframe.classList.add(PointerEventsDisabledCssClass);
    }
    const startX = event.pageX;
    const startY = event.pageY;
    const altKey = event.altKey;
    const startEvent = { startX, currentX: startX, startY, currentY: startY, altKey };
    this.el.classList.add("active");
    this._onDidStart.fire(startEvent);
    const style = createStyleSheet(this.el);
    const updateStyle = () => {
      let cursor = "";
      if (isMultisashResize) {
        cursor = "all-scroll";
      } else if (this.orientation === 1) {
        if (this.state === 1) {
          cursor = "s-resize";
        } else if (this.state === 2) {
          cursor = "n-resize";
        } else {
          cursor = isMacintosh ? "row-resize" : "ns-resize";
        }
      } else {
        if (this.state === 1) {
          cursor = "e-resize";
        } else if (this.state === 2) {
          cursor = "w-resize";
        } else {
          cursor = isMacintosh ? "col-resize" : "ew-resize";
        }
      }
      style.textContent = `* { cursor: ${cursor} !important; }`;
    };
    const disposables = new DisposableStore();
    updateStyle();
    if (!isMultisashResize) {
      this.onDidEnablementChange.event(updateStyle, null, disposables);
    }
    const onPointerMove = (e) => {
      EventHelper.stop(e, false);
      const event2 = { startX, currentX: e.pageX, startY, currentY: e.pageY, altKey };
      this._onDidChange.fire(event2);
    };
    const onPointerUp = (e) => {
      EventHelper.stop(e, false);
      this.el.removeChild(style);
      this.el.classList.remove("active");
      this._onDidEnd.fire();
      disposables.dispose();
      for (const iframe of iframes) {
        iframe.classList.remove(PointerEventsDisabledCssClass);
      }
    };
    pointerEventFactory.onPointerMove(onPointerMove, null, disposables);
    pointerEventFactory.onPointerUp(onPointerUp, null, disposables);
    disposables.add(pointerEventFactory);
  }
  onPointerDoublePress(e) {
    const orthogonalSash = this.getOrthogonalSash(e);
    if (orthogonalSash) {
      orthogonalSash._onDidReset.fire();
    }
    if (this.linkedSash) {
      this.linkedSash._onDidReset.fire();
    }
    this._onDidReset.fire();
  }
  static onMouseEnter(sash, fromLinkedSash = false) {
    if (sash.el.classList.contains("active")) {
      sash.hoverDelayer.cancel();
      sash.el.classList.add("hover");
    } else {
      sash.hoverDelayer.trigger(() => sash.el.classList.add("hover"), sash.hoverDelay).then(void 0, () => {
      });
    }
    if (!fromLinkedSash && sash.linkedSash) {
      _Sash.onMouseEnter(sash.linkedSash, true);
    }
  }
  static onMouseLeave(sash, fromLinkedSash = false) {
    sash.hoverDelayer.cancel();
    sash.el.classList.remove("hover");
    if (!fromLinkedSash && sash.linkedSash) {
      _Sash.onMouseLeave(sash.linkedSash, true);
    }
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */
  clearSashHoverState() {
    _Sash.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */
  layout() {
    if (this.orientation === 0) {
      const verticalProvider = this.layoutProvider;
      this.el.style.left = verticalProvider.getVerticalSashLeft(this) - this.size / 2 + "px";
      if (verticalProvider.getVerticalSashTop) {
        this.el.style.top = verticalProvider.getVerticalSashTop(this) + "px";
      }
      if (verticalProvider.getVerticalSashHeight) {
        this.el.style.height = verticalProvider.getVerticalSashHeight(this) + "px";
      }
    } else {
      const horizontalProvider = this.layoutProvider;
      this.el.style.top = horizontalProvider.getHorizontalSashTop(this) - this.size / 2 + "px";
      if (horizontalProvider.getHorizontalSashLeft) {
        this.el.style.left = horizontalProvider.getHorizontalSashLeft(this) + "px";
      }
      if (horizontalProvider.getHorizontalSashWidth) {
        this.el.style.width = horizontalProvider.getHorizontalSashWidth(this) + "px";
      }
    }
  }
  getOrthogonalSash(e) {
    if (!e.target || !(e.target instanceof HTMLElement)) {
      return void 0;
    }
    if (e.target.classList.contains("orthogonal-drag-handle")) {
      return e.target.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
    }
    return void 0;
  }
  dispose() {
    super.dispose();
    this.el.remove();
  }
};

// node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js
var Extensions6 = {
  IconContribution: "base.contributions.icons"
};
var IconContribution;
(function(IconContribution2) {
  function getDefinition(contribution, registry) {
    let definition = contribution.defaults;
    while (ThemeIcon.isThemeIcon(definition)) {
      const c = iconRegistry.getIcon(definition.id);
      if (!c) {
        return void 0;
      }
      definition = c.defaults;
    }
    return definition;
  }
  IconContribution2.getDefinition = getDefinition;
})(IconContribution || (IconContribution = {}));
var IconRegistry = class {
  constructor() {
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: localize("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: localize("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: false,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    };
    this.iconReferenceSchema = { type: "string", pattern: `^${CSSIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };
    this.iconsById = {};
    this.iconFontsById = {};
  }
  registerIcon(id, defaults, description, deprecationMessage) {
    const existing = this.iconsById[id];
    if (existing) {
      if (description && !existing.description) {
        existing.description = description;
        this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;
        const enumIndex = this.iconReferenceSchema.enum.indexOf(id);
        if (enumIndex !== -1) {
          this.iconReferenceSchema.enumDescriptions[enumIndex] = description;
        }
        this._onDidChange.fire();
      }
      return existing;
    }
    let iconContribution = { id, description, defaults, deprecationMessage };
    this.iconsById[id] = iconContribution;
    let propertySchema = { $ref: "#/definitions/icons" };
    if (deprecationMessage) {
      propertySchema.deprecationMessage = deprecationMessage;
    }
    if (description) {
      propertySchema.markdownDescription = `${description}: $(${id})`;
    }
    this.iconSchema.properties[id] = propertySchema;
    this.iconReferenceSchema.enum.push(id);
    this.iconReferenceSchema.enumDescriptions.push(description || "");
    this._onDidChange.fire();
    return { id };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((id) => this.iconsById[id]);
  }
  getIcon(id) {
    return this.iconsById[id];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const sorter2 = (i1, i2) => {
      return i1.id.localeCompare(i2.id);
    };
    const classNames = (i) => {
      while (ThemeIcon.isThemeIcon(i.defaults)) {
        i = this.iconsById[i.defaults.id];
      }
      return `codicon codicon-${i ? i.id : ""}`;
    };
    let reference = [];
    reference.push(`| preview     | identifier                        | default codicon ID                | description`);
    reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);
    const contributions = Object.keys(this.iconsById).map((key) => this.iconsById[key]);
    for (const i of contributions.filter((i2) => !!i2.description).sort(sorter2)) {
      reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ""}|`);
    }
    reference.push(`| preview     | identifier                        `);
    reference.push(`| ----------- | --------------------------------- |`);
    for (const i of contributions.filter((i2) => !ThemeIcon.isThemeIcon(i2.defaults)).sort(sorter2)) {
      reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|`);
    }
    return reference.join("\n");
  }
};
var iconRegistry = new IconRegistry();
Registry.add(Extensions6.IconContribution, iconRegistry);
function registerIcon(id, defaults, description, deprecationMessage) {
  return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);
}
function getIconRegistry() {
  return iconRegistry;
}
function initialize() {
  for (const icon of Codicon.getAll()) {
    iconRegistry.registerIcon(icon.id, icon.definition, icon.description);
  }
}
initialize();
var iconsSchemaId = "vscode://schemas/icons";
var schemaRegistry2 = Registry.as(Extensions4.JSONContribution);
schemaRegistry2.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());
var delayer2 = new RunOnceScheduler(() => schemaRegistry2.notifySchemaChanged(iconsSchemaId), 200);
iconRegistry.onDidChange(() => {
  if (!delayer2.isScheduled()) {
    delayer2.schedule();
  }
});
var widgetClose = registerIcon("widget-close", Codicon.close, localize("widgetClose", "Icon for the close action in widgets."));
var gotoPreviousLocation = registerIcon("goto-previous-location", Codicon.arrowUp, localize("previousChangeIcon", "Icon for goto previous editor location."));
var gotoNextLocation = registerIcon("goto-next-location", Codicon.arrowDown, localize("nextChangeIcon", "Icon for goto next editor location."));
var syncing = ThemeIcon.modify(Codicon.sync, "spin");
var spinningLoading = ThemeIcon.modify(Codicon.loading, "spin");

// node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js
var LineTokens = class _LineTokens {
  constructor(tokens, text, decoder) {
    this._lineTokensBrand = void 0;
    this._tokens = tokens;
    this._tokensCount = this._tokens.length >>> 1;
    this._text = text;
    this._languageIdCodec = decoder;
  }
  static createEmpty(lineContent, decoder) {
    const defaultMetadata = _LineTokens.defaultTokenMetadata;
    const tokens = new Uint32Array(2);
    tokens[0] = lineContent.length;
    tokens[1] = defaultMetadata;
    return new _LineTokens(tokens, lineContent, decoder);
  }
  equals(other) {
    if (other instanceof _LineTokens) {
      return this.slicedEquals(other, 0, this._tokensCount);
    }
    return false;
  }
  slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {
    if (this._text !== other._text) {
      return false;
    }
    if (this._tokensCount !== other._tokensCount) {
      return false;
    }
    const from = sliceFromTokenIndex << 1;
    const to = from + (sliceTokenCount << 1);
    for (let i = from; i < to; i++) {
      if (this._tokens[i] !== other._tokens[i]) {
        return false;
      }
    }
    return true;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(tokenIndex) {
    if (tokenIndex > 0) {
      return this._tokens[tokenIndex - 1 << 1];
    }
    return 0;
  }
  getMetadata(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return metadata;
  }
  getLanguageId(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    const languageId = TokenMetadata.getLanguageId(metadata);
    return this._languageIdCodec.decodeLanguageId(languageId);
  }
  getStandardTokenType(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getTokenType(metadata);
  }
  getForeground(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getForeground(metadata);
  }
  getClassName(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getClassNameFromMetadata(metadata);
  }
  getInlineStyle(tokenIndex, colorMap) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
  }
  getPresentation(tokenIndex) {
    const metadata = this._tokens[(tokenIndex << 1) + 1];
    return TokenMetadata.getPresentationFromMetadata(metadata);
  }
  getEndOffset(tokenIndex) {
    return this._tokens[tokenIndex << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(offset) {
    return _LineTokens.findIndexInTokensArray(this._tokens, offset);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(startOffset, endOffset, deltaOffset) {
    return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);
  }
  static convertToEndOffset(tokens, lineTextLength) {
    const tokenCount = tokens.length >>> 1;
    const lastTokenIndex = tokenCount - 1;
    for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];
    }
    tokens[lastTokenIndex << 1] = lineTextLength;
  }
  static findIndexInTokensArray(tokens, desiredIndex) {
    if (tokens.length <= 2) {
      return 0;
    }
    let low = 0;
    let high = (tokens.length >>> 1) - 1;
    while (low < high) {
      const mid = low + Math.floor((high - low) / 2);
      const endOffset = tokens[mid << 1];
      if (endOffset === desiredIndex) {
        return mid + 1;
      } else if (endOffset < desiredIndex) {
        low = mid + 1;
      } else if (endOffset > desiredIndex) {
        high = mid;
      }
    }
    return low;
  }
  /**
   * @pure
   * @param insertTokens Must be sorted by offset.
  */
  withInserted(insertTokens) {
    if (insertTokens.length === 0) {
      return this;
    }
    let nextOriginalTokenIdx = 0;
    let nextInsertTokenIdx = 0;
    let text = "";
    const newTokens = new Array();
    let originalEndOffset = 0;
    while (true) {
      const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;
      const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;
      if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {
        text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);
        const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
        newTokens.push(text.length, metadata);
        nextOriginalTokenIdx++;
        originalEndOffset = nextOriginalTokenEndOffset;
      } else if (nextInsertToken) {
        if (nextInsertToken.offset > originalEndOffset) {
          text += this._text.substring(originalEndOffset, nextInsertToken.offset);
          const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
          newTokens.push(text.length, metadata);
          originalEndOffset = nextInsertToken.offset;
        }
        text += nextInsertToken.text;
        newTokens.push(text.length, nextInsertToken.tokenMetadata);
        nextInsertTokenIdx++;
      } else {
        break;
      }
    }
    return new _LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);
  }
};
LineTokens.defaultTokenMetadata = (0 << 10 | 1 << 14 | 2 << 23) >>> 0;
var SliceLineTokens = class _SliceLineTokens {
  constructor(source, startOffset, endOffset, deltaOffset) {
    this._source = source;
    this._startOffset = startOffset;
    this._endOffset = endOffset;
    this._deltaOffset = deltaOffset;
    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
    this._tokensCount = 0;
    for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
      const tokenStartOffset = source.getStartOffset(i);
      if (tokenStartOffset >= endOffset) {
        break;
      }
      this._tokensCount++;
    }
  }
  getMetadata(tokenIndex) {
    return this._source.getMetadata(this._firstTokenIndex + tokenIndex);
  }
  getLanguageId(tokenIndex) {
    return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);
  }
  getLineContent() {
    return this._source.getLineContent().substring(this._startOffset, this._endOffset);
  }
  equals(other) {
    if (other instanceof _SliceLineTokens) {
      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);
    }
    return false;
  }
  getCount() {
    return this._tokensCount;
  }
  getForeground(tokenIndex) {
    return this._source.getForeground(this._firstTokenIndex + tokenIndex);
  }
  getEndOffset(tokenIndex) {
    const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
  }
  getClassName(tokenIndex) {
    return this._source.getClassName(this._firstTokenIndex + tokenIndex);
  }
  getInlineStyle(tokenIndex, colorMap) {
    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
  }
  getPresentation(tokenIndex) {
    return this._source.getPresentation(this._firstTokenIndex + tokenIndex);
  }
  findTokenIndexAtOffset(offset) {
    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/mime.js
var Mimes;
(function(Mimes2) {
  Mimes2.text = "text/plain";
  Mimes2.binary = "application/octet-stream";
  Mimes2.unknown = "application/unknown";
  Mimes2.markdown = "text/markdown";
  Mimes2.latex = "text/latex";
  Mimes2.uriList = "text/uri-list";
})(Mimes || (Mimes = {}));

// node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js
var BracketInfo = class {
  constructor(range2, nestingLevel, isInvalid) {
    this.range = range2;
    this.nestingLevel = nestingLevel;
    this.isInvalid = isInvalid;
  }
};
var BracketPairInfo = class {
  constructor(range2, openingBracketRange, closingBracketRange, nestingLevel) {
    this.range = range2;
    this.openingBracketRange = openingBracketRange;
    this.closingBracketRange = closingBracketRange;
    this.nestingLevel = nestingLevel;
  }
};
var BracketPairWithMinIndentationInfo = class extends BracketPairInfo {
  constructor(range2, openingBracketRange, closingBracketRange, nestingLevel, minVisibleColumnIndentation) {
    super(range2, openingBracketRange, closingBracketRange, nestingLevel);
    this.minVisibleColumnIndentation = minVisibleColumnIndentation;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js
var LengthObj = class {
  constructor(lineCount, columnCount) {
    this.lineCount = lineCount;
    this.columnCount = columnCount;
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
};
LengthObj.zero = new LengthObj(0, 0);
function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {
  return startLineCount !== endLineCount ? toLength(endLineCount - startLineCount, endColumnCount) : toLength(0, endColumnCount - startColumnCount);
}
var lengthZero = 0;
function lengthIsZero(length) {
  return length === 0;
}
var factor = (
  /* is debug: */
  false ? 1e5 : Math.pow(2, 26)
);
function toLength(lineCount, columnCount) {
  return lineCount * factor + columnCount;
}
function lengthToObj(length) {
  const l = length;
  const lineCount = Math.floor(l / factor);
  const columnCount = l - lineCount * factor;
  return new LengthObj(lineCount, columnCount);
}
function lengthGetLineCount(length) {
  return Math.floor(length / factor);
}
function lengthGetColumnCountIfZeroLineCount(length) {
  return length;
}
function lengthAdd(l1, l2) {
  return l2 < factor ? l1 + l2 : l1 - l1 % factor + l2;
}
function lengthDiffNonNegative(length1, length2) {
  const l1 = length1;
  const l2 = length2;
  const diff = l2 - l1;
  if (diff <= 0) {
    return lengthZero;
  }
  const lineCount1 = Math.floor(l1 / factor);
  const lineCount2 = Math.floor(l2 / factor);
  const colCount2 = l2 - lineCount2 * factor;
  if (lineCount1 === lineCount2) {
    const colCount1 = l1 - lineCount1 * factor;
    return toLength(0, colCount2 - colCount1);
  } else {
    return toLength(lineCount2 - lineCount1, colCount2);
  }
}
function lengthLessThan(length1, length2) {
  return length1 < length2;
}
function lengthLessThanEqual(length1, length2) {
  return length1 <= length2;
}
function lengthGreaterThanEqual(length1, length2) {
  return length1 >= length2;
}
function positionToLength(position) {
  return toLength(position.lineNumber - 1, position.column - 1);
}
function lengthsToRange(lengthStart, lengthEnd) {
  const l = lengthStart;
  const lineCount = Math.floor(l / factor);
  const colCount = l - lineCount * factor;
  const l2 = lengthEnd;
  const lineCount2 = Math.floor(l2 / factor);
  const colCount2 = l2 - lineCount2 * factor;
  return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);
}
function lengthOfString(str) {
  const lines = splitLines(str);
  return toLength(lines.length - 1, lines[lines.length - 1].length);
}

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js
var TextEditInfo = class {
  constructor(startOffset, endOffset, newLength) {
    this.startOffset = startOffset;
    this.endOffset = endOffset;
    this.newLength = newLength;
  }
};
var BeforeEditPositionMapper = class {
  /**
   * @param edits Must be sorted by offset in ascending order.
  */
  constructor(edits, documentLength) {
    this.documentLength = documentLength;
    this.nextEditIdx = 0;
    this.deltaOldToNewLineCount = 0;
    this.deltaOldToNewColumnCount = 0;
    this.deltaLineIdxInOld = -1;
    this.edits = edits.map((edit) => TextEditInfoCache.from(edit));
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
  */
  getOffsetBeforeChange(offset) {
    this.adjustNextEdit(offset);
    return this.translateCurToOld(offset);
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
  */
  getDistanceToNextChange(offset) {
    this.adjustNextEdit(offset);
    const nextEdit = this.edits[this.nextEditIdx];
    const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;
    return lengthDiffNonNegative(offset, nextChangeOffset);
  }
  translateOldToCur(oldOffsetObj) {
    if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {
      return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);
    } else {
      return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);
    }
  }
  translateCurToOld(newOffset) {
    const offsetObj = lengthToObj(newOffset);
    if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {
      return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);
    } else {
      return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);
    }
  }
  adjustNextEdit(offset) {
    while (this.nextEditIdx < this.edits.length) {
      const nextEdit = this.edits[this.nextEditIdx];
      const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);
      if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {
        this.nextEditIdx++;
        const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);
        const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));
        const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;
        this.deltaOldToNewLineCount += lineDelta;
        const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;
        const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;
        this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;
        this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;
      } else {
        break;
      }
    }
  }
};
var TextEditInfoCache = class _TextEditInfoCache {
  constructor(startOffset, endOffset, textLength) {
    this.endOffsetBeforeObj = lengthToObj(endOffset);
    this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));
    this.offsetObj = lengthToObj(startOffset);
  }
  static from(edit) {
    return new _TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js
var CursorColumns = class _CursorColumns {
  static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {
    if (codePoint === 9) {
      return _CursorColumns.nextRenderTabStop(visibleColumn, tabSize);
    }
    if (isFullWidthCharacter(codePoint) || isEmojiImprecise(codePoint)) {
      return visibleColumn + 2;
    }
    return visibleColumn + 1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  static visibleColumnFromColumn(lineContent, column, tabSize) {
    const textLen = Math.min(column - 1, lineContent.length);
    const text = lineContent.substring(0, textLen);
    const iterator = new GraphemeIterator(text);
    let result = 0;
    while (!iterator.eol()) {
      const codePoint = getNextCodePoint(text, textLen, iterator.offset);
      iterator.nextGraphemeLength();
      result = this._nextVisibleColumn(codePoint, result, tabSize);
    }
    return result;
  }
  /**
   * Returns a column from a visible column.
   * @see {@link CursorColumns}
   */
  static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {
    if (visibleColumn <= 0) {
      return 1;
    }
    const lineContentLength = lineContent.length;
    const iterator = new GraphemeIterator(lineContent);
    let beforeVisibleColumn = 0;
    let beforeColumn = 1;
    while (!iterator.eol()) {
      const codePoint = getNextCodePoint(lineContent, lineContentLength, iterator.offset);
      iterator.nextGraphemeLength();
      const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);
      const afterColumn = iterator.offset + 1;
      if (afterVisibleColumn >= visibleColumn) {
        const beforeDelta = visibleColumn - beforeVisibleColumn;
        const afterDelta = afterVisibleColumn - visibleColumn;
        if (afterDelta < beforeDelta) {
          return afterColumn;
        } else {
          return beforeColumn;
        }
      }
      beforeVisibleColumn = afterVisibleColumn;
      beforeColumn = afterColumn;
    }
    return lineContentLength + 1;
  }
  /**
   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextRenderTabStop(visibleColumn, tabSize) {
    return visibleColumn + tabSize - visibleColumn % tabSize;
  }
  /**
   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextIndentTabStop(visibleColumn, indentSize) {
    return visibleColumn + indentSize - visibleColumn % indentSize;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevRenderTabStop(column, tabSize) {
    return Math.max(0, column - 1 - (column - 1) % tabSize);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevIndentTabStop(column, indentSize) {
    return Math.max(0, column - 1 - (column - 1) % indentSize);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js
var emptyArr = new Array();
var SmallImmutableSet = class _SmallImmutableSet {
  constructor(items, additionalItems) {
    this.items = items;
    this.additionalItems = additionalItems;
  }
  static create(items, additionalItems) {
    if (items <= 128 && additionalItems.length === 0) {
      let cached = _SmallImmutableSet.cache[items];
      if (!cached) {
        cached = new _SmallImmutableSet(items, additionalItems);
        _SmallImmutableSet.cache[items] = cached;
      }
      return cached;
    }
    return new _SmallImmutableSet(items, additionalItems);
  }
  static getEmpty() {
    return this.empty;
  }
  add(value, keyProvider) {
    const key = keyProvider.getKey(value);
    let idx = key >> 5;
    if (idx === 0) {
      const newItem = 1 << key | this.items;
      if (newItem === this.items) {
        return this;
      }
      return _SmallImmutableSet.create(newItem, this.additionalItems);
    }
    idx--;
    const newItems = this.additionalItems.slice(0);
    while (newItems.length < idx) {
      newItems.push(0);
    }
    newItems[idx] |= 1 << (key & 31);
    return _SmallImmutableSet.create(this.items, newItems);
  }
  merge(other) {
    const merged = this.items | other.items;
    if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {
      if (merged === this.items) {
        return this;
      }
      if (merged === other.items) {
        return other;
      }
      return _SmallImmutableSet.create(merged, emptyArr);
    }
    const newItems = new Array();
    for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {
      const item1 = this.additionalItems[i] || 0;
      const item2 = other.additionalItems[i] || 0;
      newItems.push(item1 | item2);
    }
    return _SmallImmutableSet.create(merged, newItems);
  }
  intersects(other) {
    if ((this.items & other.items) !== 0) {
      return true;
    }
    for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {
      if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {
        return true;
      }
    }
    return false;
  }
};
SmallImmutableSet.cache = new Array(129);
SmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);
var identityKeyProvider = {
  getKey(value) {
    return value;
  }
};
var DenseKeyProvider = class {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  getKey(value) {
    let existing = this.items.get(value);
    if (existing === void 0) {
      existing = this.items.size;
      this.items.set(value, existing);
    }
    return existing;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js
var BaseAstNode = class {
  constructor(length) {
    this._length = length;
  }
  /**
   * The length of the entire node, which should equal the sum of lengths of all children.
  */
  get length() {
    return this._length;
  }
};
var PairAstNode = class _PairAstNode extends BaseAstNode {
  constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {
    super(length);
    this.openingBracket = openingBracket;
    this.child = child;
    this.closingBracket = closingBracket;
    this.missingOpeningBracketIds = missingOpeningBracketIds;
  }
  static create(openingBracket, child, closingBracket) {
    let length = openingBracket.length;
    if (child) {
      length = lengthAdd(length, child.length);
    }
    if (closingBracket) {
      length = lengthAdd(length, closingBracket.length);
    }
    return new _PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());
  }
  get kind() {
    return 2;
  }
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 3;
  }
  getChild(idx) {
    switch (idx) {
      case 0:
        return this.openingBracket;
      case 1:
        return this.child;
      case 2:
        return this.closingBracket;
    }
    throw new Error("Invalid child index");
  }
  /**
   * Avoid using this property, it allocates an array!
  */
  get children() {
    const result = new Array();
    result.push(this.openingBracket);
    if (this.child) {
      result.push(this.child);
    }
    if (this.closingBracket) {
      result.push(this.closingBracket);
    }
    return result;
  }
  canBeReused(openBracketIds) {
    if (this.closingBracket === null) {
      return false;
    }
    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {
      return false;
    }
    return true;
  }
  deepClone() {
    return new _PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
  }
  computeMinIndentation(offset, textModel) {
    return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;
  }
};
var ListAstNode = class extends BaseAstNode {
  /**
   * Use ListAstNode.create.
  */
  constructor(length, listHeight, _missingOpeningBracketIds) {
    super(length);
    this.listHeight = listHeight;
    this._missingOpeningBracketIds = _missingOpeningBracketIds;
    this.cachedMinIndentation = -1;
  }
  /**
   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
  */
  static create23(item1, item2, item3, immutable = false) {
    let length = item1.length;
    let missingBracketIds = item1.missingOpeningBracketIds;
    if (item1.listHeight !== item2.listHeight) {
      throw new Error("Invalid list heights");
    }
    length = lengthAdd(length, item2.length);
    missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);
    if (item3) {
      if (item1.listHeight !== item3.listHeight) {
        throw new Error("Invalid list heights");
      }
      length = lengthAdd(length, item3.length);
      missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);
    }
    return immutable ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds) : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);
  }
  static getEmpty() {
    return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());
  }
  get kind() {
    return 4;
  }
  get missingOpeningBracketIds() {
    return this._missingOpeningBracketIds;
  }
  throwIfImmutable() {
  }
  makeLastElementMutable() {
    this.throwIfImmutable();
    const childCount = this.childrenLength;
    if (childCount === 0) {
      return void 0;
    }
    const lastChild = this.getChild(childCount - 1);
    const mutable = lastChild.kind === 4 ? lastChild.toMutable() : lastChild;
    if (lastChild !== mutable) {
      this.setChild(childCount - 1, mutable);
    }
    return mutable;
  }
  makeFirstElementMutable() {
    this.throwIfImmutable();
    const childCount = this.childrenLength;
    if (childCount === 0) {
      return void 0;
    }
    const firstChild = this.getChild(0);
    const mutable = firstChild.kind === 4 ? firstChild.toMutable() : firstChild;
    if (firstChild !== mutable) {
      this.setChild(0, mutable);
    }
    return mutable;
  }
  canBeReused(openBracketIds) {
    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {
      return false;
    }
    let lastChild = this;
    let lastLength;
    while (lastChild.kind === 4 && (lastLength = lastChild.childrenLength) > 0) {
      lastChild = lastChild.getChild(lastLength - 1);
    }
    return lastChild.canBeReused(openBracketIds);
  }
  handleChildrenChanged() {
    this.throwIfImmutable();
    const count = this.childrenLength;
    let length = this.getChild(0).length;
    let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;
    for (let i = 1; i < count; i++) {
      const child = this.getChild(i);
      length = lengthAdd(length, child.length);
      unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);
    }
    this._length = length;
    this._missingOpeningBracketIds = unopenedBrackets;
    this.cachedMinIndentation = -1;
  }
  computeMinIndentation(offset, textModel) {
    if (this.cachedMinIndentation !== -1) {
      return this.cachedMinIndentation;
    }
    let minIndentation = Number.MAX_SAFE_INTEGER;
    let childOffset = offset;
    for (let i = 0; i < this.childrenLength; i++) {
      const child = this.getChild(i);
      if (child) {
        minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));
        childOffset = lengthAdd(childOffset, child.length);
      }
    }
    this.cachedMinIndentation = minIndentation;
    return minIndentation;
  }
};
var TwoThreeListAstNode = class _TwoThreeListAstNode extends ListAstNode {
  constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {
    super(length, listHeight, missingOpeningBracketIds);
    this._item1 = _item1;
    this._item2 = _item2;
    this._item3 = _item3;
  }
  get childrenLength() {
    return this._item3 !== null ? 3 : 2;
  }
  getChild(idx) {
    switch (idx) {
      case 0:
        return this._item1;
      case 1:
        return this._item2;
      case 2:
        return this._item3;
    }
    throw new Error("Invalid child index");
  }
  setChild(idx, node) {
    switch (idx) {
      case 0:
        this._item1 = node;
        return;
      case 1:
        this._item2 = node;
        return;
      case 2:
        this._item3 = node;
        return;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
  }
  get item1() {
    return this._item1;
  }
  get item2() {
    return this._item2;
  }
  get item3() {
    return this._item3;
  }
  deepClone() {
    return new _TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(node) {
    if (this._item3) {
      throw new Error("Cannot append to a full (2,3) tree node");
    }
    this.throwIfImmutable();
    this._item3 = node;
    this.handleChildrenChanged();
  }
  unappendChild() {
    if (!this._item3) {
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    }
    this.throwIfImmutable();
    const result = this._item3;
    this._item3 = null;
    this.handleChildrenChanged();
    return result;
  }
  prependChildOfSameHeight(node) {
    if (this._item3) {
      throw new Error("Cannot prepend to a full (2,3) tree node");
    }
    this.throwIfImmutable();
    this._item3 = this._item2;
    this._item2 = this._item1;
    this._item1 = node;
    this.handleChildrenChanged();
  }
  unprependChild() {
    if (!this._item3) {
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    }
    this.throwIfImmutable();
    const result = this._item1;
    this._item1 = this._item2;
    this._item2 = this._item3;
    this._item3 = null;
    this.handleChildrenChanged();
    return result;
  }
  toMutable() {
    return this;
  }
};
var Immutable23ListAstNode = class extends TwoThreeListAstNode {
  toMutable() {
    return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
};
var ArrayListAstNode = class _ArrayListAstNode extends ListAstNode {
  constructor(length, listHeight, _children, missingOpeningBracketIds) {
    super(length, listHeight, missingOpeningBracketIds);
    this._children = _children;
  }
  get childrenLength() {
    return this._children.length;
  }
  getChild(idx) {
    return this._children[idx];
  }
  setChild(idx, child) {
    this._children[idx] = child;
  }
  get children() {
    return this._children;
  }
  deepClone() {
    const children = new Array(this._children.length);
    for (let i = 0; i < this._children.length; i++) {
      children[i] = this._children[i].deepClone();
    }
    return new _ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(node) {
    this.throwIfImmutable();
    this._children.push(node);
    this.handleChildrenChanged();
  }
  unappendChild() {
    this.throwIfImmutable();
    const item = this._children.pop();
    this.handleChildrenChanged();
    return item;
  }
  prependChildOfSameHeight(node) {
    this.throwIfImmutable();
    this._children.unshift(node);
    this.handleChildrenChanged();
  }
  unprependChild() {
    this.throwIfImmutable();
    const item = this._children.shift();
    this.handleChildrenChanged();
    return item;
  }
  toMutable() {
    return this;
  }
};
var ImmutableArrayListAstNode = class extends ArrayListAstNode {
  toMutable() {
    return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
};
var emptyArray = [];
var ImmutableLeafAstNode = class extends BaseAstNode {
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 0;
  }
  getChild(idx) {
    return null;
  }
  get children() {
    return emptyArray;
  }
  deepClone() {
    return this;
  }
};
var TextAstNode = class extends ImmutableLeafAstNode {
  get kind() {
    return 0;
  }
  get missingOpeningBracketIds() {
    return SmallImmutableSet.getEmpty();
  }
  canBeReused(_openedBracketIds) {
    return true;
  }
  computeMinIndentation(offset, textModel) {
    const start = lengthToObj(offset);
    const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;
    const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;
    let result = Number.MAX_SAFE_INTEGER;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);
      const lineContent = textModel.getLineContent(lineNumber);
      if (firstNonWsColumn === 0) {
        continue;
      }
      const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);
      result = Math.min(result, visibleColumn);
    }
    return result;
  }
};
var BracketAstNode = class _BracketAstNode extends ImmutableLeafAstNode {
  constructor(length, languageId, bracketIds) {
    super(length);
    this.languageId = languageId;
    this.bracketIds = bracketIds;
  }
  static create(length, languageId, bracketIds) {
    const node = new _BracketAstNode(length, languageId, bracketIds);
    return node;
  }
  get kind() {
    return 1;
  }
  get missingOpeningBracketIds() {
    return SmallImmutableSet.getEmpty();
  }
  canBeReused(_openedBracketIds) {
    return false;
  }
  computeMinIndentation(offset, textModel) {
    return Number.MAX_SAFE_INTEGER;
  }
};
var InvalidBracketAstNode = class extends ImmutableLeafAstNode {
  constructor(closingBrackets, length) {
    super(length);
    this.missingOpeningBracketIds = closingBrackets;
  }
  get kind() {
    return 3;
  }
  canBeReused(openedBracketIds) {
    return !openedBracketIds.intersects(this.missingOpeningBracketIds);
  }
  computeMinIndentation(offset, textModel) {
    return Number.MAX_SAFE_INTEGER;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js
var Token2 = class {
  constructor(length, kind, bracketId, bracketIds, astNode) {
    this.length = length;
    this.kind = kind;
    this.bracketId = bracketId;
    this.bracketIds = bracketIds;
    this.astNode = astNode;
  }
};
var TextBufferTokenizer = class {
  constructor(textModel, bracketTokens) {
    this.textModel = textModel;
    this.bracketTokens = bracketTokens;
    this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);
    this._offset = lengthZero;
    this.didPeek = false;
    this.peeked = null;
    this.textBufferLineCount = textModel.getLineCount();
    this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
  }
  get offset() {
    return this._offset;
  }
  get length() {
    return toLength(this.textBufferLineCount, this.textBufferLastLineLength);
  }
  skip(length) {
    this.didPeek = false;
    this._offset = lengthAdd(this._offset, length);
    const obj = lengthToObj(this._offset);
    this.reader.setPosition(obj.lineCount, obj.columnCount);
  }
  read() {
    let token;
    if (this.peeked) {
      this.didPeek = false;
      token = this.peeked;
    } else {
      token = this.reader.read();
    }
    if (token) {
      this._offset = lengthAdd(this._offset, token.length);
    }
    return token;
  }
  peek() {
    if (!this.didPeek) {
      this.peeked = this.reader.read();
      this.didPeek = true;
    }
    return this.peeked;
  }
};
var NonPeekableTextBufferTokenizer = class {
  constructor(textModel, bracketTokens) {
    this.textModel = textModel;
    this.bracketTokens = bracketTokens;
    this.lineIdx = 0;
    this.line = null;
    this.lineCharOffset = 0;
    this.lineTokens = null;
    this.lineTokenOffset = 0;
    this.peekedToken = null;
    this.textBufferLineCount = textModel.getLineCount();
    this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
  }
  setPosition(lineIdx, column) {
    if (lineIdx === this.lineIdx) {
      this.lineCharOffset = column;
      this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);
    } else {
      this.lineIdx = lineIdx;
      this.lineCharOffset = column;
      this.line = null;
    }
    this.peekedToken = null;
  }
  read() {
    if (this.peekedToken) {
      const token = this.peekedToken;
      this.peekedToken = null;
      this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);
      return token;
    }
    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength) {
      return null;
    }
    if (this.line === null) {
      this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);
      this.line = this.lineTokens.getLineContent();
      this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);
    }
    const startLineIdx = this.lineIdx;
    const startLineCharOffset = this.lineCharOffset;
    let lengthHeuristic = 0;
    while (true) {
      const lineTokens = this.lineTokens;
      const tokenCount = lineTokens.getCount();
      let peekedBracketToken = null;
      if (this.lineTokenOffset < tokenCount) {
        const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);
        while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {
          this.lineTokenOffset++;
        }
        const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0;
        const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);
        if (isOther && endOffset !== this.lineCharOffset) {
          const languageId = lineTokens.getLanguageId(this.lineTokenOffset);
          const text = this.line.substring(this.lineCharOffset, endOffset);
          const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);
          const regexp = brackets.regExpGlobal;
          if (regexp) {
            regexp.lastIndex = 0;
            const match = regexp.exec(text);
            if (match) {
              peekedBracketToken = brackets.getToken(match[0]);
              if (peekedBracketToken) {
                this.lineCharOffset += match.index;
              }
            }
          }
        }
        lengthHeuristic += endOffset - this.lineCharOffset;
        if (peekedBracketToken) {
          if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {
            this.peekedToken = peekedBracketToken;
            break;
          } else {
            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);
            return peekedBracketToken;
          }
        } else {
          this.lineTokenOffset++;
          this.lineCharOffset = endOffset;
        }
      } else {
        if (this.lineIdx === this.textBufferLineCount - 1) {
          break;
        }
        this.lineIdx++;
        this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);
        this.lineTokenOffset = 0;
        this.line = this.lineTokens.getLineContent();
        this.lineCharOffset = 0;
        lengthHeuristic += 33;
        if (lengthHeuristic > 1e3) {
          break;
        }
      }
      if (lengthHeuristic > 1500) {
        break;
      }
    }
    const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);
    return new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));
  }
};
var FastTokenizer = class {
  constructor(text, brackets) {
    this.text = text;
    this._offset = lengthZero;
    this.idx = 0;
    const regExpStr = brackets.getRegExpStr();
    const regexp = regExpStr ? new RegExp(brackets.getRegExpStr() + "|\n", "g") : null;
    const tokens = [];
    let match;
    let curLineCount = 0;
    let lastLineBreakOffset = 0;
    let lastTokenEndOffset = 0;
    let lastTokenEndLine = 0;
    const smallTextTokens0Line = new Array();
    for (let i = 0; i < 60; i++) {
      smallTextTokens0Line.push(new Token2(toLength(0, i), 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));
    }
    const smallTextTokens1Line = new Array();
    for (let i = 0; i < 60; i++) {
      smallTextTokens1Line.push(new Token2(toLength(1, i), 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));
    }
    if (regexp) {
      regexp.lastIndex = 0;
      while ((match = regexp.exec(text)) !== null) {
        const curOffset = match.index;
        const value = match[0];
        if (value === "\n") {
          curLineCount++;
          lastLineBreakOffset = curOffset + 1;
        } else {
          if (lastTokenEndOffset !== curOffset) {
            let token;
            if (lastTokenEndLine === curLineCount) {
              const colCount = curOffset - lastTokenEndOffset;
              if (colCount < smallTextTokens0Line.length) {
                token = smallTextTokens0Line[colCount];
              } else {
                const length = toLength(0, colCount);
                token = new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));
              }
            } else {
              const lineCount = curLineCount - lastTokenEndLine;
              const colCount = curOffset - lastLineBreakOffset;
              if (lineCount === 1 && colCount < smallTextTokens1Line.length) {
                token = smallTextTokens1Line[colCount];
              } else {
                const length = toLength(lineCount, colCount);
                token = new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));
              }
            }
            tokens.push(token);
          }
          tokens.push(brackets.getToken(value));
          lastTokenEndOffset = curOffset + value.length;
          lastTokenEndLine = curLineCount;
        }
      }
    }
    const offset = text.length;
    if (lastTokenEndOffset !== offset) {
      const length = lastTokenEndLine === curLineCount ? toLength(0, offset - lastTokenEndOffset) : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);
      tokens.push(new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));
    }
    this.length = toLength(curLineCount, offset - lastLineBreakOffset);
    this.tokens = tokens;
  }
  get offset() {
    return this._offset;
  }
  read() {
    return this.tokens[this.idx++] || null;
  }
  peek() {
    return this.tokens[this.idx] || null;
  }
  skip(length) {
    throw new NotSupportedError();
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js
var BracketTokens = class _BracketTokens {
  constructor(map) {
    this.map = map;
    this.hasRegExp = false;
    this._regExpGlobal = null;
  }
  static createFromLanguage(configuration, denseKeyProvider) {
    function getId(languageId, openingText) {
      return denseKeyProvider.getKey(`${languageId}:::${openingText}`);
    }
    const brackets = configuration.characterPair.getColorizedBrackets();
    const closingBrackets = /* @__PURE__ */ new Map();
    const openingBrackets = /* @__PURE__ */ new Set();
    for (const [openingText, closingText] of brackets) {
      openingBrackets.add(openingText);
      let info = closingBrackets.get(closingText);
      const openingTextId = getId(configuration.languageId, openingText);
      if (!info) {
        info = { openingBrackets: SmallImmutableSet.getEmpty(), first: openingTextId };
        closingBrackets.set(closingText, info);
      }
      info.openingBrackets = info.openingBrackets.add(openingTextId, identityKeyProvider);
    }
    const map = /* @__PURE__ */ new Map();
    for (const [closingText, info] of closingBrackets) {
      const length = toLength(0, closingText.length);
      map.set(closingText, new Token2(length, 2, info.first, info.openingBrackets, BracketAstNode.create(length, configuration.languageId, info.openingBrackets)));
    }
    for (const openingText of openingBrackets) {
      const length = toLength(0, openingText.length);
      const openingTextId = getId(configuration.languageId, openingText);
      const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);
      map.set(openingText, new Token2(length, 1, openingTextId, bracketIds, BracketAstNode.create(length, configuration.languageId, bracketIds)));
    }
    return new _BracketTokens(map);
  }
  getRegExpStr() {
    if (this.isEmpty) {
      return null;
    } else {
      const keys = [...this.map.keys()];
      keys.sort();
      keys.reverse();
      return keys.map((k) => prepareBracketForRegExp2(k)).join("|");
    }
  }
  /**
   * Returns null if there is no such regexp (because there are no brackets).
  */
  get regExpGlobal() {
    if (!this.hasRegExp) {
      const regExpStr = this.getRegExpStr();
      this._regExpGlobal = regExpStr ? new RegExp(regExpStr, "g") : null;
      this.hasRegExp = true;
    }
    return this._regExpGlobal;
  }
  getToken(value) {
    return this.map.get(value);
  }
  findClosingTokenText(openingBracketIds) {
    for (const [closingText, info] of this.map) {
      if (info.bracketIds.intersects(openingBracketIds)) {
        return closingText;
      }
    }
    return void 0;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
};
function prepareBracketForRegExp2(str) {
  const escaped = escapeRegExpCharacters(str);
  const needsWordBoundaries = /^[\w ]+$/.test(str);
  return needsWordBoundaries ? `\\b${escaped}\\b` : escaped;
}
var LanguageAgnosticBracketTokens = class {
  constructor(denseKeyProvider, getLanguageConfiguration) {
    this.denseKeyProvider = denseKeyProvider;
    this.getLanguageConfiguration = getLanguageConfiguration;
    this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
  }
  didLanguageChange(languageId) {
    const existing = this.languageIdToBracketTokens.get(languageId);
    if (!existing) {
      return false;
    }
    const newRegExpStr = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider).getRegExpStr();
    return existing.getRegExpStr() !== newRegExpStr;
  }
  getSingleLanguageBracketTokens(languageId) {
    let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);
    if (!singleLanguageBracketTokens) {
      singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);
      this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);
    }
    return singleLanguageBracketTokens;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js
function concat23Trees(items) {
  if (items.length === 0) {
    return null;
  }
  if (items.length === 1) {
    return items[0];
  }
  let i = 0;
  function readNode() {
    if (i >= items.length) {
      return null;
    }
    const start = i;
    const height = items[start].listHeight;
    i++;
    while (i < items.length && items[i].listHeight === height) {
      i++;
    }
    if (i - start >= 2) {
      return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);
    } else {
      return items[start];
    }
  }
  let first = readNode();
  let second = readNode();
  if (!second) {
    return first;
  }
  for (let item = readNode(); item; item = readNode()) {
    if (heightDiff(first, second) <= heightDiff(second, item)) {
      first = concat(first, second);
      second = item;
    } else {
      second = concat(second, item);
    }
  }
  const result = concat(first, second);
  return result;
}
function concat23TreesOfSameHeight(items, createImmutableLists = false) {
  if (items.length === 0) {
    return null;
  }
  if (items.length === 1) {
    return items[0];
  }
  let length = items.length;
  while (length > 3) {
    const newLength = length >> 1;
    for (let i = 0; i < newLength; i++) {
      const j = i << 1;
      items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);
    }
    length = newLength;
  }
  return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);
}
function heightDiff(node1, node2) {
  return Math.abs(node1.listHeight - node2.listHeight);
}
function concat(node1, node2) {
  if (node1.listHeight === node2.listHeight) {
    return ListAstNode.create23(node1, node2, null, false);
  } else if (node1.listHeight > node2.listHeight) {
    return append2(node1, node2);
  } else {
    return prepend(node2, node1);
  }
}
function append2(list, nodeToAppend) {
  list = list.toMutable();
  let curNode = list;
  const parents = new Array();
  let nodeToAppendOfCorrectHeight;
  while (true) {
    if (nodeToAppend.listHeight === curNode.listHeight) {
      nodeToAppendOfCorrectHeight = nodeToAppend;
      break;
    }
    if (curNode.kind !== 4) {
      throw new Error("unexpected");
    }
    parents.push(curNode);
    curNode = curNode.makeLastElementMutable();
  }
  for (let i = parents.length - 1; i >= 0; i--) {
    const parent = parents[i];
    if (nodeToAppendOfCorrectHeight) {
      if (parent.childrenLength >= 3) {
        nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);
      } else {
        parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);
        nodeToAppendOfCorrectHeight = void 0;
      }
    } else {
      parent.handleChildrenChanged();
    }
  }
  if (nodeToAppendOfCorrectHeight) {
    return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);
  } else {
    return list;
  }
}
function prepend(list, nodeToAppend) {
  list = list.toMutable();
  let curNode = list;
  const parents = new Array();
  while (nodeToAppend.listHeight !== curNode.listHeight) {
    if (curNode.kind !== 4) {
      throw new Error("unexpected");
    }
    parents.push(curNode);
    curNode = curNode.makeFirstElementMutable();
  }
  let nodeToPrependOfCorrectHeight = nodeToAppend;
  for (let i = parents.length - 1; i >= 0; i--) {
    const parent = parents[i];
    if (nodeToPrependOfCorrectHeight) {
      if (parent.childrenLength >= 3) {
        nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);
      } else {
        parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);
        nodeToPrependOfCorrectHeight = void 0;
      }
    } else {
      parent.handleChildrenChanged();
    }
  }
  if (nodeToPrependOfCorrectHeight) {
    return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);
  } else {
    return list;
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js
var NodeReader = class {
  constructor(node) {
    this.lastOffset = lengthZero;
    this.nextNodes = [node];
    this.offsets = [lengthZero];
    this.idxs = [];
  }
  /**
   * Returns the longest node at `offset` that satisfies the predicate.
   * @param offset must be greater than or equal to the last offset this method has been called with!
  */
  readLongestNodeAt(offset, predicate) {
    if (lengthLessThan(offset, this.lastOffset)) {
      throw new Error("Invalid offset");
    }
    this.lastOffset = offset;
    while (true) {
      const curNode = lastOrUndefined(this.nextNodes);
      if (!curNode) {
        return void 0;
      }
      const curNodeOffset = lastOrUndefined(this.offsets);
      if (lengthLessThan(offset, curNodeOffset)) {
        return void 0;
      }
      if (lengthLessThan(curNodeOffset, offset)) {
        if (lengthAdd(curNodeOffset, curNode.length) <= offset) {
          this.nextNodeAfterCurrent();
        } else {
          const nextChildIdx = getNextChildIdx(curNode);
          if (nextChildIdx !== -1) {
            this.nextNodes.push(curNode.getChild(nextChildIdx));
            this.offsets.push(curNodeOffset);
            this.idxs.push(nextChildIdx);
          } else {
            this.nextNodeAfterCurrent();
          }
        }
      } else {
        if (predicate(curNode)) {
          this.nextNodeAfterCurrent();
          return curNode;
        } else {
          const nextChildIdx = getNextChildIdx(curNode);
          if (nextChildIdx === -1) {
            this.nextNodeAfterCurrent();
            return void 0;
          } else {
            this.nextNodes.push(curNode.getChild(nextChildIdx));
            this.offsets.push(curNodeOffset);
            this.idxs.push(nextChildIdx);
          }
        }
      }
    }
  }
  // Navigates to the longest node that continues after the current node.
  nextNodeAfterCurrent() {
    while (true) {
      const currentOffset = lastOrUndefined(this.offsets);
      const currentNode = lastOrUndefined(this.nextNodes);
      this.nextNodes.pop();
      this.offsets.pop();
      if (this.idxs.length === 0) {
        break;
      }
      const parent = lastOrUndefined(this.nextNodes);
      const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);
      if (nextChildIdx !== -1) {
        this.nextNodes.push(parent.getChild(nextChildIdx));
        this.offsets.push(lengthAdd(currentOffset, currentNode.length));
        this.idxs[this.idxs.length - 1] = nextChildIdx;
        break;
      } else {
        this.idxs.pop();
      }
    }
  }
};
function getNextChildIdx(node, curIdx = -1) {
  while (true) {
    curIdx++;
    if (curIdx >= node.childrenLength) {
      return -1;
    }
    if (node.getChild(curIdx)) {
      return curIdx;
    }
  }
}
function lastOrUndefined(arr) {
  return arr.length > 0 ? arr[arr.length - 1] : void 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js
function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {
  const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);
  return parser.parseDocument();
}
var Parser = class {
  constructor(tokenizer, edits, oldNode, createImmutableLists) {
    this.tokenizer = tokenizer;
    this.createImmutableLists = createImmutableLists;
    this._itemsConstructed = 0;
    this._itemsFromCache = 0;
    if (oldNode && createImmutableLists) {
      throw new Error("Not supported");
    }
    this.oldNodeReader = oldNode ? new NodeReader(oldNode) : void 0;
    this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);
  }
  parseDocument() {
    this._itemsConstructed = 0;
    this._itemsFromCache = 0;
    let result = this.parseList(SmallImmutableSet.getEmpty());
    if (!result) {
      result = ListAstNode.getEmpty();
    }
    return result;
  }
  parseList(openedBracketIds) {
    const items = new Array();
    while (true) {
      const token = this.tokenizer.peek();
      if (!token || token.kind === 2 && token.bracketIds.intersects(openedBracketIds)) {
        break;
      }
      const child = this.parseChild(openedBracketIds);
      if (child.kind === 4 && child.childrenLength === 0) {
        continue;
      }
      items.push(child);
    }
    const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);
    return result;
  }
  parseChild(openedBracketIds) {
    if (this.oldNodeReader) {
      const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
      if (!lengthIsZero(maxCacheableLength)) {
        const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (curNode) => {
          if (!lengthLessThan(curNode.length, maxCacheableLength)) {
            return false;
          }
          const canBeReused = curNode.canBeReused(openedBracketIds);
          return canBeReused;
        });
        if (cachedNode) {
          this._itemsFromCache++;
          this.tokenizer.skip(cachedNode.length);
          return cachedNode;
        }
      }
    }
    this._itemsConstructed++;
    const token = this.tokenizer.read();
    switch (token.kind) {
      case 2:
        return new InvalidBracketAstNode(token.bracketIds, token.length);
      case 0:
        return token.astNode;
      case 1: {
        const set = openedBracketIds.merge(token.bracketIds);
        const child = this.parseList(set);
        const nextToken = this.tokenizer.peek();
        if (nextToken && nextToken.kind === 2 && (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {
          this.tokenizer.read();
          return PairAstNode.create(token.astNode, child, nextToken.astNode);
        } else {
          return PairAstNode.create(token.astNode, child, null);
        }
      }
      default:
        throw new Error("unexpected");
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js
var BracketPairsTree = class extends Disposable {
  constructor(textModel, getLanguageConfiguration) {
    super();
    this.textModel = textModel;
    this.getLanguageConfiguration = getLanguageConfiguration;
    this.didChangeEmitter = new Emitter();
    this.denseKeyProvider = new DenseKeyProvider();
    this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);
    this.onDidChange = this.didChangeEmitter.event;
    if (textModel.backgroundTokenizationState === 0) {
      const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());
      const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);
      this.initialAstWithoutTokens = parseDocument(tokenizer, [], void 0, true);
      this.astWithTokens = this.initialAstWithoutTokens;
    } else if (textModel.backgroundTokenizationState === 2) {
      this.initialAstWithoutTokens = void 0;
      this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, false);
    } else if (textModel.backgroundTokenizationState === 1) {
      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, true);
      this.astWithTokens = this.initialAstWithoutTokens;
    }
  }
  didLanguageChange(languageId) {
    return this.brackets.didLanguageChange(languageId);
  }
  //#region TextModel events
  handleDidChangeBackgroundTokenizationState() {
    if (this.textModel.backgroundTokenizationState === 2) {
      const wasUndefined = this.initialAstWithoutTokens === void 0;
      this.initialAstWithoutTokens = void 0;
      if (!wasUndefined) {
        this.didChangeEmitter.fire();
      }
    }
  }
  handleDidChangeTokens({ ranges }) {
    const edits = ranges.map((r) => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));
    this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);
    if (!this.initialAstWithoutTokens) {
      this.didChangeEmitter.fire();
    }
  }
  handleContentChanged(change) {
    const edits = change.changes.map((c) => {
      const range2 = Range.lift(c.range);
      return new TextEditInfo(positionToLength(range2.getStartPosition()), positionToLength(range2.getEndPosition()), lengthOfString(c.text));
    }).reverse();
    this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);
    if (this.initialAstWithoutTokens) {
      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);
    }
  }
  //#endregion
  /**
   * @pure (only if isPure = true)
  */
  parseDocumentFromTextBuffer(edits, previousAst, immutable) {
    const isPure = false;
    const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;
    const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);
    const result = parseDocument(tokenizer, edits, previousAstClone, immutable);
    return result;
  }
  getBracketsInRange(range2) {
    const startOffset = toLength(range2.startLineNumber - 1, range2.startColumn - 1);
    const endOffset = toLength(range2.endLineNumber - 1, range2.endColumn - 1);
    const result = new Array();
    const node = this.initialAstWithoutTokens || this.astWithTokens;
    collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result);
    return result;
  }
  getBracketPairsInRange(range2, includeMinIndentation) {
    const result = new Array();
    const startLength = positionToLength(range2.getStartPosition());
    const endLength = positionToLength(range2.getEndPosition());
    const node = this.initialAstWithoutTokens || this.astWithTokens;
    const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);
    collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context);
    return result;
  }
};
function collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level = 0) {
  if (node.kind === 4) {
    for (const child of node.children) {
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);
      }
      nodeOffsetStart = nodeOffsetEnd;
    }
  } else if (node.kind === 2) {
    level++;
    {
      const child = node.openingBracket;
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
        const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
        result.push(new BracketInfo(range2, level - 1, !node.closingBracket));
      }
      nodeOffsetStart = nodeOffsetEnd;
    }
    if (node.child) {
      const child = node.child;
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);
      }
      nodeOffsetStart = nodeOffsetEnd;
    }
    if (node.closingBracket) {
      const child = node.closingBracket;
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
        const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
        result.push(new BracketInfo(range2, level - 1, false));
      }
      nodeOffsetStart = nodeOffsetEnd;
    }
  } else if (node.kind === 3) {
    const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
    result.push(new BracketInfo(range2, level - 1, true));
  } else if (node.kind === 1) {
    const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
    result.push(new BracketInfo(range2, level - 1, false));
  }
}
var CollectBracketPairsContext = class {
  constructor(result, includeMinIndentation, textModel) {
    this.result = result;
    this.includeMinIndentation = includeMinIndentation;
    this.textModel = textModel;
  }
};
function collectBracketPairs(node, nodeOffset, nodeOffsetEnd, startOffset, endOffset, context, level = 0) {
  var _a3;
  if (node.kind === 2) {
    const openingBracketEnd = lengthAdd(nodeOffset, node.openingBracket.length);
    let minIndentation = -1;
    if (context.includeMinIndentation) {
      minIndentation = node.computeMinIndentation(nodeOffset, context.textModel);
    }
    context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset, nodeOffsetEnd), lengthsToRange(nodeOffset, openingBracketEnd), node.closingBracket ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a3 = node.child) === null || _a3 === void 0 ? void 0 : _a3.length) || lengthZero), nodeOffsetEnd) : void 0, level, minIndentation));
    level++;
  }
  let curOffset = nodeOffset;
  for (const child of node.children) {
    const childOffset = curOffset;
    curOffset = lengthAdd(curOffset, child.length);
    if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {
      collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level);
    }
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js
var BracketPairsTextModelPart = class extends Disposable {
  constructor(textModel, languageConfigurationService) {
    super();
    this.textModel = textModel;
    this.languageConfigurationService = languageConfigurationService;
    this.bracketPairsTree = this._register(new MutableDisposable());
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.bracketsRequested = false;
    this._register(this.languageConfigurationService.onDidChange((e) => {
      var _a3;
      if (!e.languageId || ((_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.didLanguageChange(e.languageId))) {
        this.bracketPairsTree.clear();
        this.updateBracketPairsTree();
      }
    }));
  }
  get isDocumentSupported() {
    const maxSupportedDocumentLength = (
      /* max lines */
      5e4 * /* average column count */
      100
    );
    return this.textModel.getValueLength() <= maxSupportedDocumentLength;
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.bracketPairsTree.clear();
    this.updateBracketPairsTree();
  }
  handleDidChangeLanguage(e) {
    this.bracketPairsTree.clear();
    this.updateBracketPairsTree();
  }
  handleDidChangeContent(change) {
    var _a3;
    (_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.handleContentChanged(change);
  }
  handleDidChangeBackgroundTokenizationState() {
    var _a3;
    (_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.handleDidChangeBackgroundTokenizationState();
  }
  handleDidChangeTokens(e) {
    var _a3;
    (_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.handleDidChangeTokens(e);
  }
  //#endregion
  updateBracketPairsTree() {
    if (this.bracketsRequested && this.isDocumentSupported) {
      if (!this.bracketPairsTree.value) {
        const store = new DisposableStore();
        this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {
          return this.languageConfigurationService.getLanguageConfiguration(languageId);
        })), store);
        store.add(this.bracketPairsTree.value.object.onDidChange((e) => this.onDidChangeEmitter.fire(e)));
        this.onDidChangeEmitter.fire();
      }
    } else {
      if (this.bracketPairsTree.value) {
        this.bracketPairsTree.clear();
        this.onDidChangeEmitter.fire();
      }
    }
  }
  /**
   * Returns all bracket pairs that intersect the given range.
   * The result is sorted by the start position.
  */
  getBracketPairsInRange(range2) {
    var _a3;
    this.bracketsRequested = true;
    this.updateBracketPairsTree();
    return ((_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.getBracketPairsInRange(range2, false)) || [];
  }
  getBracketPairsInRangeWithMinIndentation(range2) {
    var _a3;
    this.bracketsRequested = true;
    this.updateBracketPairsTree();
    return ((_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.getBracketPairsInRange(range2, true)) || [];
  }
  getBracketsInRange(range2) {
    var _a3;
    this.bracketsRequested = true;
    this.updateBracketPairsTree();
    return ((_a3 = this.bracketPairsTree.value) === null || _a3 === void 0 ? void 0 : _a3.object.getBracketsInRange(range2)) || [];
  }
  findMatchingBracketUp(_bracket, _position, maxDuration) {
    const bracket = _bracket.toLowerCase();
    const position = this.textModel.validatePosition(_position);
    const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);
    const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
    if (!bracketsSupport) {
      return null;
    }
    const data = bracketsSupport.textIsBracket[bracket];
    if (!data) {
      return null;
    }
    return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));
  }
  matchBracket(position, maxDuration) {
    const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);
    return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);
  }
  _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {
    const tokenCount = lineTokens.getCount();
    const currentLanguageId = lineTokens.getLanguageId(tokenIndex);
    let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);
    for (let i = tokenIndex - 1; i >= 0; i--) {
      const tokenEndOffset = lineTokens.getEndOffset(i);
      if (tokenEndOffset <= searchStartOffset) {
        break;
      }
      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {
        searchStartOffset = tokenEndOffset;
        break;
      }
    }
    let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);
    for (let i = tokenIndex + 1; i < tokenCount; i++) {
      const tokenStartOffset = lineTokens.getStartOffset(i);
      if (tokenStartOffset >= searchEndOffset) {
        break;
      }
      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {
        searchEndOffset = tokenStartOffset;
        break;
      }
    }
    return { searchStartOffset, searchEndOffset };
  }
  _matchBracket(position, continueSearchPredicate) {
    const lineNumber = position.lineNumber;
    const lineTokens = this.textModel.getLineTokens(lineNumber);
    const lineText = this.textModel.getLineContent(lineNumber);
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    if (tokenIndex < 0) {
      return null;
    }
    const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;
    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
      let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);
      let bestResult = null;
      while (true) {
        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!foundBracket) {
          break;
        }
        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);
          if (r) {
            if (r instanceof BracketSearchCanceled) {
              return null;
            }
            bestResult = r;
          }
        }
        searchStartOffset = foundBracket.endColumn - 1;
      }
      if (bestResult) {
        return bestResult;
      }
    }
    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {
      const prevTokenIndex = tokenIndex - 1;
      const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;
      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {
        const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);
        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);
          if (r) {
            if (r instanceof BracketSearchCanceled) {
              return null;
            }
            return r;
          }
        }
      }
    }
    return null;
  }
  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {
    if (!data) {
      return null;
    }
    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);
    if (!matched) {
      return null;
    }
    if (matched instanceof BracketSearchCanceled) {
      return matched;
    }
    return [foundBracket, matched];
  }
  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {
    const languageId = bracket.languageId;
    const reversedBracketRegex = bracket.reversedRegex;
    let count = -1;
    let totalCallCount = 0;
    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
      while (true) {
        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
          return BracketSearchCanceled.INSTANCE;
        }
        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!r) {
          break;
        }
        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        if (bracket.isOpen(hitText)) {
          count++;
        } else if (bracket.isClose(hitText)) {
          count--;
        }
        if (count === 0) {
          return r;
        }
        searchEndOffset = r.startColumn - 1;
      }
      return null;
    };
    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
      const lineTokens = this.textModel.getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this.textModel.getLineContent(lineNumber);
      let tokenIndex = tokenCount - 1;
      let searchStartOffset = lineText.length;
      let searchEndOffset = lineText.length;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
      }
      let prevSearchInToken = true;
      for (; tokenIndex >= 0; tokenIndex--) {
        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return r;
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return r;
        }
      }
    }
    return null;
  }
  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {
    const languageId = bracket.languageId;
    const bracketRegex = bracket.forwardRegex;
    let count = 1;
    let totalCallCount = 0;
    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
      while (true) {
        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
          return BracketSearchCanceled.INSTANCE;
        }
        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!r) {
          break;
        }
        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        if (bracket.isOpen(hitText)) {
          count++;
        } else if (bracket.isClose(hitText)) {
          count--;
        }
        if (count === 0) {
          return r;
        }
        searchStartOffset = r.endColumn - 1;
      }
      return null;
    };
    const lineCount = this.textModel.getLineCount();
    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
      const lineTokens = this.textModel.getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this.textModel.getLineContent(lineNumber);
      let tokenIndex = 0;
      let searchStartOffset = 0;
      let searchEndOffset = 0;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
      }
      let prevSearchInToken = true;
      for (; tokenIndex < tokenCount; tokenIndex++) {
        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return r;
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return r;
        }
      }
    }
    return null;
  }
  findPrevBracket(_position) {
    const position = this.textModel.validatePosition(_position);
    let languageId = null;
    let modeBrackets = null;
    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
      const lineTokens = this.textModel.getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this.textModel.getLineContent(lineNumber);
      let tokenIndex = tokenCount - 1;
      let searchStartOffset = lineText.length;
      let searchEndOffset = lineText.length;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          languageId = tokenLanguageId;
          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
        }
      }
      let prevSearchInToken = true;
      for (; tokenIndex >= 0; tokenIndex--) {
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
            prevSearchInToken = false;
          }
          languageId = tokenLanguageId;
          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
        }
        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return this._toFoundBracket(modeBrackets, r);
        }
      }
    }
    return null;
  }
  findNextBracket(_position) {
    const position = this.textModel.validatePosition(_position);
    const lineCount = this.textModel.getLineCount();
    let languageId = null;
    let modeBrackets = null;
    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
      const lineTokens = this.textModel.getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this.textModel.getLineContent(lineNumber);
      let tokenIndex = 0;
      let searchStartOffset = 0;
      let searchEndOffset = 0;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          languageId = tokenLanguageId;
          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
        }
      }
      let prevSearchInToken = true;
      for (; tokenIndex < tokenCount; tokenIndex++) {
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
            prevSearchInToken = false;
          }
          languageId = tokenLanguageId;
          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
        }
        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(modeBrackets, r);
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return this._toFoundBracket(modeBrackets, r);
        }
      }
    }
    return null;
  }
  findEnclosingBrackets(_position, maxDuration) {
    const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);
    const position = this.textModel.validatePosition(_position);
    const lineCount = this.textModel.getLineCount();
    const savedCounts = /* @__PURE__ */ new Map();
    let counts = [];
    const resetCounts = (languageId2, modeBrackets2) => {
      if (!savedCounts.has(languageId2)) {
        const tmp = [];
        for (let i = 0, len = modeBrackets2 ? modeBrackets2.brackets.length : 0; i < len; i++) {
          tmp[i] = 0;
        }
        savedCounts.set(languageId2, tmp);
      }
      counts = savedCounts.get(languageId2);
    };
    let totalCallCount = 0;
    const searchInRange = (modeBrackets2, lineNumber, lineText, searchStartOffset, searchEndOffset) => {
      while (true) {
        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
          return BracketSearchCanceled.INSTANCE;
        }
        const r = BracketsUtils.findNextBracketInRange(modeBrackets2.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (!r) {
          break;
        }
        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        const bracket = modeBrackets2.textIsBracket[hitText];
        if (bracket) {
          if (bracket.isOpen(hitText)) {
            counts[bracket.index]++;
          } else if (bracket.isClose(hitText)) {
            counts[bracket.index]--;
          }
          if (counts[bracket.index] === -1) {
            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);
          }
        }
        searchStartOffset = r.endColumn - 1;
      }
      return null;
    };
    let languageId = null;
    let modeBrackets = null;
    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
      const lineTokens = this.textModel.getLineTokens(lineNumber);
      const tokenCount = lineTokens.getCount();
      const lineText = this.textModel.getLineContent(lineNumber);
      let tokenIndex = 0;
      let searchStartOffset = 0;
      let searchEndOffset = 0;
      if (lineNumber === position.lineNumber) {
        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        searchStartOffset = position.column - 1;
        searchEndOffset = position.column - 1;
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          languageId = tokenLanguageId;
          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
          resetCounts(languageId, modeBrackets);
        }
      }
      let prevSearchInToken = true;
      for (; tokenIndex < tokenCount; tokenIndex++) {
        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
        if (languageId !== tokenLanguageId) {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return stripBracketSearchCanceled(r);
            }
            prevSearchInToken = false;
          }
          languageId = tokenLanguageId;
          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
          resetCounts(languageId, modeBrackets);
        }
        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
        if (searchInToken) {
          if (prevSearchInToken) {
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          } else {
            searchStartOffset = lineTokens.getStartOffset(tokenIndex);
            searchEndOffset = lineTokens.getEndOffset(tokenIndex);
          }
        } else {
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return stripBracketSearchCanceled(r);
            }
          }
        }
        prevSearchInToken = searchInToken;
      }
      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
        if (r) {
          return stripBracketSearchCanceled(r);
        }
      }
    }
    return null;
  }
  _toFoundBracket(modeBrackets, r) {
    if (!r) {
      return null;
    }
    let text = this.textModel.getValueInRange(r);
    text = text.toLowerCase();
    const data = modeBrackets.textIsBracket[text];
    if (!data) {
      return null;
    }
    return {
      range: r,
      open: data.open,
      close: data.close,
      isOpen: modeBrackets.textIsOpenBracket[text]
    };
  }
};
function createDisposableRef(object, disposable) {
  return {
    object,
    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()
  };
}
function createTimeBasedContinueBracketSearchPredicate(maxDuration) {
  if (typeof maxDuration === "undefined") {
    return () => true;
  } else {
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime <= maxDuration;
    };
  }
}
var BracketSearchCanceled = class {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
};
BracketSearchCanceled.INSTANCE = new BracketSearchCanceled();
function stripBracketSearchCanceled(result) {
  if (result instanceof BracketSearchCanceled) {
    return null;
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js
var editorLineHighlight = registerColor("editor.lineHighlightBackground", { dark: null, light: null, hc: null }, localize("lineHighlight", "Background color for the highlight of line at the cursor position."));
var editorLineHighlightBorder = registerColor("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hc: "#f38518" }, localize("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
var editorRangeHighlight = registerColor("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hc: null }, localize("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), true);
var editorRangeHighlightBorder = registerColor("editor.rangeHighlightBorder", { dark: null, light: null, hc: activeContrastBorder }, localize("rangeHighlightBorder", "Background color of the border around highlighted ranges."), true);
var editorSymbolHighlight = registerColor("editor.symbolHighlightBackground", { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hc: null }, localize("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), true);
var editorSymbolHighlightBorder = registerColor("editor.symbolHighlightBorder", { dark: null, light: null, hc: activeContrastBorder }, localize("symbolHighlightBorder", "Background color of the border around highlighted symbols."), true);
var editorCursorForeground = registerColor("editorCursor.foreground", { dark: "#AEAFAD", light: Color.black, hc: Color.white }, localize("caret", "Color of the editor cursor."));
var editorCursorBackground = registerColor("editorCursor.background", null, localize("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor."));
var editorWhitespaces = registerColor("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hc: "#e3e4e229" }, localize("editorWhitespaces", "Color of whitespace characters in the editor."));
var editorIndentGuides = registerColor("editorIndentGuide.background", { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, localize("editorIndentGuides", "Color of the editor indentation guides."));
var editorActiveIndentGuides = registerColor("editorIndentGuide.activeBackground", { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, localize("editorActiveIndentGuide", "Color of the active editor indentation guides."));
var editorLineNumbers = registerColor("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hc: Color.white }, localize("editorLineNumbers", "Color of editor line numbers."));
var deprecatedEditorActiveLineNumber = registerColor("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hc: activeContrastBorder }, localize("editorActiveLineNumber", "Color of editor active line number"), false, localize("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
var editorActiveLineNumber = registerColor("editorLineNumber.activeForeground", { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hc: deprecatedEditorActiveLineNumber }, localize("editorActiveLineNumber", "Color of editor active line number"));
var editorRuler = registerColor("editorRuler.foreground", { dark: "#5A5A5A", light: Color.lightgrey, hc: Color.white }, localize("editorRuler", "Color of the editor rulers."));
var editorCodeLensForeground = registerColor("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hc: "#999999" }, localize("editorCodeLensForeground", "Foreground color of editor CodeLens"));
var editorBracketMatchBackground = registerColor("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hc: "#0064001a" }, localize("editorBracketMatchBackground", "Background color behind matching brackets"));
var editorBracketMatchBorder = registerColor("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hc: contrastBorder }, localize("editorBracketMatchBorder", "Color for matching brackets boxes"));
var editorOverviewRulerBorder = registerColor("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hc: "#7f7f7f4d" }, localize("editorOverviewRulerBorder", "Color of the overview ruler border."));
var editorOverviewRulerBackground = registerColor("editorOverviewRuler.background", null, localize("editorOverviewRulerBackground", "Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor."));
var editorGutter = registerColor("editorGutter.background", { dark: editorBackground, light: editorBackground, hc: editorBackground }, localize("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
var editorUnnecessaryCodeBorder = registerColor("editorUnnecessaryCode.border", { dark: null, light: null, hc: Color.fromHex("#fff").transparent(0.8) }, localize("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
var editorUnnecessaryCodeOpacity = registerColor("editorUnnecessaryCode.opacity", { dark: Color.fromHex("#000a"), light: Color.fromHex("#0007"), hc: null }, localize("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
var ghostTextBorder = registerColor("editorGhostText.border", { dark: null, light: null, hc: Color.fromHex("#fff").transparent(0.8) }, localize("editorGhostTextBorder", "Border color of ghost text in the editor."));
var ghostTextForeground = registerColor("editorGhostText.foreground", { dark: Color.fromHex("#ffffff56"), light: Color.fromHex("#0007"), hc: null }, localize("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
var ghostTextBackground = registerColor("editorGhostText.background", { dark: null, light: null, hc: null }, localize("editorGhostTextBackground", "Background color of the ghost text in the editor."));
var rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));
var overviewRulerRangeHighlight = registerColor("editorOverviewRuler.rangeHighlightForeground", { dark: rulerRangeDefault, light: rulerRangeDefault, hc: rulerRangeDefault }, localize("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerError = registerColor("editorOverviewRuler.errorForeground", { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, localize("overviewRuleError", "Overview ruler marker color for errors."));
var overviewRulerWarning = registerColor("editorOverviewRuler.warningForeground", { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder }, localize("overviewRuleWarning", "Overview ruler marker color for warnings."));
var overviewRulerInfo = registerColor("editorOverviewRuler.infoForeground", { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoBorder }, localize("overviewRuleInfo", "Overview ruler marker color for infos."));
var editorBracketHighlightingForeground1 = registerColor("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hc: "#FFD700" }, localize("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization."));
var editorBracketHighlightingForeground2 = registerColor("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hc: "#DA70D6" }, localize("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization."));
var editorBracketHighlightingForeground3 = registerColor("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hc: "#87CEFA" }, localize("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization."));
var editorBracketHighlightingForeground4 = registerColor("editorBracketHighlight.foreground4", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization."));
var editorBracketHighlightingForeground5 = registerColor("editorBracketHighlight.foreground5", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization."));
var editorBracketHighlightingForeground6 = registerColor("editorBracketHighlight.foreground6", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization."));
var editorBracketHighlightingUnexpectedBracketForeground = registerColor("editorBracketHighlight.unexpectedBracket.foreground", { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hc: new Color(new RGBA(255, 50, 50, 1)) }, localize("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets."));
var editorBracketPairGuideBackground1 = registerColor("editorBracketPairGuide.background1", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides."));
var editorBracketPairGuideBackground2 = registerColor("editorBracketPairGuide.background2", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides."));
var editorBracketPairGuideBackground3 = registerColor("editorBracketPairGuide.background3", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides."));
var editorBracketPairGuideBackground4 = registerColor("editorBracketPairGuide.background4", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides."));
var editorBracketPairGuideBackground5 = registerColor("editorBracketPairGuide.background5", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides."));
var editorBracketPairGuideBackground6 = registerColor("editorBracketPairGuide.background6", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides."));
var editorBracketPairGuideActiveBackground1 = registerColor("editorBracketPairGuide.activeBackground1", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides."));
var editorBracketPairGuideActiveBackground2 = registerColor("editorBracketPairGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides."));
var editorBracketPairGuideActiveBackground3 = registerColor("editorBracketPairGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides."));
var editorBracketPairGuideActiveBackground4 = registerColor("editorBracketPairGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides."));
var editorBracketPairGuideActiveBackground5 = registerColor("editorBracketPairGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides."));
var editorBracketPairGuideActiveBackground6 = registerColor("editorBracketPairGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, localize("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
var editorUnicodeHighlightBorder = registerColor("editorUnicodeHighlight.border", { dark: "#BD9B03", light: "#CEA33D", hc: "#ff0000" }, localize("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
registerThemingParticipant((theme, collector) => {
  const background = theme.getColor(editorBackground);
  if (background) {
    collector.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${background}; }`);
  }
  const foreground2 = theme.getColor(editorForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${foreground2}; }`);
  }
  const gutter = theme.getColor(editorGutter);
  if (gutter) {
    collector.addRule(`.monaco-editor .margin { background-color: ${gutter}; }`);
  }
  const rangeHighlight = theme.getColor(editorRangeHighlight);
  if (rangeHighlight) {
    collector.addRule(`.monaco-editor .rangeHighlight { background-color: ${rangeHighlight}; }`);
  }
  const rangeHighlightBorder = theme.getColor(editorRangeHighlightBorder);
  if (rangeHighlightBorder) {
    collector.addRule(`.monaco-editor .rangeHighlight { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${rangeHighlightBorder}; }`);
  }
  const symbolHighlight = theme.getColor(editorSymbolHighlight);
  if (symbolHighlight) {
    collector.addRule(`.monaco-editor .symbolHighlight { background-color: ${symbolHighlight}; }`);
  }
  const symbolHighlightBorder = theme.getColor(editorSymbolHighlightBorder);
  if (symbolHighlightBorder) {
    collector.addRule(`.monaco-editor .symbolHighlight { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${symbolHighlightBorder}; }`);
  }
  const invisibles = theme.getColor(editorWhitespaces);
  if (invisibles) {
    collector.addRule(`.monaco-editor .mtkw { color: ${invisibles} !important; }`);
    collector.addRule(`.monaco-editor .mtkz { color: ${invisibles} !important; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js
var ColorizedBracketPairsDecorationProvider = class extends Disposable {
  constructor(textModel) {
    super();
    this.textModel = textModel;
    this.colorProvider = new ColorProvider();
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;
    this._register(textModel.bracketPairs.onDidChange((e) => {
      this.onDidChangeEmitter.fire();
    }));
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
  }
  //#endregion
  getDecorationsInRange(range2, ownerId, filterOutValidation) {
    if (ownerId === void 0) {
      return [];
    }
    if (!this.colorizationOptions.enabled) {
      return [];
    }
    const result = new Array();
    const bracketsInRange = this.textModel.bracketPairs.getBracketsInRange(range2);
    for (const bracket of bracketsInRange) {
      result.push({
        id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,
        options: { description: "BracketPairColorization", inlineClassName: this.colorProvider.getInlineClassName(bracket) },
        ownerId: 0,
        range: bracket.range
      });
    }
    return result;
  }
  getAllDecorations(ownerId, filterOutValidation) {
    if (ownerId === void 0) {
      return [];
    }
    if (!this.colorizationOptions.enabled) {
      return [];
    }
    return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);
  }
};
var ColorProvider = class {
  constructor() {
    this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
  }
  getInlineClassName(bracket) {
    if (bracket.isInvalid) {
      return this.unexpectedClosingBracketClassName;
    }
    return this.getInlineClassNameOfLevel(bracket.nestingLevel);
  }
  getInlineClassNameOfLevel(level) {
    return `bracket-highlighting-${level % 30}`;
  }
};
registerThemingParticipant((theme, collector) => {
  const colors = [
    editorBracketHighlightingForeground1,
    editorBracketHighlightingForeground2,
    editorBracketHighlightingForeground3,
    editorBracketHighlightingForeground4,
    editorBracketHighlightingForeground5,
    editorBracketHighlightingForeground6
  ];
  const colorProvider = new ColorProvider();
  collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);
  const colorValues = colors.map((c) => theme.getColor(c)).filter((c) => !!c).filter((c) => !c.isTransparent());
  for (let level = 0; level < 30; level++) {
    const color = colorValues[level % colorValues.length];
    collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js
function escapeNewLine(str) {
  return str.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
var TextChange = class _TextChange {
  constructor(oldPosition, oldText, newPosition, newText) {
    this.oldPosition = oldPosition;
    this.oldText = oldText;
    this.newPosition = newPosition;
    this.newText = newText;
  }
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  toString() {
    if (this.oldText.length === 0) {
      return `(insert@${this.oldPosition} "${escapeNewLine(this.newText)}")`;
    }
    if (this.newText.length === 0) {
      return `(delete@${this.oldPosition} "${escapeNewLine(this.oldText)}")`;
    }
    return `(replace@${this.oldPosition} "${escapeNewLine(this.oldText)}" with "${escapeNewLine(this.newText)}")`;
  }
  static _writeStringSize(str) {
    return 4 + 2 * str.length;
  }
  static _writeString(b, str, offset) {
    const len = str.length;
    writeUInt32BE(b, len, offset);
    offset += 4;
    for (let i = 0; i < len; i++) {
      writeUInt16LE(b, str.charCodeAt(i), offset);
      offset += 2;
    }
    return offset;
  }
  static _readString(b, offset) {
    const len = readUInt32BE(b, offset);
    offset += 4;
    return decodeUTF16LE(b, offset, len);
  }
  writeSize() {
    return 4 + 4 + _TextChange._writeStringSize(this.oldText) + _TextChange._writeStringSize(this.newText);
  }
  write(b, offset) {
    writeUInt32BE(b, this.oldPosition, offset);
    offset += 4;
    writeUInt32BE(b, this.newPosition, offset);
    offset += 4;
    offset = _TextChange._writeString(b, this.oldText, offset);
    offset = _TextChange._writeString(b, this.newText, offset);
    return offset;
  }
  static read(b, offset, dest) {
    const oldPosition = readUInt32BE(b, offset);
    offset += 4;
    const newPosition = readUInt32BE(b, offset);
    offset += 4;
    const oldText = _TextChange._readString(b, offset);
    offset += _TextChange._writeStringSize(oldText);
    const newText = _TextChange._readString(b, offset);
    offset += _TextChange._writeStringSize(newText);
    dest.push(new _TextChange(oldPosition, oldText, newPosition, newText));
    return offset;
  }
};
function compressConsecutiveTextChanges(prevEdits, currEdits) {
  if (prevEdits === null || prevEdits.length === 0) {
    return currEdits;
  }
  const compressor = new TextChangeCompressor(prevEdits, currEdits);
  return compressor.compress();
}
var TextChangeCompressor = class _TextChangeCompressor {
  constructor(prevEdits, currEdits) {
    this._prevEdits = prevEdits;
    this._currEdits = currEdits;
    this._result = [];
    this._resultLen = 0;
    this._prevLen = this._prevEdits.length;
    this._prevDeltaOffset = 0;
    this._currLen = this._currEdits.length;
    this._currDeltaOffset = 0;
  }
  compress() {
    let prevIndex = 0;
    let currIndex = 0;
    let prevEdit = this._getPrev(prevIndex);
    let currEdit = this._getCurr(currIndex);
    while (prevIndex < this._prevLen || currIndex < this._currLen) {
      if (prevEdit === null) {
        this._acceptCurr(currEdit);
        currEdit = this._getCurr(++currIndex);
        continue;
      }
      if (currEdit === null) {
        this._acceptPrev(prevEdit);
        prevEdit = this._getPrev(++prevIndex);
        continue;
      }
      if (currEdit.oldEnd <= prevEdit.newPosition) {
        this._acceptCurr(currEdit);
        currEdit = this._getCurr(++currIndex);
        continue;
      }
      if (prevEdit.newEnd <= currEdit.oldPosition) {
        this._acceptPrev(prevEdit);
        prevEdit = this._getPrev(++prevIndex);
        continue;
      }
      if (currEdit.oldPosition < prevEdit.newPosition) {
        const [e1, e2] = _TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);
        this._acceptCurr(e1);
        currEdit = e2;
        continue;
      }
      if (prevEdit.newPosition < currEdit.oldPosition) {
        const [e1, e2] = _TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);
        this._acceptPrev(e1);
        prevEdit = e2;
        continue;
      }
      let mergePrev;
      let mergeCurr;
      if (currEdit.oldEnd === prevEdit.newEnd) {
        mergePrev = prevEdit;
        mergeCurr = currEdit;
        prevEdit = this._getPrev(++prevIndex);
        currEdit = this._getCurr(++currIndex);
      } else if (currEdit.oldEnd < prevEdit.newEnd) {
        const [e1, e2] = _TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);
        mergePrev = e1;
        mergeCurr = currEdit;
        prevEdit = e2;
        currEdit = this._getCurr(++currIndex);
      } else {
        const [e1, e2] = _TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);
        mergePrev = prevEdit;
        mergeCurr = e1;
        prevEdit = this._getPrev(++prevIndex);
        currEdit = e2;
      }
      this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);
      this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;
      this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;
    }
    const merged = _TextChangeCompressor._merge(this._result);
    const cleaned = _TextChangeCompressor._removeNoOps(merged);
    return cleaned;
  }
  _acceptCurr(currEdit) {
    this._result[this._resultLen++] = _TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);
    this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;
  }
  _getCurr(currIndex) {
    return currIndex < this._currLen ? this._currEdits[currIndex] : null;
  }
  _acceptPrev(prevEdit) {
    this._result[this._resultLen++] = _TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);
    this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;
  }
  _getPrev(prevIndex) {
    return prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null;
  }
  static _rebaseCurr(prevDeltaOffset, currEdit) {
    return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);
  }
  static _rebasePrev(currDeltaOffset, prevEdit) {
    return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);
  }
  static _splitPrev(edit, offset) {
    const preText = edit.newText.substr(0, offset);
    const postText = edit.newText.substr(offset);
    return [
      new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),
      new TextChange(edit.oldEnd, "", edit.newPosition + offset, postText)
    ];
  }
  static _splitCurr(edit, offset) {
    const preText = edit.oldText.substr(0, offset);
    const postText = edit.oldText.substr(offset);
    return [
      new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),
      new TextChange(edit.oldPosition + offset, postText, edit.newEnd, "")
    ];
  }
  static _merge(edits) {
    if (edits.length === 0) {
      return edits;
    }
    const result = [];
    let resultLen = 0;
    let prev = edits[0];
    for (let i = 1; i < edits.length; i++) {
      const curr = edits[i];
      if (prev.oldEnd === curr.oldPosition) {
        prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);
      } else {
        result[resultLen++] = prev;
        prev = curr;
      }
    }
    result[resultLen++] = prev;
    return result;
  }
  static _removeNoOps(edits) {
    if (edits.length === 0) {
      return edits;
    }
    const result = [];
    let resultLen = 0;
    for (let i = 0; i < edits.length; i++) {
      const edit = edits[i];
      if (edit.oldText === edit.newText) {
        continue;
      }
      result[resultLen++] = edit;
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/extpath.js
function isPathSeparator2(code) {
  return code === 47 || code === 92;
}
function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, posix.sep);
}
function toPosixPath(osPath) {
  if (osPath.indexOf("/") === -1) {
    osPath = toSlashes(osPath);
  }
  if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
    osPath = "/" + osPath;
  }
  return osPath;
}
function getRoot(path, sep2 = posix.sep) {
  if (!path) {
    return "";
  }
  const len = path.length;
  const firstLetter = path.charCodeAt(0);
  if (isPathSeparator2(firstLetter)) {
    if (isPathSeparator2(path.charCodeAt(1))) {
      if (!isPathSeparator2(path.charCodeAt(2))) {
        let pos2 = 3;
        const start = pos2;
        for (; pos2 < len; pos2++) {
          if (isPathSeparator2(path.charCodeAt(pos2))) {
            break;
          }
        }
        if (start !== pos2 && !isPathSeparator2(path.charCodeAt(pos2 + 1))) {
          pos2 += 1;
          for (; pos2 < len; pos2++) {
            if (isPathSeparator2(path.charCodeAt(pos2))) {
              return path.slice(0, pos2 + 1).replace(/[\\/]/g, sep2);
            }
          }
        }
      }
    }
    return sep2;
  } else if (isWindowsDriveLetter(firstLetter)) {
    if (path.charCodeAt(1) === 58) {
      if (isPathSeparator2(path.charCodeAt(2))) {
        return path.slice(0, 2) + sep2;
      } else {
        return path.slice(0, 2);
      }
    }
  }
  let pos = path.indexOf("://");
  if (pos !== -1) {
    pos += 3;
    for (; pos < len; pos++) {
      if (isPathSeparator2(path.charCodeAt(pos))) {
        return path.slice(0, pos + 1);
      }
    }
  }
  return "";
}
function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {
  if (base === parentCandidate) {
    return true;
  }
  if (!base || !parentCandidate) {
    return false;
  }
  if (parentCandidate.length > base.length) {
    return false;
  }
  if (ignoreCase) {
    const beginsWith = startsWithIgnoreCase(base, parentCandidate);
    if (!beginsWith) {
      return false;
    }
    if (parentCandidate.length === base.length) {
      return true;
    }
    let sepOffset = parentCandidate.length;
    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
      sepOffset--;
    }
    return base.charAt(sepOffset) === separator;
  }
  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
    parentCandidate += separator;
  }
  return base.indexOf(parentCandidate) === 0;
}
function isWindowsDriveLetter(char0) {
  return char0 >= 65 && char0 <= 90 || char0 >= 97 && char0 <= 122;
}

// node_modules/monaco-editor/esm/vs/base/common/resources.js
function originalFSPath(uri) {
  return uriToFsPath(uri, true);
}
var ExtUri = class {
  constructor(_ignorePathCasing) {
    this._ignorePathCasing = _ignorePathCasing;
  }
  compare(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return 0;
    }
    return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
  }
  isEqual(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return true;
    }
    if (!uri1 || !uri2) {
      return false;
    }
    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
  }
  getComparisonKey(uri, ignoreFragment = false) {
    return uri.with({
      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
      fragment: ignoreFragment ? null : void 0
    }).toString();
  }
  isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
    if (base.scheme === parentCandidate.scheme) {
      if (base.scheme === Schemas.file) {
        return isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
      }
      if (isEqualAuthority(base.authority, parentCandidate.authority)) {
        return isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), "/") && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
      }
    }
    return false;
  }
  // --- path math
  joinPath(resource, ...pathFragment) {
    return URI.joinPath(resource, ...pathFragment);
  }
  basenameOrAuthority(resource) {
    return basename2(resource) || resource.authority;
  }
  basename(resource) {
    return posix.basename(resource.path);
  }
  extname(resource) {
    return posix.extname(resource.path);
  }
  dirname(resource) {
    if (resource.path.length === 0) {
      return resource;
    }
    let dirname3;
    if (resource.scheme === Schemas.file) {
      dirname3 = URI.file(dirname(originalFSPath(resource))).path;
    } else {
      dirname3 = posix.dirname(resource.path);
      if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47) {
        console.error(`dirname("${resource.toString})) resulted in a relative path`);
        dirname3 = "/";
      }
    }
    return resource.with({
      path: dirname3
    });
  }
  normalizePath(resource) {
    if (!resource.path.length) {
      return resource;
    }
    let normalizedPath;
    if (resource.scheme === Schemas.file) {
      normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
    } else {
      normalizedPath = posix.normalize(resource.path);
    }
    return resource.with({
      path: normalizedPath
    });
  }
  relativePath(from, to) {
    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
      return void 0;
    }
    if (from.scheme === Schemas.file) {
      const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
      return isWindows ? toSlashes(relativePath2) : relativePath2;
    }
    let fromPath = from.path || "/", toPath = to.path || "/";
    if (this._ignorePathCasing(from)) {
      let i = 0;
      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
            break;
          }
        }
      }
      fromPath = toPath.substr(0, i) + fromPath.substr(i);
    }
    return posix.relative(fromPath, toPath);
  }
  resolvePath(base, path) {
    if (base.scheme === Schemas.file) {
      const newURI = URI.file(resolve(originalFSPath(base), path));
      return base.with({
        authority: newURI.authority,
        path: newURI.path
      });
    }
    path = toPosixPath(path);
    return base.with({
      path: posix.resolve(base.path, path)
    });
  }
  // --- misc
  isAbsolutePath(resource) {
    return !!resource.path && resource.path[0] === "/";
  }
  isEqualAuthority(a1, a2) {
    return a1 === a2 || a1 !== void 0 && a2 !== void 0 && equalsIgnoreCase(a1, a2);
  }
  hasTrailingPathSeparator(resource, sep2 = sep) {
    if (resource.scheme === Schemas.file) {
      const fsp = originalFSPath(resource);
      return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
    } else {
      const p = resource.path;
      return p.length > 1 && p.charCodeAt(p.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath);
    }
  }
  removeTrailingPathSeparator(resource, sep2 = sep) {
    if (hasTrailingPathSeparator(resource, sep2)) {
      return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
    }
    return resource;
  }
  addTrailingPathSeparator(resource, sep2 = sep) {
    let isRootSep = false;
    if (resource.scheme === Schemas.file) {
      const fsp = originalFSPath(resource);
      isRootSep = fsp !== void 0 && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
    } else {
      sep2 = "/";
      const p = resource.path;
      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47;
    }
    if (!isRootSep && !hasTrailingPathSeparator(resource, sep2)) {
      return resource.with({ path: resource.path + "/" });
    }
    return resource;
  }
};
var extUri = new ExtUri(() => false);
var extUriBiasedIgnorePathCase = new ExtUri((uri) => {
  return uri.scheme === Schemas.file ? !isLinux : true;
});
var extUriIgnorePathCase = new ExtUri((_) => true);
var isEqual = extUri.isEqual.bind(extUri);
var isEqualOrParent2 = extUri.isEqualOrParent.bind(extUri);
var getComparisonKey = extUri.getComparisonKey.bind(extUri);
var basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
var basename2 = extUri.basename.bind(extUri);
var extname2 = extUri.extname.bind(extUri);
var dirname2 = extUri.dirname.bind(extUri);
var joinPath = extUri.joinPath.bind(extUri);
var normalizePath = extUri.normalizePath.bind(extUri);
var relativePath = extUri.relativePath.bind(extUri);
var resolvePath = extUri.resolvePath.bind(extUri);
var isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
var isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
var hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
var removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
var addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
var DataUri;
(function(DataUri2) {
  DataUri2.META_DATA_LABEL = "label";
  DataUri2.META_DATA_DESCRIPTION = "description";
  DataUri2.META_DATA_SIZE = "size";
  DataUri2.META_DATA_MIME = "mime";
  function parseMetaData(dataUri) {
    const metadata = /* @__PURE__ */ new Map();
    const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
    meta.split(";").forEach((property) => {
      const [key, value] = property.split(":");
      if (key && value) {
        metadata.set(key, value);
      }
    });
    const mime = dataUri.path.substring(0, dataUri.path.indexOf(";"));
    if (mime) {
      metadata.set(DataUri2.META_DATA_MIME, mime);
    }
    return metadata;
  }
  DataUri2.parseMetaData = parseMetaData;
})(DataUri || (DataUri = {}));

// node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js
function uriGetComparisonKey(resource) {
  return resource.toString();
}
var SingleModelEditStackData = class _SingleModelEditStackData {
  constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {
    this.beforeVersionId = beforeVersionId;
    this.afterVersionId = afterVersionId;
    this.beforeEOL = beforeEOL;
    this.afterEOL = afterEOL;
    this.beforeCursorState = beforeCursorState;
    this.afterCursorState = afterCursorState;
    this.changes = changes;
  }
  static create(model, beforeCursorState) {
    const alternativeVersionId = model.getAlternativeVersionId();
    const eol = getModelEOL(model);
    return new _SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);
  }
  append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
    if (textChanges.length > 0) {
      this.changes = compressConsecutiveTextChanges(this.changes, textChanges);
    }
    this.afterEOL = afterEOL;
    this.afterVersionId = afterVersionId;
    this.afterCursorState = afterCursorState;
  }
  static _writeSelectionsSize(selections) {
    return 4 + 4 * 4 * (selections ? selections.length : 0);
  }
  static _writeSelections(b, selections, offset) {
    writeUInt32BE(b, selections ? selections.length : 0, offset);
    offset += 4;
    if (selections) {
      for (const selection of selections) {
        writeUInt32BE(b, selection.selectionStartLineNumber, offset);
        offset += 4;
        writeUInt32BE(b, selection.selectionStartColumn, offset);
        offset += 4;
        writeUInt32BE(b, selection.positionLineNumber, offset);
        offset += 4;
        writeUInt32BE(b, selection.positionColumn, offset);
        offset += 4;
      }
    }
    return offset;
  }
  static _readSelections(b, offset, dest) {
    const count = readUInt32BE(b, offset);
    offset += 4;
    for (let i = 0; i < count; i++) {
      const selectionStartLineNumber = readUInt32BE(b, offset);
      offset += 4;
      const selectionStartColumn = readUInt32BE(b, offset);
      offset += 4;
      const positionLineNumber = readUInt32BE(b, offset);
      offset += 4;
      const positionColumn = readUInt32BE(b, offset);
      offset += 4;
      dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));
    }
    return offset;
  }
  serialize() {
    let necessarySize = 4 + 4 + 1 + 1 + _SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState) + _SingleModelEditStackData._writeSelectionsSize(this.afterCursorState) + 4;
    for (const change of this.changes) {
      necessarySize += change.writeSize();
    }
    const b = new Uint8Array(necessarySize);
    let offset = 0;
    writeUInt32BE(b, this.beforeVersionId, offset);
    offset += 4;
    writeUInt32BE(b, this.afterVersionId, offset);
    offset += 4;
    writeUInt8(b, this.beforeEOL, offset);
    offset += 1;
    writeUInt8(b, this.afterEOL, offset);
    offset += 1;
    offset = _SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);
    offset = _SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);
    writeUInt32BE(b, this.changes.length, offset);
    offset += 4;
    for (const change of this.changes) {
      offset = change.write(b, offset);
    }
    return b.buffer;
  }
  static deserialize(source) {
    const b = new Uint8Array(source);
    let offset = 0;
    const beforeVersionId = readUInt32BE(b, offset);
    offset += 4;
    const afterVersionId = readUInt32BE(b, offset);
    offset += 4;
    const beforeEOL = readUInt8(b, offset);
    offset += 1;
    const afterEOL = readUInt8(b, offset);
    offset += 1;
    const beforeCursorState = [];
    offset = _SingleModelEditStackData._readSelections(b, offset, beforeCursorState);
    const afterCursorState = [];
    offset = _SingleModelEditStackData._readSelections(b, offset, afterCursorState);
    const changeCount = readUInt32BE(b, offset);
    offset += 4;
    const changes = [];
    for (let i = 0; i < changeCount; i++) {
      offset = TextChange.read(b, offset, changes);
    }
    return new _SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);
  }
};
var SingleModelEditStackElement = class {
  constructor(model, beforeCursorState) {
    this.model = model;
    this._data = SingleModelEditStackData.create(model, beforeCursorState);
  }
  get type() {
    return 0;
  }
  get resource() {
    if (URI.isUri(this.model)) {
      return this.model;
    }
    return this.model.uri;
  }
  get label() {
    return localize("edit", "Typing");
  }
  toString() {
    const data = this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data);
    return data.changes.map((change) => change.toString()).join(", ");
  }
  matchesResource(resource) {
    const uri = URI.isUri(this.model) ? this.model : this.model.uri;
    return uri.toString() === resource.toString();
  }
  setModel(model) {
    this.model = model;
  }
  canAppend(model) {
    return this.model === model && this._data instanceof SingleModelEditStackData;
  }
  append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
    if (this._data instanceof SingleModelEditStackData) {
      this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
    }
  }
  close() {
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
  }
  open() {
    if (!(this._data instanceof SingleModelEditStackData)) {
      this._data = SingleModelEditStackData.deserialize(this._data);
    }
  }
  undo() {
    if (URI.isUri(this.model)) {
      throw new Error(`Invalid SingleModelEditStackElement`);
    }
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
    const data = SingleModelEditStackData.deserialize(this._data);
    this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);
  }
  redo() {
    if (URI.isUri(this.model)) {
      throw new Error(`Invalid SingleModelEditStackElement`);
    }
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
    const data = SingleModelEditStackData.deserialize(this._data);
    this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);
  }
  heapSize() {
    if (this._data instanceof SingleModelEditStackData) {
      this._data = this._data.serialize();
    }
    return this._data.byteLength + 168;
  }
};
var MultiModelEditStackElement = class {
  constructor(label, editStackElements) {
    this.type = 1;
    this.label = label;
    this._isOpen = true;
    this._editStackElementsArr = editStackElements.slice(0);
    this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const editStackElement of this._editStackElementsArr) {
      const key = uriGetComparisonKey(editStackElement.resource);
      this._editStackElementsMap.set(key, editStackElement);
    }
    this._delegate = null;
  }
  get resources() {
    return this._editStackElementsArr.map((editStackElement) => editStackElement.resource);
  }
  prepareUndoRedo() {
    if (this._delegate) {
      return this._delegate.prepareUndoRedo(this);
    }
  }
  matchesResource(resource) {
    const key = uriGetComparisonKey(resource);
    return this._editStackElementsMap.has(key);
  }
  setModel(model) {
    const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);
    if (this._editStackElementsMap.has(key)) {
      this._editStackElementsMap.get(key).setModel(model);
    }
  }
  canAppend(model) {
    if (!this._isOpen) {
      return false;
    }
    const key = uriGetComparisonKey(model.uri);
    if (this._editStackElementsMap.has(key)) {
      const editStackElement = this._editStackElementsMap.get(key);
      return editStackElement.canAppend(model);
    }
    return false;
  }
  append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
    const key = uriGetComparisonKey(model.uri);
    const editStackElement = this._editStackElementsMap.get(key);
    editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
  }
  close() {
    this._isOpen = false;
  }
  open() {
  }
  undo() {
    this._isOpen = false;
    for (const editStackElement of this._editStackElementsArr) {
      editStackElement.undo();
    }
  }
  redo() {
    for (const editStackElement of this._editStackElementsArr) {
      editStackElement.redo();
    }
  }
  heapSize(resource) {
    const key = uriGetComparisonKey(resource);
    if (this._editStackElementsMap.has(key)) {
      const editStackElement = this._editStackElementsMap.get(key);
      return editStackElement.heapSize();
    }
    return 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    let result = [];
    for (const editStackElement of this._editStackElementsArr) {
      result.push(`${basename2(editStackElement.resource)}: ${editStackElement}`);
    }
    return `{${result.join(", ")}}`;
  }
};
function getModelEOL(model) {
  const eol = model.getEOL();
  if (eol === "\n") {
    return 0;
  } else {
    return 1;
  }
}
function isEditStackElement(element) {
  if (!element) {
    return false;
  }
  return element instanceof SingleModelEditStackElement || element instanceof MultiModelEditStackElement;
}
var EditStack = class _EditStack {
  constructor(model, undoRedoService) {
    this._model = model;
    this._undoRedoService = undoRedoService;
  }
  pushStackElement() {
    const lastElement = this._undoRedoService.getLastElement(this._model.uri);
    if (isEditStackElement(lastElement)) {
      lastElement.close();
    }
  }
  popStackElement() {
    const lastElement = this._undoRedoService.getLastElement(this._model.uri);
    if (isEditStackElement(lastElement)) {
      lastElement.open();
    }
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(beforeCursorState) {
    const lastElement = this._undoRedoService.getLastElement(this._model.uri);
    if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {
      return lastElement;
    }
    const newElement = new SingleModelEditStackElement(this._model, beforeCursorState);
    this._undoRedoService.pushElement(newElement);
    return newElement;
  }
  pushEOL(eol) {
    const editStackElement = this._getOrCreateEditStackElement(null);
    this._model.setEOL(eol);
    editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {
    const editStackElement = this._getOrCreateEditStackElement(beforeCursorState);
    const inverseEditOperations = this._model.applyEdits(editOperations, true);
    const afterCursorState = _EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);
    const textChanges = inverseEditOperations.map((op, index) => ({ index, textChange: op.textChange }));
    textChanges.sort((a, b) => {
      if (a.textChange.oldPosition === b.textChange.oldPosition) {
        return a.index - b.index;
      }
      return a.textChange.oldPosition - b.textChange.oldPosition;
    });
    editStackElement.append(this._model, textChanges.map((op) => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);
    return afterCursorState;
  }
  static _computeCursorState(cursorStateComputer, inverseEditOperations) {
    try {
      return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;
    } catch (e) {
      onUnexpectedError(e);
      return null;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js
var TextModelPart = class {
  constructor() {
    this._isDisposed = false;
  }
  dispose() {
    this._isDisposed = true;
  }
  assertNotDisposed() {
    if (this._isDisposed) {
      throw new Error("TextModelPart is disposed!");
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/utils.js
function computeIndentLevel(line, tabSize) {
  let indent = 0;
  let i = 0;
  const len = line.length;
  while (i < len) {
    const chCode = line.charCodeAt(i);
    if (chCode === 32) {
      indent++;
    } else if (chCode === 9) {
      indent = indent - indent % tabSize + tabSize;
    } else {
      break;
    }
    i++;
  }
  if (i === len) {
    return -1;
  }
  return indent;
}

// node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js
var HorizontalGuidesState;
(function(HorizontalGuidesState2) {
  HorizontalGuidesState2[HorizontalGuidesState2["Disabled"] = 0] = "Disabled";
  HorizontalGuidesState2[HorizontalGuidesState2["EnabledForActive"] = 1] = "EnabledForActive";
  HorizontalGuidesState2[HorizontalGuidesState2["Enabled"] = 2] = "Enabled";
})(HorizontalGuidesState || (HorizontalGuidesState = {}));
var IndentGuide = class {
  constructor(visibleColumn, className, horizontalLine) {
    this.visibleColumn = visibleColumn;
    this.className = className;
    this.horizontalLine = horizontalLine;
  }
};
var IndentGuideHorizontalLine = class {
  constructor(top, endColumn) {
    this.top = top;
    this.endColumn = endColumn;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js
var GuidesTextModelPart = class extends TextModelPart {
  constructor(textModel, languageConfigurationService) {
    super();
    this.textModel = textModel;
    this.languageConfigurationService = languageConfigurationService;
  }
  getLanguageConfiguration(languageId) {
    return this.languageConfigurationService.getLanguageConfiguration(languageId);
  }
  _computeIndentLevel(lineIndex) {
    return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);
  }
  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
    this.assertNotDisposed();
    const lineCount = this.textModel.getLineCount();
    if (lineNumber < 1 || lineNumber > lineCount) {
      throw new Error("Illegal value for lineNumber");
    }
    const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
    const offSide = Boolean(foldingRules && foldingRules.offSide);
    let up_aboveContentLineIndex = -2;
    let up_aboveContentLineIndent = -1;
    let up_belowContentLineIndex = -2;
    let up_belowContentLineIndent = -1;
    const up_resolveIndents = (lineNumber2) => {
      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber2 - 1)) {
        up_aboveContentLineIndex = -1;
        up_aboveContentLineIndent = -1;
        for (let lineIndex = lineNumber2 - 2; lineIndex >= 0; lineIndex--) {
          const indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            up_aboveContentLineIndex = lineIndex;
            up_aboveContentLineIndent = indent2;
            break;
          }
        }
      }
      if (up_belowContentLineIndex === -2) {
        up_belowContentLineIndex = -1;
        up_belowContentLineIndent = -1;
        for (let lineIndex = lineNumber2; lineIndex < lineCount; lineIndex++) {
          const indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            up_belowContentLineIndex = lineIndex;
            up_belowContentLineIndent = indent2;
            break;
          }
        }
      }
    };
    let down_aboveContentLineIndex = -2;
    let down_aboveContentLineIndent = -1;
    let down_belowContentLineIndex = -2;
    let down_belowContentLineIndent = -1;
    const down_resolveIndents = (lineNumber2) => {
      if (down_aboveContentLineIndex === -2) {
        down_aboveContentLineIndex = -1;
        down_aboveContentLineIndent = -1;
        for (let lineIndex = lineNumber2 - 2; lineIndex >= 0; lineIndex--) {
          const indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            down_aboveContentLineIndex = lineIndex;
            down_aboveContentLineIndent = indent2;
            break;
          }
        }
      }
      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber2 - 1)) {
        down_belowContentLineIndex = -1;
        down_belowContentLineIndent = -1;
        for (let lineIndex = lineNumber2; lineIndex < lineCount; lineIndex++) {
          const indent2 = this._computeIndentLevel(lineIndex);
          if (indent2 >= 0) {
            down_belowContentLineIndex = lineIndex;
            down_belowContentLineIndent = indent2;
            break;
          }
        }
      }
    };
    let startLineNumber = 0;
    let goUp = true;
    let endLineNumber = 0;
    let goDown = true;
    let indent = 0;
    let initialIndent = 0;
    for (let distance = 0; goUp || goDown; distance++) {
      const upLineNumber = lineNumber - distance;
      const downLineNumber = lineNumber + distance;
      if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {
        goUp = false;
      }
      if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {
        goDown = false;
      }
      if (distance > 5e4) {
        goUp = false;
        goDown = false;
      }
      let upLineIndentLevel = -1;
      if (goUp && upLineNumber >= 1) {
        const currentIndent = this._computeIndentLevel(upLineNumber - 1);
        if (currentIndent >= 0) {
          up_belowContentLineIndex = upLineNumber - 1;
          up_belowContentLineIndent = currentIndent;
          upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);
        } else {
          up_resolveIndents(upLineNumber);
          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);
        }
      }
      let downLineIndentLevel = -1;
      if (goDown && downLineNumber <= lineCount) {
        const currentIndent = this._computeIndentLevel(downLineNumber - 1);
        if (currentIndent >= 0) {
          down_aboveContentLineIndex = downLineNumber - 1;
          down_aboveContentLineIndent = currentIndent;
          downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);
        } else {
          down_resolveIndents(downLineNumber);
          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);
        }
      }
      if (distance === 0) {
        initialIndent = upLineIndentLevel;
        continue;
      }
      if (distance === 1) {
        if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {
          goUp = false;
          startLineNumber = downLineNumber;
          endLineNumber = downLineNumber;
          indent = downLineIndentLevel;
          continue;
        }
        if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {
          goDown = false;
          startLineNumber = upLineNumber;
          endLineNumber = upLineNumber;
          indent = upLineIndentLevel;
          continue;
        }
        startLineNumber = lineNumber;
        endLineNumber = lineNumber;
        indent = initialIndent;
        if (indent === 0) {
          return { startLineNumber, endLineNumber, indent };
        }
      }
      if (goUp) {
        if (upLineIndentLevel >= indent) {
          startLineNumber = upLineNumber;
        } else {
          goUp = false;
        }
      }
      if (goDown) {
        if (downLineIndentLevel >= indent) {
          endLineNumber = downLineNumber;
        } else {
          goDown = false;
        }
      }
    }
    return { startLineNumber, endLineNumber, indent };
  }
  getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {
    var _a3, _b, _c, _d, _e;
    const result = [];
    const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber)));
    let activeBracketPairRange = void 0;
    if (activePosition && bracketPairs.length > 0) {
      const bracketsContainingActivePosition = startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber ? (
        // Does active position intersect with the view port? -> Intersect bracket pairs with activePosition
        bracketPairs.filter((bp) => Range.strictContainsPosition(bp.range, activePosition))
      ) : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition));
      activeBracketPairRange = (_a3 = findLast(
        bracketsContainingActivePosition,
        /* Exclude single line bracket pairs for cases such as
         * ```
         * function test() {
         * 		if (true) { | }
         * }
         * ```
         */
        (i) => i.range.startLineNumber !== i.range.endLineNumber
      )) === null || _a3 === void 0 ? void 0 : _a3.range;
    }
    const queue = new ArrayQueue(bracketPairs);
    const activeGuides = new Array();
    const nextGuides = new Array();
    const colorProvider = new BracketPairGuidesClassNames();
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      let guides = new Array();
      if (nextGuides.length > 0) {
        guides = guides.concat(nextGuides);
        nextGuides.length = 0;
      }
      result.push(guides);
      for (const pair of queue.takeWhile((b) => b.openingBracketRange.startLineNumber <= lineNumber) || []) {
        if (pair.range.startLineNumber === pair.range.endLineNumber) {
          continue;
        }
        const guideVisibleColumn = Math.min(this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((_c = (_b = pair.closingBracketRange) === null || _b === void 0 ? void 0 : _b.getStartPosition()) !== null && _c !== void 0 ? _c : pair.range.getEndPosition()), pair.minVisibleColumnIndentation + 1);
        let renderHorizontalEndLineAtTheBottom = false;
        if (pair.closingBracketRange) {
          const firstNonWsIndex = firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));
          if (firstNonWsIndex < pair.closingBracketRange.startColumn - 1) {
            renderHorizontalEndLineAtTheBottom = true;
          }
        }
        const start = pair.openingBracketRange.getStartPosition();
        const end = (_e = (_d = pair.closingBracketRange) === null || _d === void 0 ? void 0 : _d.getStartPosition()) !== null && _e !== void 0 ? _e : pair.range.getEndPosition();
        if (pair.closingBracketRange === void 0) {
          activeGuides[pair.nestingLevel] = null;
        } else {
          activeGuides[pair.nestingLevel] = {
            nestingLevel: pair.nestingLevel,
            guideVisibleColumn,
            start,
            visibleStartColumn: this.getVisibleColumnFromPosition(start),
            end,
            visibleEndColumn: this.getVisibleColumnFromPosition(end),
            bracketPair: pair,
            renderHorizontalEndLineAtTheBottom
          };
        }
      }
      for (const line of activeGuides) {
        if (!line) {
          continue;
        }
        const isActive = activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);
        const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) + (options.highlightActive && isActive ? " " + colorProvider.activeClassName : "");
        if (isActive && options.horizontalGuides !== HorizontalGuidesState.Disabled || options.includeInactive && options.horizontalGuides === HorizontalGuidesState.Enabled) {
          if (line.start.lineNumber === lineNumber) {
            if (line.guideVisibleColumn < line.visibleStartColumn) {
              guides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(false, line.start.column)));
            }
          }
          if (line.end.lineNumber === lineNumber + 1) {
            if (line.guideVisibleColumn < line.visibleEndColumn) {
              nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(!line.renderHorizontalEndLineAtTheBottom, line.end.column)));
            }
          }
        }
      }
      let lastVisibleColumnCount = Number.MAX_SAFE_INTEGER;
      for (let i = activeGuides.length - 1; i >= 0; i--) {
        const line = activeGuides[i];
        if (!line) {
          continue;
        }
        const isActive = options.highlightActive && activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);
        const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) + (isActive ? " " + colorProvider.activeClassName : "");
        if (isActive || options.includeInactive) {
          if (line.renderHorizontalEndLineAtTheBottom && line.end.lineNumber === lineNumber + 1) {
            nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, null));
          }
        }
        if (line.end.lineNumber <= lineNumber || line.start.lineNumber >= lineNumber) {
          continue;
        }
        if (line.guideVisibleColumn >= lastVisibleColumnCount && !isActive) {
          continue;
        }
        lastVisibleColumnCount = line.guideVisibleColumn;
        if (isActive || options.includeInactive) {
          guides.push(new IndentGuide(line.guideVisibleColumn, className, null));
        }
      }
      guides.sort((a, b) => a.visibleColumn - b.visibleColumn);
    }
    return result;
  }
  getVisibleColumnFromPosition(position) {
    return CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1;
  }
  getLinesIndentGuides(startLineNumber, endLineNumber) {
    this.assertNotDisposed();
    const lineCount = this.textModel.getLineCount();
    if (startLineNumber < 1 || startLineNumber > lineCount) {
      throw new Error("Illegal value for startLineNumber");
    }
    if (endLineNumber < 1 || endLineNumber > lineCount) {
      throw new Error("Illegal value for endLineNumber");
    }
    const options = this.textModel.getOptions();
    const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
    const offSide = Boolean(foldingRules && foldingRules.offSide);
    const result = new Array(endLineNumber - startLineNumber + 1);
    let aboveContentLineIndex = -2;
    let aboveContentLineIndent = -1;
    let belowContentLineIndex = -2;
    let belowContentLineIndent = -1;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const resultIndex = lineNumber - startLineNumber;
      const currentIndent = this._computeIndentLevel(lineNumber - 1);
      if (currentIndent >= 0) {
        aboveContentLineIndex = lineNumber - 1;
        aboveContentLineIndent = currentIndent;
        result[resultIndex] = Math.ceil(currentIndent / options.indentSize);
        continue;
      }
      if (aboveContentLineIndex === -2) {
        aboveContentLineIndex = -1;
        aboveContentLineIndent = -1;
        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
          const indent = this._computeIndentLevel(lineIndex);
          if (indent >= 0) {
            aboveContentLineIndex = lineIndex;
            aboveContentLineIndent = indent;
            break;
          }
        }
      }
      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
        belowContentLineIndex = -1;
        belowContentLineIndent = -1;
        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
          const indent = this._computeIndentLevel(lineIndex);
          if (indent >= 0) {
            belowContentLineIndex = lineIndex;
            belowContentLineIndent = indent;
            break;
          }
        }
      }
      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);
    }
    return result;
  }
  _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {
    const options = this.textModel.getOptions();
    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {
      return 0;
    } else if (aboveContentLineIndent < belowContentLineIndent) {
      return 1 + Math.floor(aboveContentLineIndent / options.indentSize);
    } else if (aboveContentLineIndent === belowContentLineIndent) {
      return Math.ceil(belowContentLineIndent / options.indentSize);
    } else {
      if (offSide) {
        return Math.ceil(belowContentLineIndent / options.indentSize);
      } else {
        return 1 + Math.floor(belowContentLineIndent / options.indentSize);
      }
    }
  }
};
var BracketPairGuidesClassNames = class {
  constructor() {
    this.activeClassName = "indent-active";
  }
  getInlineClassNameOfLevel(level) {
    return `bracket-indent-guide lvl-${level % 30}`;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js
var SpacesDiffResult = class {
  constructor() {
    this.spacesDiff = 0;
    this.looksLikeAlignment = false;
  }
};
function spacesDiff(a, aLength, b, bLength, result) {
  result.spacesDiff = 0;
  result.looksLikeAlignment = false;
  let i;
  for (i = 0; i < aLength && i < bLength; i++) {
    const aCharCode = a.charCodeAt(i);
    const bCharCode = b.charCodeAt(i);
    if (aCharCode !== bCharCode) {
      break;
    }
  }
  let aSpacesCnt = 0, aTabsCount = 0;
  for (let j = i; j < aLength; j++) {
    const aCharCode = a.charCodeAt(j);
    if (aCharCode === 32) {
      aSpacesCnt++;
    } else {
      aTabsCount++;
    }
  }
  let bSpacesCnt = 0, bTabsCount = 0;
  for (let j = i; j < bLength; j++) {
    const bCharCode = b.charCodeAt(j);
    if (bCharCode === 32) {
      bSpacesCnt++;
    } else {
      bTabsCount++;
    }
  }
  if (aSpacesCnt > 0 && aTabsCount > 0) {
    return;
  }
  if (bSpacesCnt > 0 && bTabsCount > 0) {
    return;
  }
  const tabsDiff = Math.abs(aTabsCount - bTabsCount);
  const spacesDiff2 = Math.abs(aSpacesCnt - bSpacesCnt);
  if (tabsDiff === 0) {
    result.spacesDiff = spacesDiff2;
    if (spacesDiff2 > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {
      if (b.charCodeAt(bSpacesCnt) !== 32 && a.charCodeAt(bSpacesCnt - 1) === 32) {
        if (a.charCodeAt(a.length - 1) === 44) {
          result.looksLikeAlignment = true;
        }
      }
    }
    return;
  }
  if (spacesDiff2 % tabsDiff === 0) {
    result.spacesDiff = spacesDiff2 / tabsDiff;
    return;
  }
}
function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
  const linesCount = Math.min(source.getLineCount(), 1e4);
  let linesIndentedWithTabsCount = 0;
  let linesIndentedWithSpacesCount = 0;
  let previousLineText = "";
  let previousLineIndentation = 0;
  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];
  const MAX_ALLOWED_TAB_SIZE_GUESS = 8;
  const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  const tmp = new SpacesDiffResult();
  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
    const currentLineLength = source.getLineLength(lineNumber);
    const currentLineText = source.getLineContent(lineNumber);
    const useCurrentLineText = currentLineLength <= 65536;
    let currentLineHasContent = false;
    let currentLineIndentation = 0;
    let currentLineSpacesCount = 0;
    let currentLineTabsCount = 0;
    for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {
      const charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);
      if (charCode === 9) {
        currentLineTabsCount++;
      } else if (charCode === 32) {
        currentLineSpacesCount++;
      } else {
        currentLineHasContent = true;
        currentLineIndentation = j;
        break;
      }
    }
    if (!currentLineHasContent) {
      continue;
    }
    if (currentLineTabsCount > 0) {
      linesIndentedWithTabsCount++;
    } else if (currentLineSpacesCount > 1) {
      linesIndentedWithSpacesCount++;
    }
    spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);
    if (tmp.looksLikeAlignment) {
      if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {
        continue;
      }
    }
    const currentSpacesDiff = tmp.spacesDiff;
    if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
      spacesDiffCount[currentSpacesDiff]++;
    }
    previousLineText = currentLineText;
    previousLineIndentation = currentLineIndentation;
  }
  let insertSpaces = defaultInsertSpaces;
  if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
    insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;
  }
  let tabSize = defaultTabSize;
  if (insertSpaces) {
    let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;
    ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {
      const possibleTabSizeScore = spacesDiffCount[possibleTabSize];
      if (possibleTabSizeScore > tabSizeScore) {
        tabSizeScore = possibleTabSizeScore;
        tabSize = possibleTabSize;
      }
    });
    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {
      tabSize = 2;
    }
  }
  return {
    insertSpaces,
    tabSize
  };
}

// node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js
function getNodeColor(node) {
  return (node.metadata & 1) >>> 0;
}
function setNodeColor(node, color) {
  node.metadata = node.metadata & 254 | color << 0;
}
function getNodeIsVisited(node) {
  return (node.metadata & 2) >>> 1 === 1;
}
function setNodeIsVisited(node, value) {
  node.metadata = node.metadata & 253 | (value ? 1 : 0) << 1;
}
function getNodeIsForValidation(node) {
  return (node.metadata & 4) >>> 2 === 1;
}
function setNodeIsForValidation(node, value) {
  node.metadata = node.metadata & 251 | (value ? 1 : 0) << 2;
}
function getNodeStickiness(node) {
  return (node.metadata & 24) >>> 3;
}
function _setNodeStickiness(node, stickiness) {
  node.metadata = node.metadata & 231 | stickiness << 3;
}
function getCollapseOnReplaceEdit(node) {
  return (node.metadata & 32) >>> 5 === 1;
}
function setCollapseOnReplaceEdit(node, value) {
  node.metadata = node.metadata & 223 | (value ? 1 : 0) << 5;
}
var IntervalNode = class {
  constructor(id, start, end) {
    this.metadata = 0;
    this.parent = this;
    this.left = this;
    this.right = this;
    setNodeColor(
      this,
      1
      /* Red */
    );
    this.start = start;
    this.end = end;
    this.delta = 0;
    this.maxEnd = end;
    this.id = id;
    this.ownerId = 0;
    this.options = null;
    setNodeIsForValidation(this, false);
    _setNodeStickiness(
      this,
      1
      /* NeverGrowsWhenTypingAtEdges */
    );
    setCollapseOnReplaceEdit(this, false);
    this.cachedVersionId = 0;
    this.cachedAbsoluteStart = start;
    this.cachedAbsoluteEnd = end;
    this.range = null;
    setNodeIsVisited(this, false);
  }
  reset(versionId, start, end, range2) {
    this.start = start;
    this.end = end;
    this.maxEnd = end;
    this.cachedVersionId = versionId;
    this.cachedAbsoluteStart = start;
    this.cachedAbsoluteEnd = end;
    this.range = range2;
  }
  setOptions(options) {
    this.options = options;
    const className = this.options.className;
    setNodeIsForValidation(this, className === "squiggly-error" || className === "squiggly-warning" || className === "squiggly-info");
    _setNodeStickiness(this, this.options.stickiness);
    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {
    if (this.cachedVersionId !== cachedVersionId) {
      this.range = null;
    }
    this.cachedVersionId = cachedVersionId;
    this.cachedAbsoluteStart = absoluteStart;
    this.cachedAbsoluteEnd = absoluteEnd;
  }
  detach() {
    this.parent = null;
    this.left = null;
    this.right = null;
  }
};
var SENTINEL = new IntervalNode(null, 0, 0);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
setNodeColor(
  SENTINEL,
  0
  /* Black */
);
var IntervalTree = class {
  constructor() {
    this.root = SENTINEL;
    this.requestNormalizeDelta = false;
  }
  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
    if (this.root === SENTINEL) {
      return [];
    }
    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);
  }
  search(filterOwnerId, filterOutValidation, cachedVersionId) {
    if (this.root === SENTINEL) {
      return [];
    }
    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(ownerId) {
    return collectNodesFromOwner(this, ownerId);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return collectNodesPostOrder(this);
  }
  insert(node) {
    rbTreeInsert(this, node);
    this._normalizeDeltaIfNecessary();
  }
  delete(node) {
    rbTreeDelete(this, node);
    this._normalizeDeltaIfNecessary();
  }
  resolveNode(node, cachedVersionId) {
    const initialNode = node;
    let delta = 0;
    while (node !== this.root) {
      if (node === node.parent.right) {
        delta += node.parent.delta;
      }
      node = node.parent;
    }
    const nodeStart = initialNode.start + delta;
    const nodeEnd = initialNode.end + delta;
    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
  }
  acceptReplace(offset, length, textLength, forceMoveMarkers) {
    const nodesOfInterest = searchForEditing(this, offset, offset + length);
    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
      const node = nodesOfInterest[i];
      rbTreeDelete(this, node);
    }
    this._normalizeDeltaIfNecessary();
    noOverlapReplace(this, offset, offset + length, textLength);
    this._normalizeDeltaIfNecessary();
    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
      const node = nodesOfInterest[i];
      node.start = node.cachedAbsoluteStart;
      node.end = node.cachedAbsoluteEnd;
      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);
      node.maxEnd = node.end;
      rbTreeInsert(this, node);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    if (!this.requestNormalizeDelta) {
      return;
    }
    this.requestNormalizeDelta = false;
    normalizeDelta(this);
  }
};
function normalizeDelta(T) {
  let node = T.root;
  let delta = 0;
  while (node !== SENTINEL) {
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
    node.start = delta + node.start;
    node.end = delta + node.end;
    node.delta = 0;
    recomputeMaxEnd(node);
    setNodeIsVisited(node, true);
    setNodeIsVisited(node.left, false);
    setNodeIsVisited(node.right, false);
    if (node === node.parent.right) {
      delta -= node.parent.delta;
    }
    node = node.parent;
  }
  setNodeIsVisited(T.root, false);
}
function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
  if (markerOffset < checkOffset) {
    return true;
  }
  if (markerOffset > checkOffset) {
    return false;
  }
  if (moveSemantics === 1) {
    return false;
  }
  if (moveSemantics === 2) {
    return true;
  }
  return markerStickToPreviousCharacter;
}
function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
  const nodeStickiness = getNodeStickiness(node);
  const startStickToPreviousCharacter = nodeStickiness === 0 || nodeStickiness === 2;
  const endStickToPreviousCharacter = nodeStickiness === 1 || nodeStickiness === 2;
  const deletingCnt = end - start;
  const insertingCnt = textLength;
  const commonLength = Math.min(deletingCnt, insertingCnt);
  const nodeStart = node.start;
  let startDone = false;
  const nodeEnd = node.end;
  let endDone = false;
  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {
    node.start = start;
    startDone = true;
    node.end = start;
    endDone = true;
  }
  {
    const moveSemantics = forceMoveMarkers ? 1 : deletingCnt > 0 ? 2 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {
      endDone = true;
    }
  }
  if (commonLength > 0 && !forceMoveMarkers) {
    const moveSemantics = deletingCnt > insertingCnt ? 2 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {
      endDone = true;
    }
  }
  {
    const moveSemantics = forceMoveMarkers ? 1 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {
      node.start = start + insertingCnt;
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {
      node.end = start + insertingCnt;
      endDone = true;
    }
  }
  const deltaColumn = insertingCnt - deletingCnt;
  if (!startDone) {
    node.start = Math.max(0, nodeStart + deltaColumn);
  }
  if (!endDone) {
    node.end = Math.max(0, nodeEnd + deltaColumn);
  }
  if (node.start > node.end) {
    node.end = node.start;
  }
}
function searchForEditing(T, start, end) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < start) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > end) {
      setNodeIsVisited(node, true);
      continue;
    }
    nodeEnd = delta + node.end;
    if (nodeEnd >= start) {
      node.setCachedOffsets(nodeStart, nodeEnd, 0);
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function noOverlapReplace(T, start, end, textLength) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  const editDelta = textLength - (end - start);
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      recomputeMaxEnd(node);
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < start) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > end) {
      node.start += editDelta;
      node.end += editDelta;
      node.delta += editDelta;
      if (node.delta < -1073741824 || node.delta > 1073741824) {
        T.requestNormalizeDelta = true;
      }
      setNodeIsVisited(node, true);
      continue;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
}
function collectNodesFromOwner(T, ownerId) {
  let node = T.root;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.ownerId === ownerId) {
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function collectNodesPostOrder(T) {
  let node = T.root;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      node = node.right;
      continue;
    }
    result[resultLen++] = node;
    setNodeIsVisited(node, true);
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function search(T, filterOwnerId, filterOutValidation, cachedVersionId) {
  let node = T.root;
  let delta = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    nodeStart = delta + node.start;
    nodeEnd = delta + node.end;
    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
    let include = true;
    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
      include = false;
    }
    if (filterOutValidation && getNodeIsForValidation(node)) {
      include = false;
    }
    if (include) {
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < intervalStart) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > intervalEnd) {
      setNodeIsVisited(node, true);
      continue;
    }
    nodeEnd = delta + node.end;
    if (nodeEnd >= intervalStart) {
      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
      let include = true;
      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
        include = false;
      }
      if (filterOutValidation && getNodeIsForValidation(node)) {
        include = false;
      }
      if (include) {
        result[resultLen++] = node;
      }
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function rbTreeInsert(T, newNode) {
  if (T.root === SENTINEL) {
    newNode.parent = SENTINEL;
    newNode.left = SENTINEL;
    newNode.right = SENTINEL;
    setNodeColor(
      newNode,
      0
      /* Black */
    );
    T.root = newNode;
    return T.root;
  }
  treeInsert(T, newNode);
  recomputeMaxEndWalkToRoot(newNode.parent);
  let x = newNode;
  while (x !== T.root && getNodeColor(x.parent) === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (getNodeColor(y) === 1) {
        setNodeColor(
          x.parent,
          0
          /* Black */
        );
        setNodeColor(
          y,
          0
          /* Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* Red */
        );
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate(T, x);
        }
        setNodeColor(
          x.parent,
          0
          /* Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* Red */
        );
        rightRotate(T, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (getNodeColor(y) === 1) {
        setNodeColor(
          x.parent,
          0
          /* Black */
        );
        setNodeColor(
          y,
          0
          /* Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* Red */
        );
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate(T, x);
        }
        setNodeColor(
          x.parent,
          0
          /* Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* Red */
        );
        leftRotate(T, x.parent.parent);
      }
    }
  }
  setNodeColor(
    T.root,
    0
    /* Black */
  );
  return newNode;
}
function treeInsert(T, z) {
  let delta = 0;
  let x = T.root;
  const zAbsoluteStart = z.start;
  const zAbsoluteEnd = z.end;
  while (true) {
    const cmp3 = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);
    if (cmp3 < 0) {
      if (x.left === SENTINEL) {
        z.start -= delta;
        z.end -= delta;
        z.maxEnd -= delta;
        x.left = z;
        break;
      } else {
        x = x.left;
      }
    } else {
      if (x.right === SENTINEL) {
        z.start -= delta + x.delta;
        z.end -= delta + x.delta;
        z.maxEnd -= delta + x.delta;
        x.right = z;
        break;
      } else {
        delta += x.delta;
        x = x.right;
      }
    }
  }
  z.parent = x;
  z.left = SENTINEL;
  z.right = SENTINEL;
  setNodeColor(
    z,
    1
    /* Red */
  );
}
function rbTreeDelete(T, z) {
  let x;
  let y;
  if (z.left === SENTINEL) {
    x = z.right;
    y = z;
    x.delta += z.delta;
    if (x.delta < -1073741824 || x.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
    x.start += z.delta;
    x.end += z.delta;
  } else if (z.right === SENTINEL) {
    x = z.left;
    y = z;
  } else {
    y = leftest(z.right);
    x = y.right;
    x.start += y.delta;
    x.end += y.delta;
    x.delta += y.delta;
    if (x.delta < -1073741824 || x.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
    y.start += z.delta;
    y.end += z.delta;
    y.delta = z.delta;
    if (y.delta < -1073741824 || y.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
  }
  if (y === T.root) {
    T.root = x;
    setNodeColor(
      x,
      0
      /* Black */
    );
    z.detach();
    resetSentinel();
    recomputeMaxEnd(x);
    T.root.parent = SENTINEL;
    return;
  }
  const yWasRed = getNodeColor(y) === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    setNodeColor(y, getNodeColor(z));
    if (z === T.root) {
      T.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL) {
      y.right.parent = y;
    }
  }
  z.detach();
  if (yWasRed) {
    recomputeMaxEndWalkToRoot(x.parent);
    if (y !== z) {
      recomputeMaxEndWalkToRoot(y);
      recomputeMaxEndWalkToRoot(y.parent);
    }
    resetSentinel();
    return;
  }
  recomputeMaxEndWalkToRoot(x);
  recomputeMaxEndWalkToRoot(x.parent);
  if (y !== z) {
    recomputeMaxEndWalkToRoot(y);
    recomputeMaxEndWalkToRoot(y.parent);
  }
  let w;
  while (x !== T.root && getNodeColor(x) === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (getNodeColor(w) === 1) {
        setNodeColor(
          w,
          0
          /* Black */
        );
        setNodeColor(
          x.parent,
          1
          /* Red */
        );
        leftRotate(T, x.parent);
        w = x.parent.right;
      }
      if (getNodeColor(w.left) === 0 && getNodeColor(w.right) === 0) {
        setNodeColor(
          w,
          1
          /* Red */
        );
        x = x.parent;
      } else {
        if (getNodeColor(w.right) === 0) {
          setNodeColor(
            w.left,
            0
            /* Black */
          );
          setNodeColor(
            w,
            1
            /* Red */
          );
          rightRotate(T, w);
          w = x.parent.right;
        }
        setNodeColor(w, getNodeColor(x.parent));
        setNodeColor(
          x.parent,
          0
          /* Black */
        );
        setNodeColor(
          w.right,
          0
          /* Black */
        );
        leftRotate(T, x.parent);
        x = T.root;
      }
    } else {
      w = x.parent.left;
      if (getNodeColor(w) === 1) {
        setNodeColor(
          w,
          0
          /* Black */
        );
        setNodeColor(
          x.parent,
          1
          /* Red */
        );
        rightRotate(T, x.parent);
        w = x.parent.left;
      }
      if (getNodeColor(w.left) === 0 && getNodeColor(w.right) === 0) {
        setNodeColor(
          w,
          1
          /* Red */
        );
        x = x.parent;
      } else {
        if (getNodeColor(w.left) === 0) {
          setNodeColor(
            w.right,
            0
            /* Black */
          );
          setNodeColor(
            w,
            1
            /* Red */
          );
          leftRotate(T, w);
          w = x.parent.left;
        }
        setNodeColor(w, getNodeColor(x.parent));
        setNodeColor(
          x.parent,
          0
          /* Black */
        );
        setNodeColor(
          w.left,
          0
          /* Black */
        );
        rightRotate(T, x.parent);
        x = T.root;
      }
    }
  }
  setNodeColor(
    x,
    0
    /* Black */
  );
  resetSentinel();
}
function leftest(node) {
  while (node.left !== SENTINEL) {
    node = node.left;
  }
  return node;
}
function resetSentinel() {
  SENTINEL.parent = SENTINEL;
  SENTINEL.delta = 0;
  SENTINEL.start = 0;
  SENTINEL.end = 0;
}
function leftRotate(T, x) {
  const y = x.right;
  y.delta += x.delta;
  if (y.delta < -1073741824 || y.delta > 1073741824) {
    T.requestNormalizeDelta = true;
  }
  y.start += x.delta;
  y.end += x.delta;
  x.right = y.left;
  if (y.left !== SENTINEL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL) {
    T.root = y;
  } else if (x === x.parent.left) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
  recomputeMaxEnd(x);
  recomputeMaxEnd(y);
}
function rightRotate(T, y) {
  const x = y.left;
  y.delta -= x.delta;
  if (y.delta < -1073741824 || y.delta > 1073741824) {
    T.requestNormalizeDelta = true;
  }
  y.start -= x.delta;
  y.end -= x.delta;
  y.left = x.right;
  if (x.right !== SENTINEL) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  if (y.parent === SENTINEL) {
    T.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
  recomputeMaxEnd(y);
  recomputeMaxEnd(x);
}
function computeMaxEnd(node) {
  let maxEnd = node.end;
  if (node.left !== SENTINEL) {
    const leftMaxEnd = node.left.maxEnd;
    if (leftMaxEnd > maxEnd) {
      maxEnd = leftMaxEnd;
    }
  }
  if (node.right !== SENTINEL) {
    const rightMaxEnd = node.right.maxEnd + node.delta;
    if (rightMaxEnd > maxEnd) {
      maxEnd = rightMaxEnd;
    }
  }
  return maxEnd;
}
function recomputeMaxEnd(node) {
  node.maxEnd = computeMaxEnd(node);
}
function recomputeMaxEndWalkToRoot(node) {
  while (node !== SENTINEL) {
    const maxEnd = computeMaxEnd(node);
    if (node.maxEnd === maxEnd) {
      return;
    }
    node.maxEnd = maxEnd;
    node = node.parent;
  }
}
function intervalCompare(aStart, aEnd, bStart, bEnd) {
  if (aStart === bStart) {
    return aEnd - bEnd;
  }
  return aStart - bStart;
}

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js
var TreeNode = class {
  constructor(piece, color) {
    this.piece = piece;
    this.color = color;
    this.size_left = 0;
    this.lf_left = 0;
    this.parent = this;
    this.left = this;
    this.right = this;
  }
  next() {
    if (this.right !== SENTINEL2) {
      return leftest2(this.right);
    }
    let node = this;
    while (node.parent !== SENTINEL2) {
      if (node.parent.left === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL2) {
      return SENTINEL2;
    } else {
      return node.parent;
    }
  }
  prev() {
    if (this.left !== SENTINEL2) {
      return righttest(this.left);
    }
    let node = this;
    while (node.parent !== SENTINEL2) {
      if (node.parent.right === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL2) {
      return SENTINEL2;
    } else {
      return node.parent;
    }
  }
  detach() {
    this.parent = null;
    this.left = null;
    this.right = null;
  }
};
var SENTINEL2 = new TreeNode(
  null,
  0
  /* Black */
);
SENTINEL2.parent = SENTINEL2;
SENTINEL2.left = SENTINEL2;
SENTINEL2.right = SENTINEL2;
SENTINEL2.color = 0;
function leftest2(node) {
  while (node.left !== SENTINEL2) {
    node = node.left;
  }
  return node;
}
function righttest(node) {
  while (node.right !== SENTINEL2) {
    node = node.right;
  }
  return node;
}
function calculateSize(node) {
  if (node === SENTINEL2) {
    return 0;
  }
  return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
  if (node === SENTINEL2) {
    return 0;
  }
  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel2() {
  SENTINEL2.parent = SENTINEL2;
}
function leftRotate2(tree, x) {
  const y = x.right;
  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  x.right = y.left;
  if (y.left !== SENTINEL2) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL2) {
    tree.root = y;
  } else if (x.parent.left === x) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
}
function rightRotate2(tree, y) {
  const x = y.left;
  y.left = x.right;
  if (x.right !== SENTINEL2) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  if (y.parent === SENTINEL2) {
    tree.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
}
function rbDelete(tree, z) {
  let x;
  let y;
  if (z.left === SENTINEL2) {
    y = z;
    x = y.right;
  } else if (z.right === SENTINEL2) {
    y = z;
    x = y.left;
  } else {
    y = leftest2(z.right);
    x = y.right;
  }
  if (y === tree.root) {
    tree.root = x;
    x.color = 0;
    z.detach();
    resetSentinel2();
    tree.root.parent = SENTINEL2;
    return;
  }
  const yWasRed = y.color === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
    recomputeTreeMetadata(tree, x);
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    recomputeTreeMetadata(tree, x);
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    y.color = z.color;
    if (z === tree.root) {
      tree.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL2) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL2) {
      y.right.parent = y;
    }
    y.size_left = z.size_left;
    y.lf_left = z.lf_left;
    recomputeTreeMetadata(tree, y);
  }
  z.detach();
  if (x.parent.left === x) {
    const newSizeLeft = calculateSize(x);
    const newLFLeft = calculateLF(x);
    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
      const delta = newSizeLeft - x.parent.size_left;
      const lf_delta = newLFLeft - x.parent.lf_left;
      x.parent.size_left = newSizeLeft;
      x.parent.lf_left = newLFLeft;
      updateTreeMetadata(tree, x.parent, delta, lf_delta);
    }
  }
  recomputeTreeMetadata(tree, x.parent);
  if (yWasRed) {
    resetSentinel2();
    return;
  }
  let w;
  while (x !== tree.root && x.color === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        leftRotate2(tree, x.parent);
        w = x.parent.right;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.right.color === 0) {
          w.left.color = 0;
          w.color = 1;
          rightRotate2(tree, w);
          w = x.parent.right;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.right.color = 0;
        leftRotate2(tree, x.parent);
        x = tree.root;
      }
    } else {
      w = x.parent.left;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        rightRotate2(tree, x.parent);
        w = x.parent.left;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.left.color === 0) {
          w.right.color = 0;
          w.color = 1;
          leftRotate2(tree, w);
          w = x.parent.left;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.left.color = 0;
        rightRotate2(tree, x.parent);
        x = tree.root;
      }
    }
  }
  x.color = 0;
  resetSentinel2();
}
function fixInsert(tree, x) {
  recomputeTreeMetadata(tree, x);
  while (x !== tree.root && x.parent.color === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate2(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        rightRotate2(tree, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate2(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        leftRotate2(tree, x.parent.parent);
      }
    }
  }
  tree.root.color = 0;
}
function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
  while (x !== tree.root && x !== SENTINEL2) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lineFeedCntDelta;
    }
    x = x.parent;
  }
}
function recomputeTreeMetadata(tree, x) {
  let delta = 0;
  let lf_delta = 0;
  if (x === tree.root) {
    return;
  }
  while (x !== tree.root && x === x.parent.right) {
    x = x.parent;
  }
  if (x === tree.root) {
    return;
  }
  x = x.parent;
  delta = calculateSize(x.left) - x.size_left;
  lf_delta = calculateLF(x.left) - x.lf_left;
  x.size_left += delta;
  x.lf_left += lf_delta;
  while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lf_delta;
    }
    x = x.parent;
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js
var AverageBufferSize = 65535;
function createUintArray(arr) {
  let r;
  if (arr[arr.length - 1] < 65536) {
    r = new Uint16Array(arr.length);
  } else {
    r = new Uint32Array(arr.length);
  }
  r.set(arr, 0);
  return r;
}
var LineStarts = class {
  constructor(lineStarts, cr, lf, crlf, isBasicASCII2) {
    this.lineStarts = lineStarts;
    this.cr = cr;
    this.lf = lf;
    this.crlf = crlf;
    this.isBasicASCII = isBasicASCII2;
  }
};
function createLineStartsFast(str, readonly = true) {
  const r = [0];
  let rLength = 1;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        r[rLength++] = i + 2;
        i++;
      } else {
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      r[rLength++] = i + 1;
    }
  }
  if (readonly) {
    return createUintArray(r);
  } else {
    return r;
  }
}
function createLineStarts(r, str) {
  r.length = 0;
  r[0] = 0;
  let rLength = 1;
  let cr = 0, lf = 0, crlf = 0;
  let isBasicASCII2 = true;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        crlf++;
        r[rLength++] = i + 2;
        i++;
      } else {
        cr++;
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      lf++;
      r[rLength++] = i + 1;
    } else {
      if (isBasicASCII2) {
        if (chr !== 9 && (chr < 32 || chr > 126)) {
          isBasicASCII2 = false;
        }
      }
    }
  }
  const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII2);
  r.length = 0;
  return result;
}
var Piece = class {
  constructor(bufferIndex, start, end, lineFeedCnt, length) {
    this.bufferIndex = bufferIndex;
    this.start = start;
    this.end = end;
    this.lineFeedCnt = lineFeedCnt;
    this.length = length;
  }
};
var StringBuffer = class {
  constructor(buffer, lineStarts) {
    this.buffer = buffer;
    this.lineStarts = lineStarts;
  }
};
var PieceTreeSnapshot = class {
  constructor(tree, BOM) {
    this._pieces = [];
    this._tree = tree;
    this._BOM = BOM;
    this._index = 0;
    if (tree.root !== SENTINEL2) {
      tree.iterate(tree.root, (node) => {
        if (node !== SENTINEL2) {
          this._pieces.push(node.piece);
        }
        return true;
      });
    }
  }
  read() {
    if (this._pieces.length === 0) {
      if (this._index === 0) {
        this._index++;
        return this._BOM;
      } else {
        return null;
      }
    }
    if (this._index > this._pieces.length - 1) {
      return null;
    }
    if (this._index === 0) {
      return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
    }
    return this._tree.getPieceContent(this._pieces[this._index++]);
  }
};
var PieceTreeSearchCache = class {
  constructor(limit) {
    this._limit = limit;
    this._cache = [];
  }
  get(offset) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const nodePos = this._cache[i];
      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
        return nodePos;
      }
    }
    return null;
  }
  get2(lineNumber) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const nodePos = this._cache[i];
      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
        return nodePos;
      }
    }
    return null;
  }
  set(nodePosition) {
    if (this._cache.length >= this._limit) {
      this._cache.shift();
    }
    this._cache.push(nodePosition);
  }
  validate(offset) {
    let hasInvalidVal = false;
    const tmp = this._cache;
    for (let i = 0; i < tmp.length; i++) {
      const nodePos = tmp[i];
      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
        tmp[i] = null;
        hasInvalidVal = true;
        continue;
      }
    }
    if (hasInvalidVal) {
      const newArr = [];
      for (const entry of tmp) {
        if (entry !== null) {
          newArr.push(entry);
        }
      }
      this._cache = newArr;
    }
  }
};
var PieceTreeBase = class {
  constructor(chunks, eol, eolNormalized) {
    this.create(chunks, eol, eolNormalized);
  }
  create(chunks, eol, eolNormalized) {
    this._buffers = [
      new StringBuffer("", [0])
    ];
    this._lastChangeBufferPos = { line: 0, column: 0 };
    this.root = SENTINEL2;
    this._lineCnt = 1;
    this._length = 0;
    this._EOL = eol;
    this._EOLLength = eol.length;
    this._EOLNormalized = eolNormalized;
    let lastNode = null;
    for (let i = 0, len = chunks.length; i < len; i++) {
      if (chunks[i].buffer.length > 0) {
        if (!chunks[i].lineStarts) {
          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
        }
        const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
        this._buffers.push(chunks[i]);
        lastNode = this.rbInsertRight(lastNode, piece);
      }
    }
    this._searchCache = new PieceTreeSearchCache(1);
    this._lastVisitedLine = { lineNumber: 0, value: "" };
    this.computeBufferMetadata();
  }
  normalizeEOL(eol) {
    const averageBufferSize = AverageBufferSize;
    const min = averageBufferSize - Math.floor(averageBufferSize / 3);
    const max = min * 2;
    let tempChunk = "";
    let tempChunkLen = 0;
    const chunks = [];
    this.iterate(this.root, (node) => {
      const str = this.getNodeContent(node);
      const len = str.length;
      if (tempChunkLen <= min || tempChunkLen + len < max) {
        tempChunk += str;
        tempChunkLen += len;
        return true;
      }
      const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
      tempChunk = str;
      tempChunkLen = len;
      return true;
    });
    if (tempChunkLen > 0) {
      const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
    }
    this.create(chunks, eol, true);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(newEOL) {
    this._EOL = newEOL;
    this._EOLLength = this._EOL.length;
    this.normalizeEOL(newEOL);
  }
  createSnapshot(BOM) {
    return new PieceTreeSnapshot(this, BOM);
  }
  getOffsetAt(lineNumber, column) {
    let leftLen = 0;
    let x = this.root;
    while (x !== SENTINEL2) {
      if (x.left !== SENTINEL2 && x.lf_left + 1 >= lineNumber) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
        leftLen += x.size_left;
        const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        return leftLen += accumualtedValInCurrentIndex + column - 1;
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        leftLen += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return leftLen;
  }
  getPositionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    let x = this.root;
    let lfCnt = 0;
    const originalOffset = offset;
    while (x !== SENTINEL2) {
      if (x.size_left !== 0 && x.size_left >= offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        const out = this.getIndexOf(x, offset - x.size_left);
        lfCnt += x.lf_left + out.index;
        if (out.index === 0) {
          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          const column = originalOffset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        }
        return new Position(lfCnt + 1, out.remainder + 1);
      } else {
        offset -= x.size_left + x.piece.length;
        lfCnt += x.lf_left + x.piece.lineFeedCnt;
        if (x.right === SENTINEL2) {
          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          const column = originalOffset - offset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        } else {
          x = x.right;
        }
      }
    }
    return new Position(1, 1);
  }
  getValueInRange(range2, eol) {
    if (range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn) {
      return "";
    }
    const startPosition = this.nodeAt2(range2.startLineNumber, range2.startColumn);
    const endPosition = this.nodeAt2(range2.endLineNumber, range2.endColumn);
    const value = this.getValueInRange2(startPosition, endPosition);
    if (eol) {
      if (eol !== this._EOL || !this._EOLNormalized) {
        return value.replace(/\r\n|\r|\n/g, eol);
      }
      if (eol === this.getEOL() && this._EOLNormalized) {
        if (eol === "\r\n") {
        }
        return value;
      }
      return value.replace(/\r\n|\r|\n/g, eol);
    }
    return value;
  }
  getValueInRange2(startPosition, endPosition) {
    if (startPosition.node === endPosition.node) {
      const node = startPosition.node;
      const buffer2 = this._buffers[node.piece.bufferIndex].buffer;
      const startOffset2 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
      return buffer2.substring(startOffset2 + startPosition.remainder, startOffset2 + endPosition.remainder);
    }
    let x = startPosition.node;
    const buffer = this._buffers[x.piece.bufferIndex].buffer;
    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
    let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
    x = x.next();
    while (x !== SENTINEL2) {
      const buffer2 = this._buffers[x.piece.bufferIndex].buffer;
      const startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (x === endPosition.node) {
        ret += buffer2.substring(startOffset2, startOffset2 + endPosition.remainder);
        break;
      } else {
        ret += buffer2.substr(startOffset2, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  getLinesContent() {
    const lines = [];
    let linesLength = 0;
    let currentLine = "";
    let danglingCR = false;
    this.iterate(this.root, (node) => {
      if (node === SENTINEL2) {
        return true;
      }
      const piece = node.piece;
      let pieceLength = piece.length;
      if (pieceLength === 0) {
        return true;
      }
      const buffer = this._buffers[piece.bufferIndex].buffer;
      const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
      const pieceStartLine = piece.start.line;
      const pieceEndLine = piece.end.line;
      let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
      if (danglingCR) {
        if (buffer.charCodeAt(pieceStartOffset) === 10) {
          pieceStartOffset++;
          pieceLength--;
        }
        lines[linesLength++] = currentLine;
        currentLine = "";
        danglingCR = false;
        if (pieceLength === 0) {
          return true;
        }
      }
      if (pieceStartLine === pieceEndLine) {
        if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13) {
          danglingCR = true;
          currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);
        } else {
          currentLine += buffer.substr(pieceStartOffset, pieceLength);
        }
        return true;
      }
      currentLine += this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, "");
      lines[linesLength++] = currentLine;
      for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
        currentLine = this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, "");
        lines[linesLength++] = currentLine;
      }
      if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13) {
        danglingCR = true;
        if (piece.end.column === 0) {
          linesLength--;
        } else {
          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);
        }
      } else {
        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);
      }
      return true;
    });
    if (danglingCR) {
      lines[linesLength++] = currentLine;
      currentLine = "";
    }
    lines[linesLength++] = currentLine;
    return lines;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(lineNumber) {
    if (this._lastVisitedLine.lineNumber === lineNumber) {
      return this._lastVisitedLine.value;
    }
    this._lastVisitedLine.lineNumber = lineNumber;
    if (lineNumber === this._lineCnt) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
    } else if (this._EOLNormalized) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
    } else {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, "");
    }
    return this._lastVisitedLine.value;
  }
  _getCharCode(nodePos) {
    if (nodePos.remainder === nodePos.node.piece.length) {
      const matchingNode = nodePos.node.next();
      if (!matchingNode) {
        return 0;
      }
      const buffer = this._buffers[matchingNode.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
      return buffer.buffer.charCodeAt(startOffset);
    } else {
      const buffer = this._buffers[nodePos.node.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
      const targetOffset = startOffset + nodePos.remainder;
      return buffer.buffer.charCodeAt(targetOffset);
    }
  }
  getLineCharCode(lineNumber, index) {
    const nodePos = this.nodeAt2(lineNumber, index + 1);
    return this._getCharCode(nodePos);
  }
  getLineLength(lineNumber) {
    if (lineNumber === this.getLineCount()) {
      const startOffset = this.getOffsetAt(lineNumber, 1);
      return this.getLength() - startOffset;
    }
    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
  }
  findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
    const buffer = this._buffers[node.piece.bufferIndex];
    const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
    const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
    const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
    let m;
    const ret = { line: 0, column: 0 };
    let searchText;
    let offsetInBuffer;
    if (searcher._wordSeparators) {
      searchText = buffer.buffer.substring(start, end);
      offsetInBuffer = (offset) => offset + start;
      searcher.reset(0);
    } else {
      searchText = buffer.buffer;
      offsetInBuffer = (offset) => offset;
      searcher.reset(start);
    }
    do {
      m = searcher.next(searchText);
      if (m) {
        if (offsetInBuffer(m.index) >= end) {
          return resultLen;
        }
        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
        const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
        const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
        const retEndColumn = retStartColumn + m[0].length;
        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
        if (offsetInBuffer(m.index) + m[0].length >= end) {
          return resultLen;
        }
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    const result = [];
    let resultLen = 0;
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
    if (startPosition === null) {
      return [];
    }
    const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
    if (endPosition === null) {
      return [];
    }
    let start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    const end = this.positionInBuffer(endPosition.node, endPosition.remainder);
    if (startPosition.node === endPosition.node) {
      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
      return result;
    }
    let startLineNumber = searchRange.startLineNumber;
    let currentNode = startPosition.node;
    while (currentNode !== endPosition.node) {
      const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
      if (lineBreakCnt >= 1) {
        const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
        const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
        const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
        const startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn3, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
        if (resultLen >= limitResultCount) {
          return result;
        }
        startLineNumber += lineBreakCnt;
      }
      const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      if (startLineNumber === searchRange.endLineNumber) {
        const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
        return result;
      }
      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn2), startLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
      if (resultLen >= limitResultCount) {
        return result;
      }
      startLineNumber++;
      startPosition = this.nodeAt2(startLineNumber, 1);
      currentNode = startPosition.node;
      start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    }
    if (startLineNumber === searchRange.endLineNumber) {
      const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
      return result;
    }
    const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
    return result;
  }
  _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
          if (resultLen >= limitResultCount) {
            return resultLen;
          }
        }
      }
      return resultLen;
    }
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  // #endregion
  // #region Piece Table
  insert(offset, value, eolNormalized = false) {
    this._EOLNormalized = this._EOLNormalized && eolNormalized;
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (this.root !== SENTINEL2) {
      const { node, remainder, nodeStartOffset } = this.nodeAt(offset);
      const piece = node.piece;
      const bufferIndex = piece.bufferIndex;
      const insertPosInBuffer = this.positionInBuffer(node, remainder);
      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {
        this.appendToNode(node, value);
        this.computeBufferMetadata();
        return;
      }
      if (nodeStartOffset === offset) {
        this.insertContentToNodeLeft(value, node);
        this._searchCache.validate(offset);
      } else if (nodeStartOffset + node.piece.length > offset) {
        const nodesToDel = [];
        let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
          const headOfRight = this.nodeCharCodeAt(node, remainder);
          if (headOfRight === 10) {
            const newStart = { line: newRightPiece.start.line + 1, column: 0 };
            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
            value += "\n";
          }
        }
        if (this.shouldCheckCRLF() && this.startWithLF(value)) {
          const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
          if (tailOfLeft === 13) {
            const previousPos = this.positionInBuffer(node, remainder - 1);
            this.deleteNodeTail(node, previousPos);
            value = "\r" + value;
            if (node.piece.length === 0) {
              nodesToDel.push(node);
            }
          } else {
            this.deleteNodeTail(node, insertPosInBuffer);
          }
        } else {
          this.deleteNodeTail(node, insertPosInBuffer);
        }
        const newPieces = this.createNewPieces(value);
        if (newRightPiece.length > 0) {
          this.rbInsertRight(node, newRightPiece);
        }
        let tmpNode = node;
        for (let k = 0; k < newPieces.length; k++) {
          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.deleteNodes(nodesToDel);
      } else {
        this.insertContentToNodeRight(value, node);
      }
    } else {
      const pieces = this.createNewPieces(value);
      let node = this.rbInsertLeft(null, pieces[0]);
      for (let k = 1; k < pieces.length; k++) {
        node = this.rbInsertRight(node, pieces[k]);
      }
    }
    this.computeBufferMetadata();
  }
  delete(offset, cnt) {
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (cnt <= 0 || this.root === SENTINEL2) {
      return;
    }
    const startPosition = this.nodeAt(offset);
    const endPosition = this.nodeAt(offset + cnt);
    const startNode = startPosition.node;
    const endNode = endPosition.node;
    if (startNode === endNode) {
      const startSplitPosInBuffer2 = this.positionInBuffer(startNode, startPosition.remainder);
      const endSplitPosInBuffer2 = this.positionInBuffer(startNode, endPosition.remainder);
      if (startPosition.nodeStartOffset === offset) {
        if (cnt === startNode.piece.length) {
          const next = startNode.next();
          rbDelete(this, startNode);
          this.validateCRLFWithPrevNode(next);
          this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(startNode, endSplitPosInBuffer2);
        this._searchCache.validate(offset);
        this.validateCRLFWithPrevNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
        this.deleteNodeTail(startNode, startSplitPosInBuffer2);
        this.validateCRLFWithNextNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(startNode, startSplitPosInBuffer2, endSplitPosInBuffer2);
      this.computeBufferMetadata();
      return;
    }
    const nodesToDel = [];
    const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
    this.deleteNodeTail(startNode, startSplitPosInBuffer);
    this._searchCache.validate(offset);
    if (startNode.piece.length === 0) {
      nodesToDel.push(startNode);
    }
    const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
    this.deleteNodeHead(endNode, endSplitPosInBuffer);
    if (endNode.piece.length === 0) {
      nodesToDel.push(endNode);
    }
    const secondNode = startNode.next();
    for (let node = secondNode; node !== SENTINEL2 && node !== endNode; node = node.next()) {
      nodesToDel.push(node);
    }
    const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
    this.deleteNodes(nodesToDel);
    this.validateCRLFWithNextNode(prev);
    this.computeBufferMetadata();
  }
  insertContentToNodeLeft(value, node) {
    const nodesToDel = [];
    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
      const piece = node.piece;
      const newStart = { line: piece.start.line + 1, column: 0 };
      const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
      node.piece = nPiece;
      value += "\n";
      updateTreeMetadata(this, node, -1, -1);
      if (node.piece.length === 0) {
        nodesToDel.push(node);
      }
    }
    const newPieces = this.createNewPieces(value);
    let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
    for (let k = newPieces.length - 2; k >= 0; k--) {
      newNode = this.rbInsertLeft(newNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
    this.deleteNodes(nodesToDel);
  }
  insertContentToNodeRight(value, node) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const newPieces = this.createNewPieces(value);
    const newNode = this.rbInsertRight(node, newPieces[0]);
    let tmpNode = newNode;
    for (let k = 1; k < newPieces.length; k++) {
      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
  }
  positionInBuffer(node, remainder, ret) {
    const piece = node.piece;
    const bufferIndex = node.piece.bufferIndex;
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    const startOffset = lineStarts[piece.start.line] + piece.start.column;
    const offset = startOffset + remainder;
    let low = piece.start.line;
    let high = piece.end.line;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStart = lineStarts[mid];
      if (mid === high) {
        break;
      }
      midStop = lineStarts[mid + 1];
      if (offset < midStart) {
        high = mid - 1;
      } else if (offset >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    if (ret) {
      ret.line = mid;
      ret.column = offset - midStart;
      return null;
    }
    return {
      line: mid,
      column: offset - midStart
    };
  }
  getLineFeedCnt(bufferIndex, start, end) {
    if (end.column === 0) {
      return end.line - start.line;
    }
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    if (end.line === lineStarts.length - 1) {
      return end.line - start.line;
    }
    const nextLineStartOffset = lineStarts[end.line + 1];
    const endOffset = lineStarts[end.line] + end.column;
    if (nextLineStartOffset > endOffset + 1) {
      return end.line - start.line;
    }
    const previousCharOffset = endOffset - 1;
    const buffer = this._buffers[bufferIndex].buffer;
    if (buffer.charCodeAt(previousCharOffset) === 13) {
      return end.line - start.line + 1;
    } else {
      return end.line - start.line;
    }
  }
  offsetInBuffer(bufferIndex, cursor) {
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    return lineStarts[cursor.line] + cursor.column;
  }
  deleteNodes(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      rbDelete(this, nodes[i]);
    }
  }
  createNewPieces(text) {
    if (text.length > AverageBufferSize) {
      const newPieces = [];
      while (text.length > AverageBufferSize) {
        const lastChar = text.charCodeAt(AverageBufferSize - 1);
        let splitText;
        if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
          splitText = text.substring(0, AverageBufferSize - 1);
          text = text.substring(AverageBufferSize - 1);
        } else {
          splitText = text.substring(0, AverageBufferSize);
          text = text.substring(AverageBufferSize);
        }
        const lineStarts3 = createLineStartsFast(splitText);
        newPieces.push(new Piece(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: lineStarts3.length - 1, column: splitText.length - lineStarts3[lineStarts3.length - 1] },
          lineStarts3.length - 1,
          splitText.length
        ));
        this._buffers.push(new StringBuffer(splitText, lineStarts3));
      }
      const lineStarts2 = createLineStartsFast(text);
      newPieces.push(new Piece(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: lineStarts2.length - 1, column: text.length - lineStarts2[lineStarts2.length - 1] },
        lineStarts2.length - 1,
        text.length
      ));
      this._buffers.push(new StringBuffer(text, lineStarts2));
      return newPieces;
    }
    let startOffset = this._buffers[0].buffer.length;
    const lineStarts = createLineStartsFast(text, false);
    let start = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };
      start = this._lastChangeBufferPos;
      for (let i = 0; i < lineStarts.length; i++) {
        lineStarts[i] += startOffset + 1;
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += "_" + text;
      startOffset += 1;
    } else {
      if (startOffset !== 0) {
        for (let i = 0; i < lineStarts.length; i++) {
          lineStarts[i] += startOffset;
        }
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += text;
    }
    const endOffset = this._buffers[0].buffer.length;
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
    const endPos = { line: endIndex, column: endColumn };
    const newPiece = new Piece(
      0,
      /** todo@peng */
      start,
      endPos,
      this.getLineFeedCnt(0, start, endPos),
      endOffset - startOffset
    );
    this._lastChangeBufferPos = endPos;
    return [newPiece];
  }
  getLineRawContent(lineNumber, endOffset = 0) {
    let x = this.root;
    let ret = "";
    const cache = this._searchCache.get2(lineNumber);
    if (cache) {
      x = cache.node;
      const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
      const buffer = this._buffers[x.piece.bufferIndex].buffer;
      const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
        ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
      } else {
        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
        return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
      }
    } else {
      let nodeStartOffset = 0;
      const originalLineNumber = lineNumber;
      while (x !== SENTINEL2) {
        if (x.left !== SENTINEL2 && x.lf_left >= lineNumber - 1) {
          x = x.left;
        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          nodeStartOffset += x.size_left;
          this._searchCache.set({
            node: x,
            nodeStartOffset,
            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
          });
          return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
          break;
        } else {
          lineNumber -= x.lf_left + x.piece.lineFeedCnt;
          nodeStartOffset += x.size_left + x.piece.length;
          x = x.right;
        }
      }
    }
    x = x.next();
    while (x !== SENTINEL2) {
      const buffer = this._buffers[x.piece.bufferIndex].buffer;
      if (x.piece.lineFeedCnt > 0) {
        const accumulatedValue = this.getAccumulatedValue(x, 0);
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);
        return ret;
      } else {
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer.substr(startOffset, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  computeBufferMetadata() {
    let x = this.root;
    let lfCnt = 1;
    let len = 0;
    while (x !== SENTINEL2) {
      lfCnt += x.lf_left + x.piece.lineFeedCnt;
      len += x.size_left + x.piece.length;
      x = x.right;
    }
    this._lineCnt = lfCnt;
    this._length = len;
    this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(node, accumulatedValue) {
    const piece = node.piece;
    const pos = this.positionInBuffer(node, accumulatedValue);
    const lineCnt = pos.line - piece.start.line;
    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
      const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
      if (realLineCnt !== lineCnt) {
        return { index: realLineCnt, remainder: 0 };
      }
    }
    return { index: lineCnt, remainder: pos.column };
  }
  getAccumulatedValue(node, index) {
    if (index < 0) {
      return 0;
    }
    const piece = node.piece;
    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    const expectedLineStartIndex = piece.start.line + index + 1;
    if (expectedLineStartIndex > piece.end.line) {
      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
    } else {
      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
    }
  }
  deleteNodeTail(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const newEnd = pos;
    const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = newEndOffset - originalEndOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  deleteNodeHead(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const newStart = pos;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
    const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = originalStartOffset - newStartOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  shrinkNode(node, start, end) {
    const piece = node.piece;
    const originalStartPos = piece.start;
    const originalEndPos = piece.end;
    const oldLength = piece.length;
    const oldLFCnt = piece.lineFeedCnt;
    const newEnd = start;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
    const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
    const newNode = this.rbInsertRight(node, newPiece);
    this.validateCRLFWithPrevNode(newNode);
  }
  appendToNode(node, value) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
    const startOffset = this._buffers[0].buffer.length;
    this._buffers[0].buffer += value;
    const lineStarts = createLineStartsFast(value, false);
    for (let i = 0; i < lineStarts.length; i++) {
      lineStarts[i] += startOffset;
    }
    if (hitCRLF) {
      const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop();
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
    const newEnd = { line: endIndex, column: endColumn };
    const newLength = node.piece.length + value.length;
    const oldLineFeedCnt = node.piece.lineFeedCnt;
    const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
    const lf_delta = newLineFeedCnt - oldLineFeedCnt;
    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
    this._lastChangeBufferPos = newEnd;
    updateTreeMetadata(this, node, value.length, lf_delta);
  }
  nodeAt(offset) {
    let x = this.root;
    const cache = this._searchCache.get(offset);
    if (cache) {
      return {
        node: cache.node,
        nodeStartOffset: cache.nodeStartOffset,
        remainder: offset - cache.nodeStartOffset
      };
    }
    let nodeStartOffset = 0;
    while (x !== SENTINEL2) {
      if (x.size_left > offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        nodeStartOffset += x.size_left;
        const ret = {
          node: x,
          remainder: offset - x.size_left,
          nodeStartOffset
        };
        this._searchCache.set(ret);
        return ret;
      } else {
        offset -= x.size_left + x.piece.length;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return null;
  }
  nodeAt2(lineNumber, column) {
    let x = this.root;
    let nodeStartOffset = 0;
    while (x !== SENTINEL2) {
      if (x.left !== SENTINEL2 && x.lf_left >= lineNumber - 1) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
        nodeStartOffset += x.size_left;
        return {
          node: x,
          remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
          nodeStartOffset
        };
      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        if (prevAccumualtedValue + column - 1 <= x.piece.length) {
          return {
            node: x,
            remainder: prevAccumualtedValue + column - 1,
            nodeStartOffset
          };
        } else {
          column -= x.piece.length - prevAccumualtedValue;
          break;
        }
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    x = x.next();
    while (x !== SENTINEL2) {
      if (x.piece.lineFeedCnt > 0) {
        const accumulatedValue = this.getAccumulatedValue(x, 0);
        const nodeStartOffset2 = this.offsetOfNode(x);
        return {
          node: x,
          remainder: Math.min(column - 1, accumulatedValue),
          nodeStartOffset: nodeStartOffset2
        };
      } else {
        if (x.piece.length >= column - 1) {
          const nodeStartOffset2 = this.offsetOfNode(x);
          return {
            node: x,
            remainder: column - 1,
            nodeStartOffset: nodeStartOffset2
          };
        } else {
          column -= x.piece.length;
        }
      }
      x = x.next();
    }
    return null;
  }
  nodeCharCodeAt(node, offset) {
    if (node.piece.lineFeedCnt < 1) {
      return -1;
    }
    const buffer = this._buffers[node.piece.bufferIndex];
    const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
    return buffer.buffer.charCodeAt(newOffset);
  }
  offsetOfNode(node) {
    if (!node) {
      return 0;
    }
    let pos = node.size_left;
    while (node !== this.root) {
      if (node.parent.right === node) {
        pos += node.parent.size_left + node.parent.piece.length;
      }
      node = node.parent;
    }
    return pos;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === "\n");
  }
  startWithLF(val) {
    if (typeof val === "string") {
      return val.charCodeAt(0) === 10;
    }
    if (val === SENTINEL2 || val.piece.lineFeedCnt === 0) {
      return false;
    }
    const piece = val.piece;
    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    const line = piece.start.line;
    const startOffset = lineStarts[line] + piece.start.column;
    if (line === lineStarts.length - 1) {
      return false;
    }
    const nextLineOffset = lineStarts[line + 1];
    if (nextLineOffset > startOffset + 1) {
      return false;
    }
    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
  }
  endWithCR(val) {
    if (typeof val === "string") {
      return val.charCodeAt(val.length - 1) === 13;
    }
    if (val === SENTINEL2 || val.piece.lineFeedCnt === 0) {
      return false;
    }
    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(nextNode) {
    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
      const node = nextNode.prev();
      if (this.endWithCR(node)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  validateCRLFWithNextNode(node) {
    if (this.shouldCheckCRLF() && this.endWithCR(node)) {
      const nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  fixCRLF(prev, next) {
    const nodesToDel = [];
    const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
    let newEnd;
    if (prev.piece.end.column === 0) {
      newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
    } else {
      newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
    }
    const prevNewLength = prev.piece.length - 1;
    const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
    updateTreeMetadata(this, prev, -1, -1);
    if (prev.piece.length === 0) {
      nodesToDel.push(prev);
    }
    const newStart = { line: next.piece.start.line + 1, column: 0 };
    const newLength = next.piece.length - 1;
    const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, next, -1, -1);
    if (next.piece.length === 0) {
      nodesToDel.push(next);
    }
    const pieces = this.createNewPieces("\r\n");
    this.rbInsertRight(prev, pieces[0]);
    for (let i = 0; i < nodesToDel.length; i++) {
      rbDelete(this, nodesToDel[i]);
    }
  }
  adjustCarriageReturnFromNext(value, node) {
    if (this.shouldCheckCRLF() && this.endWithCR(value)) {
      const nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        value += "\n";
        if (nextNode.piece.length === 1) {
          rbDelete(this, nextNode);
        } else {
          const piece = nextNode.piece;
          const newStart = { line: piece.start.line + 1, column: 0 };
          const newLength = piece.length - 1;
          const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
          updateTreeMetadata(this, nextNode, -1, -1);
        }
        return true;
      }
    }
    return false;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(node, callback) {
    if (node === SENTINEL2) {
      return callback(SENTINEL2);
    }
    const leftRet = this.iterate(node.left, callback);
    if (!leftRet) {
      return leftRet;
    }
    return callback(node) && this.iterate(node.right, callback);
  }
  getNodeContent(node) {
    if (node === SENTINEL2) {
      return "";
    }
    const buffer = this._buffers[node.piece.bufferIndex];
    let currentContent;
    const piece = node.piece;
    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    currentContent = buffer.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  getPieceContent(piece) {
    const buffer = this._buffers[piece.bufferIndex];
    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const currentContent = buffer.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(node, p) {
    const z = new TreeNode(
      p,
      1
      /* Red */
    );
    z.left = SENTINEL2;
    z.right = SENTINEL2;
    z.parent = SENTINEL2;
    z.size_left = 0;
    z.lf_left = 0;
    const x = this.root;
    if (x === SENTINEL2) {
      this.root = z;
      z.color = 0;
    } else if (node.right === SENTINEL2) {
      node.right = z;
      z.parent = node;
    } else {
      const nextNode = leftest2(node.right);
      nextNode.left = z;
      z.parent = nextNode;
    }
    fixInsert(this, z);
    return z;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(node, p) {
    const z = new TreeNode(
      p,
      1
      /* Red */
    );
    z.left = SENTINEL2;
    z.right = SENTINEL2;
    z.parent = SENTINEL2;
    z.size_left = 0;
    z.lf_left = 0;
    if (this.root === SENTINEL2) {
      this.root = z;
      z.color = 0;
    } else if (node.left === SENTINEL2) {
      node.left = z;
      z.parent = node;
    } else {
      const prevNode = righttest(node.left);
      prevNode.right = z;
      z.parent = prevNode;
    }
    fixInsert(this, z);
    return z;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js
function countEOL(text) {
  let eolCount = 0;
  let firstLineLength = 0;
  let lastLineStart = 0;
  let eol = 0;
  for (let i = 0, len = text.length; i < len; i++) {
    const chr = text.charCodeAt(i);
    if (chr === 13) {
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      if (i + 1 < len && text.charCodeAt(i + 1) === 10) {
        eol |= 2;
        i++;
      } else {
        eol |= 3;
      }
      lastLineStart = i + 1;
    } else if (chr === 10) {
      eol |= 1;
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      lastLineStart = i + 1;
    }
  }
  if (eolCount === 0) {
    firstLineLength = text.length;
  }
  return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js
var PieceTreeTextBuffer = class _PieceTreeTextBuffer extends Disposable {
  constructor(chunks, BOM, eol, containsRTL2, containsUnusualLineTerminators2, isBasicASCII2, eolNormalized) {
    super();
    this._onDidChangeContent = this._register(new Emitter());
    this._BOM = BOM;
    this._mightContainNonBasicASCII = !isBasicASCII2;
    this._mightContainRTL = containsRTL2;
    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators2;
    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = false;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(preserveBOM) {
    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : "");
  }
  getOffsetAt(lineNumber, column) {
    return this._pieceTree.getOffsetAt(lineNumber, column);
  }
  getPositionAt(offset) {
    return this._pieceTree.getPositionAt(offset);
  }
  getRangeAt(start, length) {
    const end = start + length;
    const startPosition = this.getPositionAt(start);
    const endPosition = this.getPositionAt(end);
    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
  }
  getValueInRange(range2, eol = 0) {
    if (range2.isEmpty()) {
      return "";
    }
    const lineEnding = this._getEndOfLine(eol);
    return this._pieceTree.getValueInRange(range2, lineEnding);
  }
  getValueLengthInRange(range2, eol = 0) {
    if (range2.isEmpty()) {
      return 0;
    }
    if (range2.startLineNumber === range2.endLineNumber) {
      return range2.endColumn - range2.startColumn;
    }
    const startOffset = this.getOffsetAt(range2.startLineNumber, range2.startColumn);
    const endOffset = this.getOffsetAt(range2.endLineNumber, range2.endColumn);
    return endOffset - startOffset;
  }
  getCharacterCountInRange(range2, eol = 0) {
    if (this._mightContainNonBasicASCII) {
      let result = 0;
      const fromLineNumber = range2.startLineNumber;
      const toLineNumber = range2.endLineNumber;
      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
        const lineContent = this.getLineContent(lineNumber);
        const fromOffset = lineNumber === fromLineNumber ? range2.startColumn - 1 : 0;
        const toOffset = lineNumber === toLineNumber ? range2.endColumn - 1 : lineContent.length;
        for (let offset = fromOffset; offset < toOffset; offset++) {
          if (isHighSurrogate(lineContent.charCodeAt(offset))) {
            result = result + 1;
            offset = offset + 1;
          } else {
            result = result + 1;
          }
        }
      }
      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);
      return result;
    }
    return this.getValueLengthInRange(range2, eol);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(lineNumber) {
    return this._pieceTree.getLineContent(lineNumber);
  }
  getLineCharCode(lineNumber, index) {
    return this._pieceTree.getLineCharCode(lineNumber, index);
  }
  getLineLength(lineNumber) {
    return this._pieceTree.getLineLength(lineNumber);
  }
  getLineFirstNonWhitespaceColumn(lineNumber) {
    const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 1;
  }
  getLineLastNonWhitespaceColumn(lineNumber) {
    const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
    if (result === -1) {
      return 0;
    }
    return result + 2;
  }
  _getEndOfLine(eol) {
    switch (eol) {
      case 1:
        return "\n";
      case 2:
        return "\r\n";
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(newEOL) {
    this._pieceTree.setEOL(newEOL);
  }
  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
    let mightContainRTL = this._mightContainRTL;
    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;
    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;
    let canReduceOperations = true;
    let operations = [];
    for (let i = 0; i < rawOperations.length; i++) {
      const op = rawOperations[i];
      if (canReduceOperations && op._isTracked) {
        canReduceOperations = false;
      }
      const validatedRange = op.range;
      if (op.text) {
        let textMightContainNonBasicASCII = true;
        if (!mightContainNonBasicASCII) {
          textMightContainNonBasicASCII = !isBasicASCII(op.text);
          mightContainNonBasicASCII = textMightContainNonBasicASCII;
        }
        if (!mightContainRTL && textMightContainNonBasicASCII) {
          mightContainRTL = containsRTL(op.text);
        }
        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {
          mightContainUnusualLineTerminators = containsUnusualLineTerminators(op.text);
        }
      }
      let validText = "";
      let eolCount = 0;
      let firstLineLength = 0;
      let lastLineLength = 0;
      if (op.text) {
        let strEOL;
        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);
        const bufferEOL = this.getEOL();
        const expectedStrEOL = bufferEOL === "\r\n" ? 2 : 1;
        if (strEOL === 0 || strEOL === expectedStrEOL) {
          validText = op.text;
        } else {
          validText = op.text.replace(/\r\n|\r|\n/g, bufferEOL);
        }
      }
      operations[i] = {
        sortIndex: i,
        identifier: op.identifier || null,
        range: validatedRange,
        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
        rangeLength: this.getValueLengthInRange(validatedRange),
        text: validText,
        eolCount,
        firstLineLength,
        lastLineLength,
        forceMoveMarkers: Boolean(op.forceMoveMarkers),
        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
      };
    }
    operations.sort(_PieceTreeTextBuffer._sortOpsAscending);
    let hasTouchingRanges = false;
    for (let i = 0, count = operations.length - 1; i < count; i++) {
      const rangeEnd = operations[i].range.getEndPosition();
      const nextRangeStart = operations[i + 1].range.getStartPosition();
      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
        if (nextRangeStart.isBefore(rangeEnd)) {
          throw new Error("Overlapping ranges are not allowed!");
        }
        hasTouchingRanges = true;
      }
    }
    if (canReduceOperations) {
      operations = this._reduceOperations(operations);
    }
    const reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? _PieceTreeTextBuffer._getInverseEditRanges(operations) : [];
    const newTrimAutoWhitespaceCandidates = [];
    if (recordTrimAutoWhitespace) {
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        const reverseRange = reverseRanges[i];
        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {
          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
            let currentLineContent = "";
            if (lineNumber === reverseRange.startLineNumber) {
              currentLineContent = this.getLineContent(op.range.startLineNumber);
              if (firstNonWhitespaceIndex(currentLineContent) !== -1) {
                continue;
              }
            }
            newTrimAutoWhitespaceCandidates.push({ lineNumber, oldContent: currentLineContent });
          }
        }
      }
    }
    let reverseOperations = null;
    if (computeUndoEdits) {
      let reverseRangeDeltaOffset = 0;
      reverseOperations = [];
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        const reverseRange = reverseRanges[i];
        const bufferText = this.getValueInRange(op.range);
        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;
        reverseRangeDeltaOffset += op.text.length - bufferText.length;
        reverseOperations[i] = {
          sortIndex: op.sortIndex,
          identifier: op.identifier,
          range: reverseRange,
          text: bufferText,
          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)
        };
      }
      if (!hasTouchingRanges) {
        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);
      }
    }
    this._mightContainRTL = mightContainRTL;
    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;
    this._mightContainNonBasicASCII = mightContainNonBasicASCII;
    const contentChanges = this._doApplyEdits(operations);
    let trimAutoWhitespaceLineNumbers = null;
    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);
      trimAutoWhitespaceLineNumbers = [];
      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
        const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
          continue;
        }
        const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
        const lineContent = this.getLineContent(lineNumber);
        if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {
          continue;
        }
        trimAutoWhitespaceLineNumbers.push(lineNumber);
      }
    }
    this._onDidChangeContent.fire();
    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(operations) {
    if (operations.length < 1e3) {
      return operations;
    }
    return [this._toSingleEditOperation(operations)];
  }
  _toSingleEditOperation(operations) {
    let forceMoveMarkers = false;
    const firstEditRange = operations[0].range;
    const lastEditRange = operations[operations.length - 1].range;
    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
    let lastEndLineNumber = firstEditRange.startLineNumber;
    let lastEndColumn = firstEditRange.startColumn;
    const result = [];
    for (let i = 0, len = operations.length; i < len; i++) {
      const operation = operations[i];
      const range2 = operation.range;
      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range2.startLineNumber, range2.startColumn)));
      if (operation.text.length > 0) {
        result.push(operation.text);
      }
      lastEndLineNumber = range2.endLineNumber;
      lastEndColumn = range2.endColumn;
    }
    const text = result.join("");
    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
    return {
      sortIndex: 0,
      identifier: operations[0].identifier,
      range: entireEditRange,
      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
      rangeLength: this.getValueLengthInRange(
        entireEditRange,
        0
        /* TextDefined */
      ),
      text,
      eolCount,
      firstLineLength,
      lastLineLength,
      forceMoveMarkers,
      isAutoWhitespaceEdit: false
    };
  }
  _doApplyEdits(operations) {
    operations.sort(_PieceTreeTextBuffer._sortOpsDescending);
    const contentChanges = [];
    for (let i = 0; i < operations.length; i++) {
      const op = operations[i];
      const startLineNumber = op.range.startLineNumber;
      const startColumn = op.range.startColumn;
      const endLineNumber = op.range.endLineNumber;
      const endColumn = op.range.endColumn;
      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {
        continue;
      }
      if (op.text) {
        this._pieceTree.delete(op.rangeOffset, op.rangeLength);
        this._pieceTree.insert(op.rangeOffset, op.text, true);
      } else {
        this._pieceTree.delete(op.rangeOffset, op.rangeLength);
      }
      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      contentChanges.push({
        range: contentChangeRange,
        rangeLength: op.rangeLength,
        text: op.text,
        rangeOffset: op.rangeOffset,
        forceMoveMarkers: op.forceMoveMarkers
      });
    }
    return contentChanges;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(operations) {
    const result = [];
    let prevOpEndLineNumber = 0;
    let prevOpEndColumn = 0;
    let prevOp = null;
    for (let i = 0, len = operations.length; i < len; i++) {
      const op = operations[i];
      let startLineNumber;
      let startColumn;
      if (prevOp) {
        if (prevOp.range.endLineNumber === op.range.startLineNumber) {
          startLineNumber = prevOpEndLineNumber;
          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
        } else {
          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
          startColumn = op.range.startColumn;
        }
      } else {
        startLineNumber = op.range.startLineNumber;
        startColumn = op.range.startColumn;
      }
      let resultRange;
      if (op.text.length > 0) {
        const lineCount = op.eolCount + 1;
        if (lineCount === 1) {
          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);
        } else {
          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);
        }
      } else {
        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);
      }
      prevOpEndLineNumber = resultRange.endLineNumber;
      prevOpEndColumn = resultRange.endColumn;
      result.push(resultRange);
      prevOp = op;
    }
    return result;
  }
  static _sortOpsAscending(a, b) {
    const r = Range.compareRangesUsingEnds(a.range, b.range);
    if (r === 0) {
      return a.sortIndex - b.sortIndex;
    }
    return r;
  }
  static _sortOpsDescending(a, b) {
    const r = Range.compareRangesUsingEnds(a.range, b.range);
    if (r === 0) {
      return b.sortIndex - a.sortIndex;
    }
    return -r;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js
var PieceTreeTextBufferFactory = class {
  constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {
    this._chunks = _chunks;
    this._bom = _bom;
    this._cr = _cr;
    this._lf = _lf;
    this._crlf = _crlf;
    this._containsRTL = _containsRTL;
    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;
    this._isBasicASCII = _isBasicASCII;
    this._normalizeEOL = _normalizeEOL;
  }
  _getEOL(defaultEOL) {
    const totalEOLCount = this._cr + this._lf + this._crlf;
    const totalCRCount = this._cr + this._crlf;
    if (totalEOLCount === 0) {
      return defaultEOL === 1 ? "\n" : "\r\n";
    }
    if (totalCRCount > totalEOLCount / 2) {
      return "\r\n";
    }
    return "\n";
  }
  create(defaultEOL) {
    const eol = this._getEOL(defaultEOL);
    const chunks = this._chunks;
    if (this._normalizeEOL && (eol === "\r\n" && (this._cr > 0 || this._lf > 0) || eol === "\n" && (this._cr > 0 || this._crlf > 0))) {
      for (let i = 0, len = chunks.length; i < len; i++) {
        const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
        const newLineStart = createLineStartsFast(str);
        chunks[i] = new StringBuffer(str, newLineStart);
      }
    }
    const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer, disposable: textBuffer };
  }
};
var PieceTreeTextBufferBuilder = class {
  constructor() {
    this.chunks = [];
    this.BOM = "";
    this._hasPreviousChar = false;
    this._previousChar = 0;
    this._tmpLineStarts = [];
    this.cr = 0;
    this.lf = 0;
    this.crlf = 0;
    this.containsRTL = false;
    this.containsUnusualLineTerminators = false;
    this.isBasicASCII = true;
  }
  acceptChunk(chunk) {
    if (chunk.length === 0) {
      return;
    }
    if (this.chunks.length === 0) {
      if (startsWithUTF8BOM(chunk)) {
        this.BOM = UTF8_BOM_CHARACTER;
        chunk = chunk.substr(1);
      }
    }
    const lastChar = chunk.charCodeAt(chunk.length - 1);
    if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
      this._hasPreviousChar = true;
      this._previousChar = lastChar;
    } else {
      this._acceptChunk1(chunk, false);
      this._hasPreviousChar = false;
      this._previousChar = lastChar;
    }
  }
  _acceptChunk1(chunk, allowEmptyStrings) {
    if (!allowEmptyStrings && chunk.length === 0) {
      return;
    }
    if (this._hasPreviousChar) {
      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
    } else {
      this._acceptChunk2(chunk);
    }
  }
  _acceptChunk2(chunk) {
    const lineStarts = createLineStarts(this._tmpLineStarts, chunk);
    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));
    this.cr += lineStarts.cr;
    this.lf += lineStarts.lf;
    this.crlf += lineStarts.crlf;
    if (this.isBasicASCII) {
      this.isBasicASCII = lineStarts.isBasicASCII;
    }
    if (!this.isBasicASCII && !this.containsRTL) {
      this.containsRTL = containsRTL(chunk);
    }
    if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {
      this.containsUnusualLineTerminators = containsUnusualLineTerminators(chunk);
    }
  }
  finish(normalizeEOL = true) {
    this._finish();
    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);
  }
  _finish() {
    if (this.chunks.length === 0) {
      this._acceptChunk1("", true);
    }
    if (this._hasPreviousChar) {
      this._hasPreviousChar = false;
      const lastChunk = this.chunks[this.chunks.length - 1];
      lastChunk.buffer += String.fromCharCode(this._previousChar);
      const newLineStarts = createLineStartsFast(lastChunk.buffer);
      lastChunk.lineStarts = newLineStarts;
      if (this._previousChar === 13) {
        this.cr++;
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js
var ModelRawFlush = class {
  constructor() {
    this.changeType = 1;
  }
};
var LineInjectedText = class _LineInjectedText {
  constructor(ownerId, lineNumber, column, options, order) {
    this.ownerId = ownerId;
    this.lineNumber = lineNumber;
    this.column = column;
    this.options = options;
    this.order = order;
  }
  static applyInjectedText(lineText, injectedTexts) {
    if (!injectedTexts || injectedTexts.length === 0) {
      return lineText;
    }
    let result = "";
    let lastOriginalOffset = 0;
    for (const injectedText of injectedTexts) {
      result += lineText.substring(lastOriginalOffset, injectedText.column - 1);
      lastOriginalOffset = injectedText.column - 1;
      result += injectedText.options.content;
    }
    result += lineText.substring(lastOriginalOffset);
    return result;
  }
  static fromDecorations(decorations) {
    const result = [];
    for (const decoration of decorations) {
      if (decoration.options.before && decoration.options.before.content.length > 0) {
        result.push(new _LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));
      }
      if (decoration.options.after && decoration.options.after.content.length > 0) {
        result.push(new _LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));
      }
    }
    result.sort((a, b) => {
      if (a.lineNumber === b.lineNumber) {
        if (a.column === b.column) {
          return a.order - b.order;
        }
        return a.column - b.column;
      }
      return a.lineNumber - b.lineNumber;
    });
    return result;
  }
};
var ModelRawLineChanged = class {
  constructor(lineNumber, detail, injectedText) {
    this.changeType = 2;
    this.lineNumber = lineNumber;
    this.detail = detail;
    this.injectedText = injectedText;
  }
};
var ModelRawLinesDeleted = class {
  constructor(fromLineNumber, toLineNumber) {
    this.changeType = 3;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
  }
};
var ModelRawLinesInserted = class {
  constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {
    this.changeType = 4;
    this.injectedTexts = injectedTexts;
    this.fromLineNumber = fromLineNumber;
    this.toLineNumber = toLineNumber;
    this.detail = detail;
  }
};
var ModelRawEOLChanged = class {
  constructor() {
    this.changeType = 5;
  }
};
var ModelRawContentChangedEvent = class _ModelRawContentChangedEvent {
  constructor(changes, versionId, isUndoing, isRedoing) {
    this.changes = changes;
    this.versionId = versionId;
    this.isUndoing = isUndoing;
    this.isRedoing = isRedoing;
    this.resultingSelection = null;
  }
  containsEvent(type) {
    for (let i = 0, len = this.changes.length; i < len; i++) {
      const change = this.changes[i];
      if (change.changeType === type) {
        return true;
      }
    }
    return false;
  }
  static merge(a, b) {
    const changes = [].concat(a.changes).concat(b.changes);
    const versionId = b.versionId;
    const isUndoing = a.isUndoing || b.isUndoing;
    const isRedoing = a.isRedoing || b.isRedoing;
    return new _ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);
  }
};
var ModelInjectedTextChangedEvent = class {
  constructor(changes) {
    this.changes = changes;
  }
};
var InternalModelContentChangeEvent = class _InternalModelContentChangeEvent {
  constructor(rawContentChangedEvent, contentChangedEvent) {
    this.rawContentChangedEvent = rawContentChangedEvent;
    this.contentChangedEvent = contentChangedEvent;
  }
  merge(other) {
    const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
    const contentChangedEvent = _InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
    return new _InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);
  }
  static _mergeChangeEvents(a, b) {
    const changes = [].concat(a.changes).concat(b.changes);
    const eol = b.eol;
    const versionId = b.versionId;
    const isUndoing = a.isUndoing || b.isUndoing;
    const isRedoing = a.isRedoing || b.isRedoing;
    const isFlush = a.isFlush || b.isFlush;
    return {
      changes,
      eol,
      versionId,
      isUndoing,
      isRedoing,
      isFlush
    };
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js
var ContiguousMultilineTokens = class {
  constructor(startLineNumber, tokens) {
    this._startLineNumber = startLineNumber;
    this._tokens = tokens;
  }
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._startLineNumber + this._tokens.length - 1;
  }
  /**
   * @see {@link _tokens}
   */
  getLineTokens(lineNumber) {
    return this._tokens[lineNumber - this._startLineNumber];
  }
  appendLineTokens(lineTokens) {
    this._tokens.push(lineTokens);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js
var ContiguousMultilineTokensBuilder = class {
  constructor() {
    this._tokens = [];
  }
  add(lineNumber, lineTokens) {
    if (this._tokens.length > 0) {
      const last = this._tokens[this._tokens.length - 1];
      if (last.endLineNumber + 1 === lineNumber) {
        last.appendLineTokens(lineTokens);
        return;
      }
    }
    this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));
  }
  finalize() {
    return this._tokens;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js
var ContiguousGrowingArray = class {
  constructor(_default) {
    this._default = _default;
    this._store = [];
  }
  get(index) {
    if (index < this._store.length) {
      return this._store[index];
    }
    return this._default;
  }
  set(index, value) {
    while (index >= this._store.length) {
      this._store[this._store.length] = this._default;
    }
    this._store[index] = value;
  }
  delete(deleteIndex, deleteCount) {
    if (deleteCount === 0 || deleteIndex >= this._store.length) {
      return;
    }
    this._store.splice(deleteIndex, deleteCount);
  }
  insert(insertIndex, insertCount) {
    if (insertCount === 0 || insertIndex >= this._store.length) {
      return;
    }
    const arr = [];
    for (let i = 0; i < insertCount; i++) {
      arr[i] = this._default;
    }
    this._store = arrayInsert(this._store, insertIndex, arr);
  }
};
var TokenizationStateStore = class {
  constructor(tokenizationSupport, initialState) {
    this.tokenizationSupport = tokenizationSupport;
    this.initialState = initialState;
    this._lineBeginState = new ContiguousGrowingArray(null);
    this._lineNeedsTokenization = new ContiguousGrowingArray(true);
    this._firstLineNeedsTokenization = 0;
    this._lineBeginState.set(0, this.initialState);
  }
  get invalidLineStartIndex() {
    return this._firstLineNeedsTokenization;
  }
  markMustBeTokenized(lineIndex) {
    this._lineNeedsTokenization.set(lineIndex, true);
    this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, lineIndex);
  }
  getBeginState(lineIndex) {
    return this._lineBeginState.get(lineIndex);
  }
  setEndState(linesLength, lineIndex, endState) {
    this._lineNeedsTokenization.set(lineIndex, false);
    this._firstLineNeedsTokenization = lineIndex + 1;
    if (lineIndex === linesLength - 1) {
      return;
    }
    const previousEndState = this._lineBeginState.get(lineIndex + 1);
    if (previousEndState === null || !endState.equals(previousEndState)) {
      this._lineBeginState.set(lineIndex + 1, endState);
      this.markMustBeTokenized(lineIndex + 1);
      return;
    }
    let i = lineIndex + 1;
    while (i < linesLength) {
      if (this._lineNeedsTokenization.get(i)) {
        break;
      }
      i++;
    }
    this._firstLineNeedsTokenization = i;
  }
  //#region Editing
  applyEdits(range2, eolCount) {
    this.markMustBeTokenized(range2.startLineNumber - 1);
    this._lineBeginState.delete(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    this._lineNeedsTokenization.delete(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    this._lineBeginState.insert(range2.startLineNumber, eolCount);
    this._lineNeedsTokenization.insert(range2.startLineNumber, eolCount);
  }
};
var TextModelTokenization = class extends Disposable {
  constructor(_textModel, _languageIdCodec) {
    super();
    this._textModel = _textModel;
    this._languageIdCodec = _languageIdCodec;
    this._isScheduled = false;
    this._isDisposed = false;
    this._tokenizationStateStore = null;
    this._register(TokenizationRegistry2.onDidChange((e) => {
      const languageId = this._textModel.getLanguageId();
      if (e.changedLanguages.indexOf(languageId) === -1) {
        return;
      }
      this._resetTokenizationState();
      this._textModel.clearTokens();
    }));
    this._resetTokenizationState();
  }
  dispose() {
    this._isDisposed = true;
    super.dispose();
  }
  //#region TextModel events
  handleDidChangeContent(e) {
    if (e.isFlush) {
      this._resetTokenizationState();
      return;
    }
    if (this._tokenizationStateStore) {
      for (let i = 0, len = e.changes.length; i < len; i++) {
        const change = e.changes[i];
        const [eolCount] = countEOL(change.text);
        this._tokenizationStateStore.applyEdits(change.range, eolCount);
      }
    }
    this._beginBackgroundTokenization();
  }
  handleDidChangeAttached() {
    this._beginBackgroundTokenization();
  }
  handleDidChangeLanguage(e) {
    this._resetTokenizationState();
    this._textModel.clearTokens();
  }
  //#endregion
  _resetTokenizationState() {
    const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);
    if (tokenizationSupport && initialState) {
      this._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, initialState);
    } else {
      this._tokenizationStateStore = null;
    }
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    if (this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
      return;
    }
    this._isScheduled = true;
    runWhenIdle((deadline) => {
      this._isScheduled = false;
      this._backgroundTokenizeWithDeadline(deadline);
    });
  }
  /**
   * Tokenize until the deadline occurs, but try to yield every 1-2ms.
   */
  _backgroundTokenizeWithDeadline(deadline) {
    const endTime = Date.now() + deadline.timeRemaining();
    const execute = () => {
      if (this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
        return;
      }
      this._backgroundTokenizeForAtLeast1ms();
      if (Date.now() < endTime) {
        setTimeout0(execute);
      } else {
        this._beginBackgroundTokenization();
      }
    };
    execute();
  }
  /**
   * Tokenize for at least 1ms.
   */
  _backgroundTokenizeForAtLeast1ms() {
    const lineCount = this._textModel.getLineCount();
    const builder = new ContiguousMultilineTokensBuilder();
    const sw = StopWatch.create(false);
    do {
      if (sw.elapsed() > 1) {
        break;
      }
      const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);
      if (tokenizedLineNumber >= lineCount) {
        break;
      }
    } while (this._hasLinesToTokenize());
    this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());
  }
  tokenizeViewport(startLineNumber, endLineNumber) {
    const builder = new ContiguousMultilineTokensBuilder();
    this._tokenizeViewport(builder, startLineNumber, endLineNumber);
    this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());
  }
  reset() {
    this._resetTokenizationState();
    this._textModel.clearTokens();
  }
  forceTokenization(lineNumber) {
    const builder = new ContiguousMultilineTokensBuilder();
    this._updateTokensUntilLine(builder, lineNumber);
    this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());
  }
  getTokenTypeIfInsertingCharacter(position, character) {
    if (!this._tokenizationStateStore) {
      return 0;
    }
    this.forceTokenization(position.lineNumber);
    const lineStartState = this._tokenizationStateStore.getBeginState(position.lineNumber - 1);
    if (!lineStartState) {
      return 0;
    }
    const languageId = this._textModel.getLanguageId();
    const lineContent = this._textModel.getLineContent(position.lineNumber);
    const text = lineContent.substring(0, position.column - 1) + character + lineContent.substring(position.column - 1);
    const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);
    const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);
    if (lineTokens.getCount() === 0) {
      return 0;
    }
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    return lineTokens.getStandardTokenType(tokenIndex);
  }
  tokenizeLineWithEdit(position, length, newText) {
    const lineNumber = position.lineNumber;
    const column = position.column;
    if (!this._tokenizationStateStore) {
      return null;
    }
    this.forceTokenization(lineNumber);
    const lineStartState = this._tokenizationStateStore.getBeginState(lineNumber - 1);
    if (!lineStartState) {
      return null;
    }
    const curLineContent = this._textModel.getLineContent(lineNumber);
    const newLineContent = curLineContent.substring(0, column - 1) + newText + curLineContent.substring(column - 1 + length);
    const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);
    const result = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, newLineContent, true, lineStartState);
    const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);
    return lineTokens;
  }
  isCheapToTokenize(lineNumber) {
    if (!this._tokenizationStateStore) {
      return true;
    }
    const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;
    if (lineNumber > firstInvalidLineNumber) {
      return false;
    }
    if (lineNumber < firstInvalidLineNumber) {
      return true;
    }
    if (this._textModel.getLineLength(lineNumber) < 2048) {
      return true;
    }
    return false;
  }
  _hasLinesToTokenize() {
    if (!this._tokenizationStateStore) {
      return false;
    }
    return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();
  }
  _tokenizeOneInvalidLine(builder) {
    if (!this._tokenizationStateStore || !this._hasLinesToTokenize()) {
      return this._textModel.getLineCount() + 1;
    }
    const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;
    this._updateTokensUntilLine(builder, lineNumber);
    return lineNumber;
  }
  _updateTokensUntilLine(builder, lineNumber) {
    if (!this._tokenizationStateStore) {
      return;
    }
    const languageId = this._textModel.getLanguageId();
    const linesLength = this._textModel.getLineCount();
    const endLineIndex = lineNumber - 1;
    for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
      const text = this._textModel.getLineContent(lineIndex + 1);
      const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);
      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);
      builder.add(lineIndex + 1, r.tokens);
      this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);
      lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1;
    }
  }
  _tokenizeViewport(builder, startLineNumber, endLineNumber) {
    if (!this._tokenizationStateStore) {
      return;
    }
    if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {
      return;
    }
    if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {
      this._updateTokensUntilLine(builder, endLineNumber);
      return;
    }
    let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const fakeLines = [];
    let initialState = null;
    for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {
      const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);
      if (newNonWhitespaceIndex === 0) {
        continue;
      }
      if (newNonWhitespaceIndex < nonWhitespaceColumn) {
        initialState = this._tokenizationStateStore.getBeginState(i - 1);
        if (initialState) {
          break;
        }
        fakeLines.push(this._textModel.getLineContent(i));
        nonWhitespaceColumn = newNonWhitespaceIndex;
      }
    }
    if (!initialState) {
      initialState = this._tokenizationStateStore.initialState;
    }
    const languageId = this._textModel.getLanguageId();
    let state = initialState;
    for (let i = fakeLines.length - 1; i >= 0; i--) {
      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, fakeLines[i], false, state);
      state = r.endState;
    }
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const text = this._textModel.getLineContent(lineNumber);
      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, state);
      builder.add(lineNumber, r.tokens);
      this._tokenizationStateStore.markMustBeTokenized(lineNumber - 1);
      state = r.endState;
    }
  }
};
function initializeTokenization(textModel) {
  if (textModel.isTooLargeForTokenization()) {
    return [null, null];
  }
  const tokenizationSupport = TokenizationRegistry2.get(textModel.getLanguageId());
  if (!tokenizationSupport) {
    return [null, null];
  }
  let initialState;
  try {
    initialState = tokenizationSupport.getInitialState();
  } catch (e) {
    onUnexpectedError(e);
    return [null, null];
  }
  return [tokenizationSupport, initialState];
}
function safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {
  let r = null;
  if (tokenizationSupport) {
    try {
      r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  if (!r) {
    r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);
  }
  LineTokens.convertToEndOffset(r.tokens, text.length);
  return r;
}

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js
var EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;
var ContiguousTokensEditing = class _ContiguousTokensEditing {
  static deleteBeginning(lineTokens, toChIndex) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    return _ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);
  }
  static deleteEnding(lineTokens, fromChIndex) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    const tokens = toUint32Array(lineTokens);
    const lineTextLength = tokens[tokens.length - 2];
    return _ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);
  }
  static delete(lineTokens, fromChIndex, toChIndex) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
      return lineTokens;
    }
    const tokens = toUint32Array(lineTokens);
    const tokensCount = tokens.length >>> 1;
    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
      return EMPTY_LINE_TOKENS;
    }
    const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);
    const fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;
    const fromTokenEndOffset = tokens[fromTokenIndex << 1];
    if (toChIndex < fromTokenEndOffset) {
      const delta2 = toChIndex - fromChIndex;
      for (let i = fromTokenIndex; i < tokensCount; i++) {
        tokens[i << 1] -= delta2;
      }
      return lineTokens;
    }
    let dest;
    let lastEnd;
    if (fromTokenStartOffset !== fromChIndex) {
      tokens[fromTokenIndex << 1] = fromChIndex;
      dest = fromTokenIndex + 1 << 1;
      lastEnd = fromChIndex;
    } else {
      dest = fromTokenIndex << 1;
      lastEnd = fromTokenStartOffset;
    }
    const delta = toChIndex - fromChIndex;
    for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
      const tokenEndOffset = tokens[tokenIndex << 1] - delta;
      if (tokenEndOffset > lastEnd) {
        tokens[dest++] = tokenEndOffset;
        tokens[dest++] = tokens[(tokenIndex << 1) + 1];
        lastEnd = tokenEndOffset;
      }
    }
    if (dest === tokens.length) {
      return lineTokens;
    }
    const tmp = new Uint32Array(dest);
    tmp.set(tokens.subarray(0, dest), 0);
    return tmp.buffer;
  }
  static append(lineTokens, _otherTokens) {
    if (_otherTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    if (lineTokens === EMPTY_LINE_TOKENS) {
      return _otherTokens;
    }
    if (lineTokens === null) {
      return lineTokens;
    }
    if (_otherTokens === null) {
      return null;
    }
    const myTokens = toUint32Array(lineTokens);
    const otherTokens = toUint32Array(_otherTokens);
    const otherTokensCount = otherTokens.length >>> 1;
    const result = new Uint32Array(myTokens.length + otherTokens.length);
    result.set(myTokens, 0);
    let dest = myTokens.length;
    const delta = myTokens[myTokens.length - 2];
    for (let i = 0; i < otherTokensCount; i++) {
      result[dest++] = otherTokens[i << 1] + delta;
      result[dest++] = otherTokens[(i << 1) + 1];
    }
    return result.buffer;
  }
  static insert(lineTokens, chIndex, textLength) {
    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
      return lineTokens;
    }
    const tokens = toUint32Array(lineTokens);
    const tokensCount = tokens.length >>> 1;
    let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);
    if (fromTokenIndex > 0) {
      const fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];
      if (fromTokenStartOffset === chIndex) {
        fromTokenIndex--;
      }
    }
    for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
      tokens[tokenIndex << 1] += textLength;
    }
    return lineTokens;
  }
};
function toUint32Array(arr) {
  if (arr instanceof Uint32Array) {
    return arr;
  } else {
    return new Uint32Array(arr);
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js
var ContiguousTokensStore = class _ContiguousTokensStore {
  constructor(languageIdCodec) {
    this._lineTokens = [];
    this._len = 0;
    this._languageIdCodec = languageIdCodec;
  }
  flush() {
    this._lineTokens = [];
    this._len = 0;
  }
  getTokens(topLevelLanguageId, lineIndex, lineText) {
    let rawLineTokens = null;
    if (lineIndex < this._len) {
      rawLineTokens = this._lineTokens[lineIndex];
    }
    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {
      return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);
    }
    const lineTokens = new Uint32Array(2);
    lineTokens[0] = lineText.length;
    lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));
    return new LineTokens(lineTokens, lineText, this._languageIdCodec);
  }
  static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {
    const tokens = _tokens ? toUint32Array(_tokens) : null;
    if (lineTextLength === 0) {
      let hasDifferentLanguageId = false;
      if (tokens && tokens.length > 1) {
        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;
      }
      if (!hasDifferentLanguageId) {
        return EMPTY_LINE_TOKENS;
      }
    }
    if (!tokens || tokens.length === 0) {
      const tokens2 = new Uint32Array(2);
      tokens2[0] = lineTextLength;
      tokens2[1] = getDefaultMetadata(topLevelLanguageId);
      return tokens2.buffer;
    }
    tokens[tokens.length - 2] = lineTextLength;
    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {
      return tokens.buffer;
    }
    return tokens;
  }
  _ensureLine(lineIndex) {
    while (lineIndex >= this._len) {
      this._lineTokens[this._len] = null;
      this._len++;
    }
  }
  _deleteLines(start, deleteCount) {
    if (deleteCount === 0) {
      return;
    }
    if (start + deleteCount > this._len) {
      deleteCount = this._len - start;
    }
    this._lineTokens.splice(start, deleteCount);
    this._len -= deleteCount;
  }
  _insertLines(insertIndex, insertCount) {
    if (insertCount === 0) {
      return;
    }
    const lineTokens = [];
    for (let i = 0; i < insertCount; i++) {
      lineTokens[i] = null;
    }
    this._lineTokens = arrayInsert(this._lineTokens, insertIndex, lineTokens);
    this._len += insertCount;
  }
  setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {
    const tokens = _ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);
    this._ensureLine(lineIndex);
    const oldTokens = this._lineTokens[lineIndex];
    this._lineTokens[lineIndex] = tokens;
    if (checkEquality) {
      return !_ContiguousTokensStore._equals(oldTokens, tokens);
    }
    return false;
  }
  static _equals(_a3, _b) {
    if (!_a3 || !_b) {
      return !_a3 && !_b;
    }
    const a = toUint32Array(_a3);
    const b = toUint32Array(_b);
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  //#region Editing
  acceptEdit(range2, eolCount, firstLineLength) {
    this._acceptDeleteRange(range2);
    this._acceptInsertText(new Position(range2.startLineNumber, range2.startColumn), eolCount, firstLineLength);
  }
  _acceptDeleteRange(range2) {
    const firstLineIndex = range2.startLineNumber - 1;
    if (firstLineIndex >= this._len) {
      return;
    }
    if (range2.startLineNumber === range2.endLineNumber) {
      if (range2.startColumn === range2.endColumn) {
        return;
      }
      this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range2.startColumn - 1, range2.endColumn - 1);
      return;
    }
    this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range2.startColumn - 1);
    const lastLineIndex = range2.endLineNumber - 1;
    let lastLineTokens = null;
    if (lastLineIndex < this._len) {
      lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range2.endColumn - 1);
    }
    this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);
    this._deleteLines(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
  }
  _acceptInsertText(position, eolCount, firstLineLength) {
    if (eolCount === 0 && firstLineLength === 0) {
      return;
    }
    const lineIndex = position.lineNumber - 1;
    if (lineIndex >= this._len) {
      return;
    }
    if (eolCount === 0) {
      this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
      return;
    }
    this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);
    this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
    this._insertLines(position.lineNumber, eolCount);
  }
};
function getDefaultMetadata(topLevelLanguageId) {
  return (topLevelLanguageId << 0 | 0 << 8 | 0 << 10 | 1 << 14 | 2 << 23) >>> 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js
var SparseTokensStore = class _SparseTokensStore {
  constructor(languageIdCodec) {
    this._pieces = [];
    this._isComplete = false;
    this._languageIdCodec = languageIdCodec;
  }
  flush() {
    this._pieces = [];
    this._isComplete = false;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(pieces, isComplete) {
    this._pieces = pieces || [];
    this._isComplete = isComplete;
  }
  setPartial(_range, pieces) {
    let range2 = _range;
    if (pieces.length > 0) {
      const _firstRange = pieces[0].getRange();
      const _lastRange = pieces[pieces.length - 1].getRange();
      if (!_firstRange || !_lastRange) {
        return _range;
      }
      range2 = _range.plusRange(_firstRange).plusRange(_lastRange);
    }
    let insertPosition = null;
    for (let i = 0, len = this._pieces.length; i < len; i++) {
      const piece = this._pieces[i];
      if (piece.endLineNumber < range2.startLineNumber) {
        continue;
      }
      if (piece.startLineNumber > range2.endLineNumber) {
        insertPosition = insertPosition || { index: i };
        break;
      }
      piece.removeTokens(range2);
      if (piece.isEmpty()) {
        this._pieces.splice(i, 1);
        i--;
        len--;
        continue;
      }
      if (piece.endLineNumber < range2.startLineNumber) {
        continue;
      }
      if (piece.startLineNumber > range2.endLineNumber) {
        insertPosition = insertPosition || { index: i };
        continue;
      }
      const [a, b] = piece.split(range2);
      if (a.isEmpty()) {
        insertPosition = insertPosition || { index: i };
        continue;
      }
      if (b.isEmpty()) {
        continue;
      }
      this._pieces.splice(i, 1, a, b);
      i++;
      len++;
      insertPosition = insertPosition || { index: i };
    }
    insertPosition = insertPosition || { index: this._pieces.length };
    if (pieces.length > 0) {
      this._pieces = arrayInsert(this._pieces, insertPosition.index, pieces);
    }
    return range2;
  }
  isComplete() {
    return this._isComplete;
  }
  addSparseTokens(lineNumber, aTokens) {
    const pieces = this._pieces;
    if (pieces.length === 0) {
      return aTokens;
    }
    const pieceIndex = _SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);
    const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);
    if (!bTokens) {
      return aTokens;
    }
    const aLen = aTokens.getCount();
    const bLen = bTokens.getCount();
    let aIndex = 0;
    const result = [];
    let resultLen = 0;
    let lastEndOffset = 0;
    const emitToken = (endOffset, metadata) => {
      if (endOffset === lastEndOffset) {
        return;
      }
      lastEndOffset = endOffset;
      result[resultLen++] = endOffset;
      result[resultLen++] = metadata;
    };
    for (let bIndex = 0; bIndex < bLen; bIndex++) {
      const bStartCharacter = bTokens.getStartCharacter(bIndex);
      const bEndCharacter = bTokens.getEndCharacter(bIndex);
      const bMetadata = bTokens.getMetadata(bIndex);
      const bMask = ((bMetadata & 1 ? 1024 : 0) | (bMetadata & 2 ? 2048 : 0) | (bMetadata & 4 ? 4096 : 0) | (bMetadata & 8 ? 8192 : 0) | (bMetadata & 16 ? 8372224 : 0) | (bMetadata & 32 ? 4286578688 : 0)) >>> 0;
      const aMask = ~bMask >>> 0;
      while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {
        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
        aIndex++;
      }
      if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {
        emitToken(bStartCharacter, aTokens.getMetadata(aIndex));
      }
      while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {
        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);
        aIndex++;
      }
      if (aIndex < aLen) {
        emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);
        if (aTokens.getEndOffset(aIndex) === bEndCharacter) {
          aIndex++;
        }
      } else {
        const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);
        emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);
      }
    }
    while (aIndex < aLen) {
      emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
      aIndex++;
    }
    return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);
  }
  static _findFirstPieceWithLine(pieces, lineNumber) {
    let low = 0;
    let high = pieces.length - 1;
    while (low < high) {
      let mid = low + Math.floor((high - low) / 2);
      if (pieces[mid].endLineNumber < lineNumber) {
        low = mid + 1;
      } else if (pieces[mid].startLineNumber > lineNumber) {
        high = mid - 1;
      } else {
        while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {
          mid--;
        }
        return mid;
      }
    }
    return low;
  }
  acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    for (const piece of this._pieces) {
      piece.acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode);
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js
var IUndoRedoService = createDecorator("undoRedoService");
var ResourceEditStackSnapshot = class {
  constructor(resource, elements) {
    this.resource = resource;
    this.elements = elements;
  }
};
var UndoRedoGroup = class _UndoRedoGroup {
  constructor() {
    this.id = _UndoRedoGroup._ID++;
    this.order = 1;
  }
  nextOrder() {
    if (this.id === 0) {
      return 0;
    }
    return this.order++;
  }
};
UndoRedoGroup._ID = 0;
UndoRedoGroup.None = new UndoRedoGroup();
var UndoRedoSource = class _UndoRedoSource {
  constructor() {
    this.id = _UndoRedoSource._ID++;
    this.order = 1;
  }
  nextOrder() {
    if (this.id === 0) {
      return 0;
    }
    return this.order++;
  }
};
UndoRedoSource._ID = 0;
UndoRedoSource.None = new UndoRedoSource();

// node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js
function _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += indentSize;
    } else {
      spacesCnt++;
    }
  }
  let result = "";
  if (!insertSpaces) {
    const tabsCnt = Math.floor(spacesCnt / indentSize);
    spacesCnt = spacesCnt % indentSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}
function normalizeIndentation(str, indentSize, insertSpaces) {
  let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(str);
  if (firstNonWhitespaceIndex2 === -1) {
    firstNonWhitespaceIndex2 = str.length;
  }
  return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex2), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex2);
}

// node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function createTextBufferBuilder() {
  return new PieceTreeTextBufferBuilder();
}
function createTextBufferFactory(text) {
  const builder = createTextBufferBuilder();
  builder.acceptChunk(text);
  return builder.finish();
}
function createTextBuffer(value, defaultEOL) {
  const factory = typeof value === "string" ? createTextBufferFactory(value) : value;
  return factory.create(defaultEOL);
}
var MODEL_ID = 0;
var LIMIT_FIND_COUNT2 = 999;
var LONG_LINE_BOUNDARY = 1e4;
var TextModelSnapshot = class {
  constructor(source) {
    this._source = source;
    this._eos = false;
  }
  read() {
    if (this._eos) {
      return null;
    }
    const result = [];
    let resultCnt = 0;
    let resultLength = 0;
    do {
      const tmp = this._source.read();
      if (tmp === null) {
        this._eos = true;
        if (resultCnt === 0) {
          return null;
        } else {
          return result.join("");
        }
      }
      if (tmp.length > 0) {
        result[resultCnt++] = tmp;
        resultLength += tmp.length;
      }
      if (resultLength >= 64 * 1024) {
        return result.join("");
      }
    } while (true);
  }
};
var invalidFunc = () => {
  throw new Error(`Invalid change accessor`);
};
var TextModel = class TextModel2 extends Disposable {
  constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {
    super();
    this._undoRedoService = _undoRedoService;
    this._languageService = _languageService;
    this._languageConfigurationService = _languageConfigurationService;
    this._onWillDispose = this._register(new Emitter());
    this.onWillDispose = this._onWillDispose.event;
    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter((affectedInjectedTextLines) => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));
    this.onDidChangeDecorations = this._onDidChangeDecorations.event;
    this._onDidChangeLanguage = this._register(new Emitter());
    this.onDidChangeLanguage = this._onDidChangeLanguage.event;
    this._onDidChangeLanguageConfiguration = this._register(new Emitter());
    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;
    this._onDidChangeTokens = this._register(new Emitter());
    this.onDidChangeTokens = this._onDidChangeTokens.event;
    this._onDidChangeOptions = this._register(new Emitter());
    this.onDidChangeOptions = this._onDidChangeOptions.event;
    this._onDidChangeAttached = this._register(new Emitter());
    this.onDidChangeAttached = this._onDidChangeAttached.event;
    this._onDidChangeInjectedText = this._register(new Emitter());
    this._eventEmitter = this._register(new DidChangeContentEmitter());
    this._backgroundTokenizationState = 0;
    this._onBackgroundTokenizationStateChanged = this._register(new Emitter());
    MODEL_ID++;
    this.id = "$model" + MODEL_ID;
    this.isForSimpleWidget = creationOptions.isForSimpleWidget;
    if (typeof associatedResource === "undefined" || associatedResource === null) {
      this._associatedResource = URI.parse("inmemory://model/" + MODEL_ID);
    } else {
      this._associatedResource = associatedResource;
    }
    this._attachedEditorCount = 0;
    const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);
    this._buffer = textBuffer;
    this._bufferDisposable = disposable;
    this._options = TextModel2.resolveOptions(this._buffer, creationOptions);
    const bufferLineCount = this._buffer.getLineCount();
    const bufferTextLength = this._buffer.getValueLengthInRange(
      new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1),
      0
      /* TextDefined */
    );
    if (creationOptions.largeFileOptimizations) {
      this._isTooLargeForTokenization = bufferTextLength > TextModel2.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel2.LARGE_FILE_LINE_COUNT_THRESHOLD;
    } else {
      this._isTooLargeForTokenization = false;
    }
    this._isTooLargeForSyncing = bufferTextLength > TextModel2.MODEL_SYNC_LIMIT;
    this._versionId = 1;
    this._alternativeVersionId = 1;
    this._initialUndoRedoSnapshot = null;
    this._isDisposed = false;
    this._isDisposing = false;
    this._languageId = languageId;
    this._languageRegistryListener = this._languageConfigurationService.onDidChange((e) => {
      if (e.affects(this._languageId)) {
        this._onDidChangeLanguageConfiguration.fire({});
      }
    });
    this._instanceId = singleLetterHash(MODEL_ID);
    this._lastDecorationId = 0;
    this._decorations = /* @__PURE__ */ Object.create(null);
    this._decorationsTree = new DecorationsTrees();
    this._commandManager = new EditStack(this, this._undoRedoService);
    this._isUndoing = false;
    this._isRedoing = false;
    this._trimAutoWhitespaceLines = null;
    this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);
    this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);
    this._tokenization = new TextModelTokenization(this, this._languageService.languageIdCodec);
    this._bracketPairColorizer = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));
    this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));
    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));
    this._register(this._decorationProvider.onDidChange(() => {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._onDidChangeDecorations.fire();
      this._onDidChangeDecorations.endDeferredEmit();
    }));
  }
  static resolveOptions(textBuffer, options) {
    if (options.detectIndentation) {
      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);
      return new TextModelResolvedOptions({
        tabSize: guessedIndentation.tabSize,
        indentSize: guessedIndentation.tabSize,
        insertSpaces: guessedIndentation.insertSpaces,
        trimAutoWhitespace: options.trimAutoWhitespace,
        defaultEOL: options.defaultEOL,
        bracketPairColorizationOptions: options.bracketPairColorizationOptions
      });
    }
    return new TextModelResolvedOptions({
      tabSize: options.tabSize,
      indentSize: options.indentSize,
      insertSpaces: options.insertSpaces,
      trimAutoWhitespace: options.trimAutoWhitespace,
      defaultEOL: options.defaultEOL,
      bracketPairColorizationOptions: options.bracketPairColorizationOptions
    });
  }
  onDidChangeContent(listener) {
    return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));
  }
  onDidChangeContentOrInjectedText(listener) {
    return combinedDisposable(this._eventEmitter.fastEvent((e) => listener(e.rawContentChangedEvent)), this._onDidChangeInjectedText.event((e) => listener(e)));
  }
  get bracketPairs() {
    return this._bracketPairColorizer;
  }
  get guides() {
    return this._guidesTextModelPart;
  }
  get backgroundTokenizationState() {
    return this._backgroundTokenizationState;
  }
  handleTokenizationProgress(completed) {
    if (this._backgroundTokenizationState === 2) {
      return;
    }
    const newState = completed ? 2 : 1;
    if (this._backgroundTokenizationState !== newState) {
      this._backgroundTokenizationState = newState;
      this._bracketPairColorizer.handleDidChangeBackgroundTokenizationState();
      this._onBackgroundTokenizationStateChanged.fire();
    }
  }
  dispose() {
    this._isDisposing = true;
    this._onWillDispose.fire();
    this._languageRegistryListener.dispose();
    this._tokenization.dispose();
    this._isDisposed = true;
    super.dispose();
    this._bufferDisposable.dispose();
    this._isDisposing = false;
    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], "", "\n", false, false, true, true);
    emptyDisposedTextBuffer.dispose();
    this._buffer = emptyDisposedTextBuffer;
    this._bufferDisposable = Disposable.None;
  }
  _assertNotDisposed() {
    if (this._isDisposed) {
      throw new Error("Model is disposed!");
    }
  }
  _emitContentChangedEvent(rawChange, change) {
    if (this._isDisposing) {
      return;
    }
    this._bracketPairColorizer.handleDidChangeContent(change);
    this._tokenization.handleDidChangeContent(change);
    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));
  }
  setValue(value) {
    this._assertNotDisposed();
    if (value === null) {
      return;
    }
    const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);
    this._setValueFromTextBuffer(textBuffer, disposable);
  }
  _createContentChanged2(range2, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {
    return {
      changes: [{
        range: range2,
        rangeOffset,
        rangeLength,
        text
      }],
      eol: this._buffer.getEOL(),
      versionId: this.getVersionId(),
      isUndoing,
      isRedoing,
      isFlush
    };
  }
  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {
    this._assertNotDisposed();
    const oldFullModelRange = this.getFullModelRange();
    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
    const endLineNumber = this.getLineCount();
    const endColumn = this.getLineMaxColumn(endLineNumber);
    this._buffer = textBuffer;
    this._bufferDisposable.dispose();
    this._bufferDisposable = textBufferDisposable;
    this._increaseVersionId();
    this._tokens.flush();
    this._semanticTokens.flush();
    this._decorations = /* @__PURE__ */ Object.create(null);
    this._decorationsTree = new DecorationsTrees();
    this._commandManager.clear();
    this._trimAutoWhitespaceLines = null;
    this._emitContentChangedEvent(new ModelRawContentChangedEvent([
      new ModelRawFlush()
    ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));
  }
  setEOL(eol) {
    this._assertNotDisposed();
    const newEOL = eol === 1 ? "\r\n" : "\n";
    if (this._buffer.getEOL() === newEOL) {
      return;
    }
    const oldFullModelRange = this.getFullModelRange();
    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
    const endLineNumber = this.getLineCount();
    const endColumn = this.getLineMaxColumn(endLineNumber);
    this._onBeforeEOLChange();
    this._buffer.setEOL(newEOL);
    this._increaseVersionId();
    this._onAfterEOLChange();
    this._emitContentChangedEvent(new ModelRawContentChangedEvent([
      new ModelRawEOLChanged()
    ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));
  }
  _onBeforeEOLChange() {
    this._decorationsTree.ensureAllNodesHaveRanges(this);
  }
  _onAfterEOLChange() {
    const versionId = this.getVersionId();
    const allDecorations = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, len = allDecorations.length; i < len; i++) {
      const node = allDecorations[i];
      const range2 = node.range;
      const delta = node.cachedAbsoluteStart - node.start;
      const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
      const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
      node.cachedAbsoluteStart = startOffset;
      node.cachedAbsoluteEnd = endOffset;
      node.cachedVersionId = versionId;
      node.start = startOffset - delta;
      node.end = endOffset - delta;
      recomputeMaxEnd(node);
    }
  }
  onBeforeAttached() {
    this._attachedEditorCount++;
    if (this._attachedEditorCount === 1) {
      this._tokenization.handleDidChangeAttached();
      this._onDidChangeAttached.fire(void 0);
    }
  }
  onBeforeDetached() {
    this._attachedEditorCount--;
    if (this._attachedEditorCount === 0) {
      this._tokenization.handleDidChangeAttached();
      this._onDidChangeAttached.fire(void 0);
    }
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    this._assertNotDisposed();
    if (this.isTooLargeForTokenization()) {
      return false;
    }
    let smallLineCharCount = 0;
    let longLineCharCount = 0;
    const lineCount = this._buffer.getLineCount();
    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
      const lineLength = this._buffer.getLineLength(lineNumber);
      if (lineLength >= LONG_LINE_BOUNDARY) {
        longLineCharCount += lineLength;
      } else {
        smallLineCharCount += lineLength;
      }
    }
    return longLineCharCount > smallLineCharCount;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    this._assertNotDisposed();
    return this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(_newOpts) {
    this._assertNotDisposed();
    const tabSize = typeof _newOpts.tabSize !== "undefined" ? _newOpts.tabSize : this._options.tabSize;
    const indentSize = typeof _newOpts.indentSize !== "undefined" ? _newOpts.indentSize : this._options.indentSize;
    const insertSpaces = typeof _newOpts.insertSpaces !== "undefined" ? _newOpts.insertSpaces : this._options.insertSpaces;
    const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== "undefined" ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
    const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== "undefined" ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;
    const newOpts = new TextModelResolvedOptions({
      tabSize,
      indentSize,
      insertSpaces,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace,
      bracketPairColorizationOptions
    });
    if (this._options.equals(newOpts)) {
      return;
    }
    const e = this._options.createChangeEvent(newOpts);
    this._options = newOpts;
    this._bracketPairColorizer.handleDidChangeOptions(e);
    this._decorationProvider.handleDidChangeOptions(e);
    this._onDidChangeOptions.fire(e);
  }
  detectIndentation(defaultInsertSpaces, defaultTabSize) {
    this._assertNotDisposed();
    const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);
    this.updateOptions({
      insertSpaces: guessedIndentation.insertSpaces,
      tabSize: guessedIndentation.tabSize,
      indentSize: guessedIndentation.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  normalizeIndentation(str) {
    this._assertNotDisposed();
    return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    this._assertNotDisposed();
    return this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(selections = null) {
    const matches = this.findMatches(
      UNUSUAL_LINE_TERMINATORS.source,
      false,
      true,
      false,
      null,
      false,
      1073741824
      /* MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators();
    this.pushEditOperations(selections, matches.map((m) => ({ range: m.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    this._assertNotDisposed();
    return this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    this._assertNotDisposed();
    return this._initialUndoRedoSnapshot;
  }
  getOffsetAt(rawPosition) {
    this._assertNotDisposed();
    const position = this._validatePosition(
      rawPosition.lineNumber,
      rawPosition.column,
      0
      /* Relaxed */
    );
    return this._buffer.getOffsetAt(position.lineNumber, position.column);
  }
  getPositionAt(rawOffset) {
    this._assertNotDisposed();
    const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));
    return this._buffer.getPositionAt(offset);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1;
    this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(versionId) {
    this._versionId = versionId;
  }
  _overwriteAlternativeVersionId(newAlternativeVersionId) {
    this._alternativeVersionId = newAlternativeVersionId;
  }
  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {
    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;
  }
  getValue(eol, preserveBOM = false) {
    this._assertNotDisposed();
    const fullModelRange = this.getFullModelRange();
    const fullModelValue = this.getValueInRange(fullModelRange, eol);
    if (preserveBOM) {
      return this._buffer.getBOM() + fullModelValue;
    }
    return fullModelValue;
  }
  createSnapshot(preserveBOM = false) {
    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
  }
  getValueLength(eol, preserveBOM = false) {
    this._assertNotDisposed();
    const fullModelRange = this.getFullModelRange();
    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
    if (preserveBOM) {
      return this._buffer.getBOM().length + fullModelValue;
    }
    return fullModelValue;
  }
  getValueInRange(rawRange, eol = 0) {
    this._assertNotDisposed();
    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
  }
  getValueLengthInRange(rawRange, eol = 0) {
    this._assertNotDisposed();
    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
  }
  getCharacterCountInRange(rawRange, eol = 0) {
    this._assertNotDisposed();
    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);
  }
  getLineCount() {
    this._assertNotDisposed();
    return this._buffer.getLineCount();
  }
  getLineContent(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineContent(lineNumber);
  }
  getLineLength(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineLength(lineNumber);
  }
  getLinesContent() {
    this._assertNotDisposed();
    return this._buffer.getLinesContent();
  }
  getEOL() {
    this._assertNotDisposed();
    return this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    this._assertNotDisposed();
    return this._buffer.getEOL() === "\n" ? 0 : 1;
  }
  getLineMinColumn(lineNumber) {
    this._assertNotDisposed();
    return 1;
  }
  getLineMaxColumn(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineLength(lineNumber) + 1;
  }
  getLineFirstNonWhitespaceColumn(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
  }
  getLineLastNonWhitespaceColumn(lineNumber) {
    this._assertNotDisposed();
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(range2) {
    const linesCount = this._buffer.getLineCount();
    const initialStartLineNumber = range2.startLineNumber;
    const initialStartColumn = range2.startColumn;
    let startLineNumber = Math.floor(typeof initialStartLineNumber === "number" && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);
    let startColumn = Math.floor(typeof initialStartColumn === "number" && !isNaN(initialStartColumn) ? initialStartColumn : 1);
    if (startLineNumber < 1) {
      startLineNumber = 1;
      startColumn = 1;
    } else if (startLineNumber > linesCount) {
      startLineNumber = linesCount;
      startColumn = this.getLineMaxColumn(startLineNumber);
    } else {
      if (startColumn <= 1) {
        startColumn = 1;
      } else {
        const maxColumn = this.getLineMaxColumn(startLineNumber);
        if (startColumn >= maxColumn) {
          startColumn = maxColumn;
        }
      }
    }
    const initialEndLineNumber = range2.endLineNumber;
    const initialEndColumn = range2.endColumn;
    let endLineNumber = Math.floor(typeof initialEndLineNumber === "number" && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);
    let endColumn = Math.floor(typeof initialEndColumn === "number" && !isNaN(initialEndColumn) ? initialEndColumn : 1);
    if (endLineNumber < 1) {
      endLineNumber = 1;
      endColumn = 1;
    } else if (endLineNumber > linesCount) {
      endLineNumber = linesCount;
      endColumn = this.getLineMaxColumn(endLineNumber);
    } else {
      if (endColumn <= 1) {
        endColumn = 1;
      } else {
        const maxColumn = this.getLineMaxColumn(endLineNumber);
        if (endColumn >= maxColumn) {
          endColumn = maxColumn;
        }
      }
    }
    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range2 instanceof Range && !(range2 instanceof Selection)) {
      return range2;
    }
    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  _isValidPosition(lineNumber, column, validationType) {
    if (typeof lineNumber !== "number" || typeof column !== "number") {
      return false;
    }
    if (isNaN(lineNumber) || isNaN(column)) {
      return false;
    }
    if (lineNumber < 1 || column < 1) {
      return false;
    }
    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {
      return false;
    }
    const lineCount = this._buffer.getLineCount();
    if (lineNumber > lineCount) {
      return false;
    }
    if (column === 1) {
      return true;
    }
    const maxColumn = this.getLineMaxColumn(lineNumber);
    if (column > maxColumn) {
      return false;
    }
    if (validationType === 1) {
      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
      if (isHighSurrogate(charCodeBefore)) {
        return false;
      }
    }
    return true;
  }
  _validatePosition(_lineNumber, _column, validationType) {
    const lineNumber = Math.floor(typeof _lineNumber === "number" && !isNaN(_lineNumber) ? _lineNumber : 1);
    const column = Math.floor(typeof _column === "number" && !isNaN(_column) ? _column : 1);
    const lineCount = this._buffer.getLineCount();
    if (lineNumber < 1) {
      return new Position(1, 1);
    }
    if (lineNumber > lineCount) {
      return new Position(lineCount, this.getLineMaxColumn(lineCount));
    }
    if (column <= 1) {
      return new Position(lineNumber, 1);
    }
    const maxColumn = this.getLineMaxColumn(lineNumber);
    if (column >= maxColumn) {
      return new Position(lineNumber, maxColumn);
    }
    if (validationType === 1) {
      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
      if (isHighSurrogate(charCodeBefore)) {
        return new Position(lineNumber, column - 1);
      }
    }
    return new Position(lineNumber, column);
  }
  validatePosition(position) {
    const validationType = 1;
    this._assertNotDisposed();
    if (position instanceof Position) {
      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {
        return position;
      }
    }
    return this._validatePosition(position.lineNumber, position.column, validationType);
  }
  _isValidRange(range2, validationType) {
    const startLineNumber = range2.startLineNumber;
    const startColumn = range2.startColumn;
    const endLineNumber = range2.endLineNumber;
    const endColumn = range2.endColumn;
    if (!this._isValidPosition(
      startLineNumber,
      startColumn,
      0
      /* Relaxed */
    )) {
      return false;
    }
    if (!this._isValidPosition(
      endLineNumber,
      endColumn,
      0
      /* Relaxed */
    )) {
      return false;
    }
    if (validationType === 1) {
      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;
      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;
      const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
      const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
        return true;
      }
      return false;
    }
    return true;
  }
  validateRange(_range) {
    const validationType = 1;
    this._assertNotDisposed();
    if (_range instanceof Range && !(_range instanceof Selection)) {
      if (this._isValidRange(_range, validationType)) {
        return _range;
      }
    }
    const start = this._validatePosition(
      _range.startLineNumber,
      _range.startColumn,
      0
      /* Relaxed */
    );
    const end = this._validatePosition(
      _range.endLineNumber,
      _range.endColumn,
      0
      /* Relaxed */
    );
    const startLineNumber = start.lineNumber;
    const startColumn = start.column;
    const endLineNumber = end.lineNumber;
    const endColumn = end.column;
    if (validationType === 1) {
      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;
      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;
      const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
      const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      if (startLineNumber === endLineNumber && startColumn === endColumn) {
        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
      }
      if (startInsideSurrogatePair && endInsideSurrogatePair) {
        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
      }
      if (startInsideSurrogatePair) {
        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
      }
      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
    }
    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  modifyPosition(rawPosition, offset) {
    this._assertNotDisposed();
    const candidate = this.getOffsetAt(rawPosition) + offset;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const lineCount = this.getLineCount();
    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
  }
  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT2) {
    this._assertNotDisposed();
    let searchRanges = null;
    if (rawSearchScope !== null) {
      if (!Array.isArray(rawSearchScope)) {
        rawSearchScope = [rawSearchScope];
      }
      if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {
        searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));
      }
    }
    if (searchRanges === null) {
      searchRanges = [this.getFullModelRange()];
    }
    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);
    const uniqueSearchRanges = [];
    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {
      if (Range.areIntersecting(prev, curr)) {
        return prev.plusRange(curr);
      }
      uniqueSearchRanges.push(prev);
      return curr;
    }));
    let matchMapper;
    if (!isRegex && searchString.indexOf("\n") < 0) {
      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);
      const searchData = searchParams.parseSearchRequest();
      if (!searchData) {
        return [];
      }
      matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    } else {
      matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);
    }
    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);
  }
  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
    this._assertNotDisposed();
    const searchStart = this.validatePosition(rawSearchStart);
    if (!isRegex && searchString.indexOf("\n") < 0) {
      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);
      const searchData = searchParams.parseSearchRequest();
      if (!searchData) {
        return null;
      }
      const lineCount = this.getLineCount();
      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));
      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
      if (ret.length > 0) {
        return ret[0];
      }
      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));
      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
      if (ret.length > 0) {
        return ret[0];
      }
      return null;
    }
    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
  }
  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {
    this._assertNotDisposed();
    const searchStart = this.validatePosition(rawSearchStart);
    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(eol) {
    const currentEOL = this.getEOL() === "\n" ? 0 : 1;
    if (currentEOL === eol) {
      return;
    }
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      if (this._initialUndoRedoSnapshot === null) {
        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
      }
      this._commandManager.pushEOL(eol);
    } finally {
      this._eventEmitter.endDeferredEmit();
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _validateEditOperation(rawOperation) {
    if (rawOperation instanceof ValidAnnotatedEditOperation) {
      return rawOperation;
    }
    return new ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);
  }
  _validateEditOperations(rawOperations) {
    const result = [];
    for (let i = 0, len = rawOperations.length; i < len; i++) {
      result[i] = this._validateEditOperation(rawOperations[i]);
    }
    return result;
  }
  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);
    } finally {
      this._eventEmitter.endDeferredEmit();
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      const incomingEdits = editOperations.map((op) => {
        return {
          range: this.validateRange(op.range),
          text: op.text
        };
      });
      let editsAreNearCursors = true;
      if (beforeCursorState) {
        for (let i = 0, len = beforeCursorState.length; i < len; i++) {
          const sel = beforeCursorState[i];
          let foundEditNearSel = false;
          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
            const editRange = incomingEdits[j].range;
            const selIsAbove = editRange.startLineNumber > sel.endLineNumber;
            const selIsBelow = sel.startLineNumber > editRange.endLineNumber;
            if (!selIsAbove && !selIsBelow) {
              foundEditNearSel = true;
              break;
            }
          }
          if (!foundEditNearSel) {
            editsAreNearCursors = false;
            break;
          }
        }
      }
      if (editsAreNearCursors) {
        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
          const trimLineNumber = this._trimAutoWhitespaceLines[i];
          const maxLineColumn = this.getLineMaxColumn(trimLineNumber);
          let allowTrimLine = true;
          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
            const editRange = incomingEdits[j].range;
            const editText = incomingEdits[j].text;
            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
              continue;
            }
            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === "\n") {
              continue;
            }
            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === "\n") {
              continue;
            }
            allowTrimLine = false;
            break;
          }
          if (allowTrimLine) {
            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);
            editOperations.push(new ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));
          }
        }
      }
      this._trimAutoWhitespaceLines = null;
    }
    if (this._initialUndoRedoSnapshot === null) {
      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
    }
    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);
  }
  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
    const edits = changes.map((change) => {
      const rangeStart = this.getPositionAt(change.newPosition);
      const rangeEnd = this.getPositionAt(change.newEnd);
      return {
        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
        text: change.oldText
      };
    });
    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);
  }
  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
    const edits = changes.map((change) => {
      const rangeStart = this.getPositionAt(change.oldPosition);
      const rangeEnd = this.getPositionAt(change.oldEnd);
      return {
        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
        text: change.newText
      };
    });
    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);
  }
  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      this._isUndoing = isUndoing;
      this._isRedoing = isRedoing;
      this.applyEdits(edits, false);
      this.setEOL(eol);
      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);
    } finally {
      this._isUndoing = false;
      this._isRedoing = false;
      this._eventEmitter.endDeferredEmit(resultingSelection);
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(rawOperations, computeUndoEdits = false) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      this._eventEmitter.beginDeferredEmit();
      const operations = this._validateEditOperations(rawOperations);
      return this._doApplyEdits(operations, computeUndoEdits);
    } finally {
      this._eventEmitter.endDeferredEmit();
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(rawOperations, computeUndoEdits) {
    const oldLineCount = this._buffer.getLineCount();
    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);
    const newLineCount = this._buffer.getLineCount();
    const contentChanges = result.changes;
    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;
    if (contentChanges.length !== 0) {
      for (let i = 0, len = contentChanges.length; i < len; i++) {
        const change = contentChanges[i];
        const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);
        this._tokens.acceptEdit(change.range, eolCount, firstLineLength);
        this._semanticTokens.acceptEdit(
          change.range,
          eolCount,
          firstLineLength,
          lastLineLength,
          change.text.length > 0 ? change.text.charCodeAt(0) : 0
          /* Null */
        );
        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
      }
      const rawContentChanges = [];
      this._increaseVersionId();
      let lineCount = oldLineCount;
      for (let i = 0, len = contentChanges.length; i < len; i++) {
        const change = contentChanges[i];
        const [eolCount] = countEOL(change.text);
        this._onDidChangeDecorations.fire();
        const startLineNumber = change.range.startLineNumber;
        const endLineNumber = change.range.endLineNumber;
        const deletingLinesCnt = endLineNumber - startLineNumber;
        const insertingLinesCnt = eolCount;
        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;
        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;
        const firstEditLineNumber = currentEditStartLineNumber;
        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;
        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);
        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);
        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);
        for (let j = editingLinesCnt; j >= 0; j--) {
          const editLineNumber = startLineNumber + j;
          const currentEditLineNumber = currentEditStartLineNumber + j;
          injectedTextInEditedRangeQueue.takeFromEndWhile((r) => r.lineNumber > currentEditLineNumber);
          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile((r) => r.lineNumber === currentEditLineNumber);
          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));
        }
        if (editingLinesCnt < deletingLinesCnt) {
          const spliceStartLineNumber = startLineNumber + editingLinesCnt;
          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));
        }
        if (editingLinesCnt < insertingLinesCnt) {
          const injectedTextInEditedRangeQueue2 = new ArrayQueue(injectedTextInEditedRange);
          const spliceLineNumber = startLineNumber + editingLinesCnt;
          const cnt = insertingLinesCnt - editingLinesCnt;
          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;
          const injectedTexts = [];
          const newLines = [];
          for (let i2 = 0; i2 < cnt; i2++) {
            const lineNumber = fromLineNumber + i2;
            newLines[i2] = this.getLineContent(lineNumber);
            injectedTextInEditedRangeQueue2.takeWhile((r) => r.lineNumber < lineNumber);
            injectedTexts[i2] = injectedTextInEditedRangeQueue2.takeWhile((r) => r.lineNumber === lineNumber);
          }
          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));
        }
        lineCount += changeLineCountDelta;
      }
      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: contentChanges,
        eol: this._buffer.getEOL(),
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: false
      });
    }
    return result.reverseEdits === null ? void 0 : result.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {
    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {
      return;
    }
    const affectedLines = [...affectedInjectedTextLines];
    const lineChangeEvents = affectedLines.map((lineNumber) => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));
    this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));
  }
  changeDecorations(callback, ownerId = 0) {
    this._assertNotDisposed();
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      return this._changeDecorations(ownerId, callback);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(ownerId, callback) {
    const changeAccessor = {
      addDecoration: (range2, options) => {
        return this._deltaDecorationsImpl(ownerId, [], [{ range: range2, options }])[0];
      },
      changeDecoration: (id, newRange) => {
        this._changeDecorationImpl(id, newRange);
      },
      changeDecorationOptions: (id, options) => {
        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));
      },
      removeDecoration: (id) => {
        this._deltaDecorationsImpl(ownerId, [id], []);
      },
      deltaDecorations: (oldDecorations, newDecorations) => {
        if (oldDecorations.length === 0 && newDecorations.length === 0) {
          return [];
        }
        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
      }
    };
    let result = null;
    try {
      result = callback(changeAccessor);
    } catch (e) {
      onUnexpectedError(e);
    }
    changeAccessor.addDecoration = invalidFunc;
    changeAccessor.changeDecoration = invalidFunc;
    changeAccessor.changeDecorationOptions = invalidFunc;
    changeAccessor.removeDecoration = invalidFunc;
    changeAccessor.deltaDecorations = invalidFunc;
    return result;
  }
  deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {
    this._assertNotDisposed();
    if (!oldDecorations) {
      oldDecorations = [];
    }
    if (oldDecorations.length === 0 && newDecorations.length === 0) {
      return [];
    }
    try {
      this._onDidChangeDecorations.beginDeferredEmit();
      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _getTrackedRange(id) {
    return this.getDecorationRange(id);
  }
  _setTrackedRange(id, newRange, newStickiness) {
    const node = id ? this._decorations[id] : null;
    if (!node) {
      if (!newRange) {
        return null;
      }
      return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];
    }
    if (!newRange) {
      this._decorationsTree.delete(node);
      delete this._decorations[node.id];
      return null;
    }
    const range2 = this._validateRangeRelaxedNoAllocations(newRange);
    const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
    const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
    this._decorationsTree.delete(node);
    node.reset(this.getVersionId(), startOffset, endOffset, range2);
    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
    this._decorationsTree.insert(node);
    return node.id;
  }
  removeAllDecorationsWithOwnerId(ownerId) {
    if (this._isDisposed) {
      return;
    }
    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      this._decorationsTree.delete(node);
      delete this._decorations[node.id];
    }
  }
  getDecorationOptions(decorationId) {
    const node = this._decorations[decorationId];
    if (!node) {
      return null;
    }
    return node.options;
  }
  getDecorationRange(decorationId) {
    const node = this._decorations[decorationId];
    if (!node) {
      return null;
    }
    return this._decorationsTree.getNodeRange(this, node);
  }
  getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      return [];
    }
    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
  }
  getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {
    const lineCount = this.getLineCount();
    const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
    const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
    const endColumn = this.getLineMaxColumn(endLineNumber);
    const range2 = new Range(startLineNumber, 1, endLineNumber, endColumn);
    const decorations = this._getDecorationsInRange(range2, ownerId, filterOutValidation);
    decorations.push(...this._decorationProvider.getDecorationsInRange(range2, ownerId, filterOutValidation));
    return decorations;
  }
  getDecorationsInRange(range2, ownerId = 0, filterOutValidation = false) {
    const validatedRange = this.validateRange(range2);
    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);
    decorations.push(...this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));
    return decorations;
  }
  getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {
    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);
  }
  getInjectedTextDecorations(ownerId = 0) {
    return this._decorationsTree.getAllInjectedText(this, ownerId);
  }
  _getInjectedTextInLine(lineNumber) {
    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);
    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);
    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);
    return LineInjectedText.fromDecorations(result).filter((t) => t.lineNumber === lineNumber);
  }
  getAllDecorations(ownerId = 0, filterOutValidation = false) {
    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);
    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));
    return result;
  }
  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {
    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);
  }
  getRangeAt(start, end) {
    return this._buffer.getRangeAt(start, end - start);
  }
  _changeDecorationImpl(decorationId, _range) {
    const node = this._decorations[decorationId];
    if (!node) {
      return;
    }
    if (node.options.after) {
      const oldRange = this.getDecorationRange(decorationId);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);
    }
    if (node.options.before) {
      const oldRange = this.getDecorationRange(decorationId);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);
    }
    const range2 = this._validateRangeRelaxedNoAllocations(_range);
    const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
    const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
    this._decorationsTree.delete(node);
    node.reset(this.getVersionId(), startOffset, endOffset, range2);
    this._decorationsTree.insert(node);
    this._onDidChangeDecorations.checkAffectedAndFire(node.options);
    if (node.options.after) {
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.endLineNumber);
    }
    if (node.options.before) {
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.startLineNumber);
    }
  }
  _changeDecorationOptionsImpl(decorationId, options) {
    const node = this._decorations[decorationId];
    if (!node) {
      return;
    }
    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;
    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;
    this._onDidChangeDecorations.checkAffectedAndFire(node.options);
    this._onDidChangeDecorations.checkAffectedAndFire(options);
    if (node.options.after || options.after) {
      const nodeRange = this._decorationsTree.getNodeRange(this, node);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
    }
    if (node.options.before || options.before) {
      const nodeRange = this._decorationsTree.getNodeRange(this, node);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
    }
    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {
      this._decorationsTree.delete(node);
      node.setOptions(options);
      this._decorationsTree.insert(node);
    } else {
      node.setOptions(options);
    }
  }
  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {
    const versionId = this.getVersionId();
    const oldDecorationsLen = oldDecorationsIds.length;
    let oldDecorationIndex = 0;
    const newDecorationsLen = newDecorations.length;
    let newDecorationIndex = 0;
    const result = new Array(newDecorationsLen);
    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {
      let node = null;
      if (oldDecorationIndex < oldDecorationsLen) {
        do {
          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
        } while (!node && oldDecorationIndex < oldDecorationsLen);
        if (node) {
          if (node.options.after) {
            const nodeRange = this._decorationsTree.getNodeRange(this, node);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
          }
          if (node.options.before) {
            const nodeRange = this._decorationsTree.getNodeRange(this, node);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
          }
          this._decorationsTree.delete(node);
          this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        }
      }
      if (newDecorationIndex < newDecorationsLen) {
        if (!node) {
          const internalDecorationId = ++this._lastDecorationId;
          const decorationId = `${this._instanceId};${internalDecorationId}`;
          node = new IntervalNode(decorationId, 0, 0);
          this._decorations[decorationId] = node;
        }
        const newDecoration = newDecorations[newDecorationIndex];
        const range2 = this._validateRangeRelaxedNoAllocations(newDecoration.range);
        const options = _normalizeOptions(newDecoration.options);
        const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
        const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
        node.ownerId = ownerId;
        node.reset(versionId, startOffset, endOffset, range2);
        node.setOptions(options);
        if (node.options.after) {
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.endLineNumber);
        }
        if (node.options.before) {
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.startLineNumber);
        }
        this._onDidChangeDecorations.checkAffectedAndFire(options);
        this._decorationsTree.insert(node);
        result[newDecorationIndex] = node.id;
        newDecorationIndex++;
      } else {
        if (node) {
          delete this._decorations[node.id];
        }
      }
    }
    return result;
  }
  setTokens(tokens, backgroundTokenizationCompleted = false) {
    if (tokens.length !== 0) {
      const ranges = [];
      for (let i = 0, len = tokens.length; i < len; i++) {
        const element = tokens[i];
        let minChangedLineNumber = 0;
        let maxChangedLineNumber = 0;
        let hasChange = false;
        for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {
          if (hasChange) {
            this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);
            maxChangedLineNumber = lineNumber;
          } else {
            const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);
            if (lineHasChange) {
              hasChange = true;
              minChangedLineNumber = lineNumber;
              maxChangedLineNumber = lineNumber;
            }
          }
        }
        if (hasChange) {
          ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });
        }
      }
      if (ranges.length > 0) {
        this._emitModelTokensChangedEvent({
          tokenizationSupportChanged: false,
          semanticTokensApplied: false,
          ranges
        });
      }
    }
    this.handleTokenizationProgress(backgroundTokenizationCompleted);
  }
  setSemanticTokens(tokens, isComplete) {
    this._semanticTokens.set(tokens, isComplete);
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: false,
      semanticTokensApplied: tokens !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._semanticTokens.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._semanticTokens.isEmpty();
  }
  setPartialSemanticTokens(range2, tokens) {
    if (this.hasCompleteSemanticTokens()) {
      return;
    }
    const changedRange = this.validateRange(this._semanticTokens.setPartial(range2, tokens));
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: false,
      semanticTokensApplied: true,
      ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]
    });
  }
  tokenizeViewport(startLineNumber, endLineNumber) {
    startLineNumber = Math.max(1, startLineNumber);
    endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);
    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);
  }
  clearTokens() {
    this._tokens.flush();
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: true,
      semanticTokensApplied: false,
      ranges: [{
        fromLineNumber: 1,
        toLineNumber: this._buffer.getLineCount()
      }]
    });
  }
  _emitModelTokensChangedEvent(e) {
    if (!this._isDisposing) {
      this._bracketPairColorizer.handleDidChangeTokens(e);
      this._onDidChangeTokens.fire(e);
    }
  }
  resetTokenization() {
    this._tokenization.reset();
  }
  forceTokenization(lineNumber) {
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    this._tokenization.forceTokenization(lineNumber);
  }
  isCheapToTokenize(lineNumber) {
    return this._tokenization.isCheapToTokenize(lineNumber);
  }
  tokenizeIfCheap(lineNumber) {
    if (this.isCheapToTokenize(lineNumber)) {
      this.forceTokenization(lineNumber);
    }
  }
  getLineTokens(lineNumber) {
    if (lineNumber < 1 || lineNumber > this.getLineCount()) {
      throw new Error("Illegal value for lineNumber");
    }
    return this._getLineTokens(lineNumber);
  }
  _getLineTokens(lineNumber) {
    const lineText = this.getLineContent(lineNumber);
    const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);
    return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);
  }
  getLanguageId() {
    return this._languageId;
  }
  setMode(languageId) {
    if (this._languageId === languageId) {
      return;
    }
    const e = {
      oldLanguage: this._languageId,
      newLanguage: languageId
    };
    this._languageId = languageId;
    this._bracketPairColorizer.handleDidChangeLanguage(e);
    this._tokenization.handleDidChangeLanguage(e);
    this._onDidChangeLanguage.fire(e);
    this._onDidChangeLanguageConfiguration.fire({});
  }
  getLanguageIdAtPosition(lineNumber, column) {
    const position = this.validatePosition(new Position(lineNumber, column));
    const lineTokens = this.getLineTokens(position.lineNumber);
    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
  }
  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
    const position = this.validatePosition(new Position(lineNumber, column));
    return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);
  }
  tokenizeLineWithEdit(position, length, newText) {
    const validatedPosition = this.validatePosition(position);
    return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);
  }
  getLanguageConfiguration(languageId) {
    return this._languageConfigurationService.getLanguageConfiguration(languageId);
  }
  // Having tokens allows implementing additional helper methods
  getWordAtPosition(_position) {
    this._assertNotDisposed();
    const position = this.validatePosition(_position);
    const lineContent = this.getLineContent(position.lineNumber);
    const lineTokens = this._getLineTokens(position.lineNumber);
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    const [rbStartOffset, rbEndOffset] = TextModel2._findLanguageBoundaries(lineTokens, tokenIndex);
    const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {
      return rightBiasedWord;
    }
    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
      const [lbStartOffset, lbEndOffset] = TextModel2._findLanguageBoundaries(lineTokens, tokenIndex - 1);
      const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);
      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {
        return leftBiasedWord;
      }
    }
    return null;
  }
  static _findLanguageBoundaries(lineTokens, tokenIndex) {
    const languageId = lineTokens.getLanguageId(tokenIndex);
    let startOffset = 0;
    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {
      startOffset = lineTokens.getStartOffset(i);
    }
    let endOffset = lineTokens.getLineContent().length;
    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
      endOffset = lineTokens.getEndOffset(i);
    }
    return [startOffset, endOffset];
  }
  getWordUntilPosition(position) {
    const wordAtPosition = this.getWordAtPosition(position);
    if (!wordAtPosition) {
      return {
        word: "",
        startColumn: position.column,
        endColumn: position.column
      };
    }
    return {
      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
      startColumn: wordAtPosition.startColumn,
      endColumn: position.column
    };
  }
  //#endregion
  normalizePosition(position, affinity) {
    return position;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(lineNumber) {
    return indentOfLine(this.getLineContent(lineNumber)) + 1;
  }
};
TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
TextModel.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: false,
  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,
  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,
  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,
  detectIndentation: false,
  defaultEOL: 1,
  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions
};
TextModel = __decorate5([
  __param3(4, IUndoRedoService),
  __param3(5, ILanguageService),
  __param3(6, ILanguageConfigurationService)
], TextModel);
function indentOfLine(line) {
  let indent = 0;
  for (const c of line) {
    if (c === " " || c === "	") {
      indent++;
    } else {
      break;
    }
  }
  return indent;
}
function isNodeInOverviewRuler(node) {
  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;
}
function isNodeInjectedText(node) {
  return !!node.options.after || !!node.options.before;
}
var DecorationsTrees = class {
  constructor() {
    this._decorationsTree0 = new IntervalTree();
    this._decorationsTree1 = new IntervalTree();
    this._injectedTextDecorationsTree = new IntervalTree();
  }
  ensureAllNodesHaveRanges(host) {
    this.getAll(host, 0, false, false);
  }
  _ensureNodesHaveRanges(host, nodes) {
    for (const node of nodes) {
      if (node.range === null) {
        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
      }
    }
    return nodes;
  }
  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {
    const versionId = host.getVersionId();
    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);
    return this._ensureNodesHaveRanges(host, result);
  }
  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {
    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);
    return r0.concat(r1).concat(r2);
  }
  getInjectedTextInInterval(host, start, end, filterOwnerId) {
    const versionId = host.getVersionId();
    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);
    return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());
  }
  getAllInjectedText(host, filterOwnerId) {
    const versionId = host.getVersionId();
    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);
    return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());
  }
  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {
    const versionId = host.getVersionId();
    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);
    return this._ensureNodesHaveRanges(host, result);
  }
  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {
    if (overviewRulerOnly) {
      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
    } else {
      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);
      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);
      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);
      return r0.concat(r1).concat(r2);
    }
  }
  collectNodesFromOwner(ownerId) {
    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);
    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);
    return r0.concat(r1).concat(r2);
  }
  collectNodesPostOrder() {
    const r0 = this._decorationsTree0.collectNodesPostOrder();
    const r1 = this._decorationsTree1.collectNodesPostOrder();
    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();
    return r0.concat(r1).concat(r2);
  }
  insert(node) {
    if (isNodeInjectedText(node)) {
      this._injectedTextDecorationsTree.insert(node);
    } else if (isNodeInOverviewRuler(node)) {
      this._decorationsTree1.insert(node);
    } else {
      this._decorationsTree0.insert(node);
    }
  }
  delete(node) {
    if (isNodeInjectedText(node)) {
      this._injectedTextDecorationsTree.delete(node);
    } else if (isNodeInOverviewRuler(node)) {
      this._decorationsTree1.delete(node);
    } else {
      this._decorationsTree0.delete(node);
    }
  }
  getNodeRange(host, node) {
    const versionId = host.getVersionId();
    if (node.cachedVersionId !== versionId) {
      this._resolveNode(node, versionId);
    }
    if (node.range === null) {
      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
    }
    return node.range;
  }
  _resolveNode(node, cachedVersionId) {
    if (isNodeInjectedText(node)) {
      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);
    } else if (isNodeInOverviewRuler(node)) {
      this._decorationsTree1.resolveNode(node, cachedVersionId);
    } else {
      this._decorationsTree0.resolveNode(node, cachedVersionId);
    }
  }
  acceptReplace(offset, length, textLength, forceMoveMarkers) {
    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);
  }
};
function cleanClassName(className) {
  return className.replace(/[^a-z0-9\-_]/gi, " ");
}
var DecorationOptions = class {
  constructor(options) {
    this.color = options.color || "";
    this.darkColor = options.darkColor || "";
  }
};
var ModelDecorationOverviewRulerOptions = class extends DecorationOptions {
  constructor(options) {
    super(options);
    this._resolvedColor = null;
    this.position = typeof options.position === "number" ? options.position : OverviewRulerLane.Center;
  }
  getColor(theme) {
    if (!this._resolvedColor) {
      if (theme.type !== "light" && this.darkColor) {
        this._resolvedColor = this._resolveColor(this.darkColor, theme);
      } else {
        this._resolvedColor = this._resolveColor(this.color, theme);
      }
    }
    return this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(color, theme) {
    if (typeof color === "string") {
      return color;
    }
    const c = color ? theme.getColor(color.id) : null;
    if (!c) {
      return "";
    }
    return c.toString();
  }
};
var ModelDecorationMinimapOptions = class extends DecorationOptions {
  constructor(options) {
    super(options);
    this.position = options.position;
  }
  getColor(theme) {
    if (!this._resolvedColor) {
      if (theme.type !== "light" && this.darkColor) {
        this._resolvedColor = this._resolveColor(this.darkColor, theme);
      } else {
        this._resolvedColor = this._resolveColor(this.color, theme);
      }
    }
    return this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(color, theme) {
    if (typeof color === "string") {
      return Color.fromHex(color);
    }
    return theme.getColor(color.id);
  }
};
var ModelDecorationInjectedTextOptions = class _ModelDecorationInjectedTextOptions {
  constructor(options) {
    this.content = options.content || "";
    this.inlineClassName = options.inlineClassName || null;
    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
    this.attachedData = options.attachedData || null;
    this.cursorStops = options.cursorStops || null;
  }
  static from(options) {
    if (options instanceof _ModelDecorationInjectedTextOptions) {
      return options;
    }
    return new _ModelDecorationInjectedTextOptions(options);
  }
};
var ModelDecorationOptions = class _ModelDecorationOptions {
  constructor(options) {
    var _a3, _b;
    this.description = options.description;
    this.stickiness = options.stickiness || 0;
    this.zIndex = options.zIndex || 0;
    this.className = options.className ? cleanClassName(options.className) : null;
    this.hoverMessage = options.hoverMessage || null;
    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;
    this.isWholeLine = options.isWholeLine || false;
    this.showIfCollapsed = options.showIfCollapsed || false;
    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;
    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;
    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;
    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;
    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;
    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;
    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;
    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;
    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;
    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;
    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;
    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;
    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;
    this.hideInCommentTokens = (_a3 = options.hideInCommentTokens) !== null && _a3 !== void 0 ? _a3 : false;
    this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;
  }
  static register(options) {
    return new _ModelDecorationOptions(options);
  }
  static createDynamic(options) {
    return new _ModelDecorationOptions(options);
  }
};
ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: "empty" });
var TRACKED_RANGE_OPTIONS = [
  ModelDecorationOptions.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* AlwaysGrowsWhenTypingAtEdges */
  }),
  ModelDecorationOptions.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* NeverGrowsWhenTypingAtEdges */
  }),
  ModelDecorationOptions.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* GrowsOnlyWhenTypingBefore */
  }),
  ModelDecorationOptions.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* GrowsOnlyWhenTypingAfter */
  })
];
function _normalizeOptions(options) {
  if (options instanceof ModelDecorationOptions) {
    return options;
  }
  return ModelDecorationOptions.createDynamic(options);
}
var DidChangeDecorationsEmitter = class extends Disposable {
  constructor(handleBeforeFire) {
    super();
    this.handleBeforeFire = handleBeforeFire;
    this._actual = this._register(new Emitter());
    this.event = this._actual.event;
    this._affectedInjectedTextLines = null;
    this._deferredCnt = 0;
    this._shouldFire = false;
    this._affectsMinimap = false;
    this._affectsOverviewRuler = false;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    var _a3;
    this._deferredCnt--;
    if (this._deferredCnt === 0) {
      if (this._shouldFire) {
        this.handleBeforeFire(this._affectedInjectedTextLines);
        const event = {
          affectsMinimap: this._affectsMinimap,
          affectsOverviewRuler: this._affectsOverviewRuler
        };
        this._shouldFire = false;
        this._affectsMinimap = false;
        this._affectsOverviewRuler = false;
        this._actual.fire(event);
      }
      (_a3 = this._affectedInjectedTextLines) === null || _a3 === void 0 ? void 0 : _a3.clear();
      this._affectedInjectedTextLines = null;
    }
  }
  recordLineAffectedByInjectedText(lineNumber) {
    if (!this._affectedInjectedTextLines) {
      this._affectedInjectedTextLines = /* @__PURE__ */ new Set();
    }
    this._affectedInjectedTextLines.add(lineNumber);
  }
  checkAffectedAndFire(options) {
    if (!this._affectsMinimap) {
      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;
    }
    if (!this._affectsOverviewRuler) {
      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;
    }
    this._shouldFire = true;
  }
  fire() {
    this._affectsMinimap = true;
    this._affectsOverviewRuler = true;
    this._shouldFire = true;
  }
};
var DidChangeContentEmitter = class extends Disposable {
  constructor() {
    super();
    this._fastEmitter = this._register(new Emitter());
    this.fastEvent = this._fastEmitter.event;
    this._slowEmitter = this._register(new Emitter());
    this.slowEvent = this._slowEmitter.event;
    this._deferredCnt = 0;
    this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(resultingSelection = null) {
    this._deferredCnt--;
    if (this._deferredCnt === 0) {
      if (this._deferredEvent !== null) {
        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;
        const e = this._deferredEvent;
        this._deferredEvent = null;
        this._fastEmitter.fire(e);
        this._slowEmitter.fire(e);
      }
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      if (this._deferredEvent) {
        this._deferredEvent = this._deferredEvent.merge(e);
      } else {
        this._deferredEvent = e;
      }
      return;
    }
    this._fastEmitter.fire(e);
    this._slowEmitter.fire(e);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/fastDomNode.js
var FastDomNode = class {
  constructor(domNode) {
    this.domNode = domNode;
    this._maxWidth = -1;
    this._width = -1;
    this._height = -1;
    this._top = -1;
    this._left = -1;
    this._bottom = -1;
    this._right = -1;
    this._fontFamily = "";
    this._fontWeight = "";
    this._fontSize = -1;
    this._fontStyle = "";
    this._fontFeatureSettings = "";
    this._textDecoration = "";
    this._lineHeight = -1;
    this._letterSpacing = -100;
    this._className = "";
    this._display = "";
    this._position = "";
    this._visibility = "";
    this._color = "";
    this._backgroundColor = "";
    this._layerHint = false;
    this._contain = "none";
    this._boxShadow = "";
  }
  setMaxWidth(maxWidth) {
    if (this._maxWidth === maxWidth) {
      return;
    }
    this._maxWidth = maxWidth;
    this.domNode.style.maxWidth = this._maxWidth + "px";
  }
  setWidth(width) {
    if (this._width === width) {
      return;
    }
    this._width = width;
    this.domNode.style.width = this._width + "px";
  }
  setHeight(height) {
    if (this._height === height) {
      return;
    }
    this._height = height;
    this.domNode.style.height = this._height + "px";
  }
  setTop(top) {
    if (this._top === top) {
      return;
    }
    this._top = top;
    this.domNode.style.top = this._top + "px";
  }
  unsetTop() {
    if (this._top === -1) {
      return;
    }
    this._top = -1;
    this.domNode.style.top = "";
  }
  setLeft(left) {
    if (this._left === left) {
      return;
    }
    this._left = left;
    this.domNode.style.left = this._left + "px";
  }
  setBottom(bottom) {
    if (this._bottom === bottom) {
      return;
    }
    this._bottom = bottom;
    this.domNode.style.bottom = this._bottom + "px";
  }
  setRight(right) {
    if (this._right === right) {
      return;
    }
    this._right = right;
    this.domNode.style.right = this._right + "px";
  }
  setFontFamily(fontFamily) {
    if (this._fontFamily === fontFamily) {
      return;
    }
    this._fontFamily = fontFamily;
    this.domNode.style.fontFamily = this._fontFamily;
  }
  setFontWeight(fontWeight) {
    if (this._fontWeight === fontWeight) {
      return;
    }
    this._fontWeight = fontWeight;
    this.domNode.style.fontWeight = this._fontWeight;
  }
  setFontSize(fontSize) {
    if (this._fontSize === fontSize) {
      return;
    }
    this._fontSize = fontSize;
    this.domNode.style.fontSize = this._fontSize + "px";
  }
  setFontStyle(fontStyle) {
    if (this._fontStyle === fontStyle) {
      return;
    }
    this._fontStyle = fontStyle;
    this.domNode.style.fontStyle = this._fontStyle;
  }
  setFontFeatureSettings(fontFeatureSettings) {
    if (this._fontFeatureSettings === fontFeatureSettings) {
      return;
    }
    this._fontFeatureSettings = fontFeatureSettings;
    this.domNode.style.fontFeatureSettings = this._fontFeatureSettings;
  }
  setTextDecoration(textDecoration) {
    if (this._textDecoration === textDecoration) {
      return;
    }
    this._textDecoration = textDecoration;
    this.domNode.style.textDecoration = this._textDecoration;
  }
  setLineHeight(lineHeight) {
    if (this._lineHeight === lineHeight) {
      return;
    }
    this._lineHeight = lineHeight;
    this.domNode.style.lineHeight = this._lineHeight + "px";
  }
  setLetterSpacing(letterSpacing) {
    if (this._letterSpacing === letterSpacing) {
      return;
    }
    this._letterSpacing = letterSpacing;
    this.domNode.style.letterSpacing = this._letterSpacing + "px";
  }
  setClassName(className) {
    if (this._className === className) {
      return;
    }
    this._className = className;
    this.domNode.className = this._className;
  }
  toggleClassName(className, shouldHaveIt) {
    this.domNode.classList.toggle(className, shouldHaveIt);
    this._className = this.domNode.className;
  }
  setDisplay(display) {
    if (this._display === display) {
      return;
    }
    this._display = display;
    this.domNode.style.display = this._display;
  }
  setPosition(position) {
    if (this._position === position) {
      return;
    }
    this._position = position;
    this.domNode.style.position = this._position;
  }
  setVisibility(visibility) {
    if (this._visibility === visibility) {
      return;
    }
    this._visibility = visibility;
    this.domNode.style.visibility = this._visibility;
  }
  setColor(color) {
    if (this._color === color) {
      return;
    }
    this._color = color;
    this.domNode.style.color = this._color;
  }
  setBackgroundColor(backgroundColor) {
    if (this._backgroundColor === backgroundColor) {
      return;
    }
    this._backgroundColor = backgroundColor;
    this.domNode.style.backgroundColor = this._backgroundColor;
  }
  setLayerHinting(layerHint) {
    if (this._layerHint === layerHint) {
      return;
    }
    this._layerHint = layerHint;
    this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "";
  }
  setBoxShadow(boxShadow) {
    if (this._boxShadow === boxShadow) {
      return;
    }
    this._boxShadow = boxShadow;
    this.domNode.style.boxShadow = boxShadow;
  }
  setContain(contain) {
    if (this._contain === contain) {
      return;
    }
    this._contain = contain;
    this.domNode.style.contain = this._contain;
  }
  setAttribute(name, value) {
    this.domNode.setAttribute(name, value);
  }
  removeAttribute(name) {
    this.domNode.removeAttribute(name);
  }
  appendChild(child) {
    this.domNode.appendChild(child.domNode);
  }
  removeChild(child) {
    this.domNode.removeChild(child.domNode);
  }
};
function createFastDomNode(domNode) {
  return new FastDomNode(domNode);
}

// node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js
function renderText(text, options = {}) {
  const element = createElement(options);
  element.textContent = text;
  return element;
}
function renderFormattedText(formattedText, options = {}) {
  const element = createElement(options);
  _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);
  return element;
}
function createElement(options) {
  const tagName = options.inline ? "span" : "div";
  const element = document.createElement(tagName);
  if (options.className) {
    element.className = options.className;
  }
  return element;
}
var StringStream = class {
  constructor(source) {
    this.source = source;
    this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const next = this.peek();
    this.advance();
    return next;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
};
function _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {
  let child;
  if (treeNode.type === 2) {
    child = document.createTextNode(treeNode.content || "");
  } else if (treeNode.type === 3) {
    child = document.createElement("b");
  } else if (treeNode.type === 4) {
    child = document.createElement("i");
  } else if (treeNode.type === 7 && renderCodeSegments) {
    child = document.createElement("code");
  } else if (treeNode.type === 5 && actionHandler) {
    const a = document.createElement("a");
    actionHandler.disposables.add(addStandardDisposableListener(a, "click", (event) => {
      actionHandler.callback(String(treeNode.index), event);
    }));
    child = a;
  } else if (treeNode.type === 8) {
    child = document.createElement("br");
  } else if (treeNode.type === 1) {
    child = element;
  }
  if (child && element !== child) {
    element.appendChild(child);
  }
  if (child && Array.isArray(treeNode.children)) {
    treeNode.children.forEach((nodeChild) => {
      _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);
    });
  }
}
function parseFormattedText(content, parseCodeSegments) {
  const root = {
    type: 1,
    children: []
  };
  let actionViewItemIndex = 0;
  let current = root;
  const stack = [];
  const stream = new StringStream(content);
  while (!stream.eos()) {
    let next = stream.next();
    const isEscapedFormatType = next === "\\" && formatTagType(stream.peek(), parseCodeSegments) !== 0;
    if (isEscapedFormatType) {
      next = stream.next();
    }
    if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {
      stream.advance();
      if (current.type === 2) {
        current = stack.pop();
      }
      const type = formatTagType(next, parseCodeSegments);
      if (current.type === type || current.type === 5 && type === 6) {
        current = stack.pop();
      } else {
        const newCurrent = {
          type,
          children: []
        };
        if (type === 5) {
          newCurrent.index = actionViewItemIndex;
          actionViewItemIndex++;
        }
        current.children.push(newCurrent);
        stack.push(current);
        current = newCurrent;
      }
    } else if (next === "\n") {
      if (current.type === 2) {
        current = stack.pop();
      }
      current.children.push({
        type: 8
        /* NewLine */
      });
    } else {
      if (current.type !== 2) {
        const textCurrent = {
          type: 2,
          content: next
        };
        current.children.push(textCurrent);
        stack.push(current);
        current = textCurrent;
      } else {
        current.content += next;
      }
    }
  }
  if (current.type === 2) {
    current = stack.pop();
  }
  if (stack.length) {
  }
  return root;
}
function isFormatTag(char, supportCodeSegments) {
  return formatTagType(char, supportCodeSegments) !== 0;
}
function formatTagType(char, supportCodeSegments) {
  switch (char) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return supportCodeSegments ? 7 : 0;
    default:
      return 0;
  }
}

// node_modules/monaco-editor/esm/vs/base/browser/dnd.js
var DataTransfers = {
  /**
   * Application specific resource transfer type
   */
  RESOURCES: "ResourceURLs",
  /**
   * Browser specific transfer type to download
   */
  DOWNLOAD_URL: "DownloadURL",
  /**
   * Browser specific transfer type for files
   */
  FILES: "Files",
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: Mimes.text,
  /**
   * Application specific terminal transfer type.
   */
  TERMINALS: "Terminals"
};
var DragAndDropData = class {
  constructor(data) {
    this.data = data;
  }
  update() {
  }
  getData() {
    return this.data;
  }
};
var StaticDND = {
  CurrentDragAndDropData: void 0
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js
import "/home/ubuntu/project/s/front2.0/node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css";
var BaseActionViewItem = class extends Disposable {
  constructor(context, action, options = {}) {
    super();
    this.options = options;
    this._context = context || this;
    this._action = action;
    if (action instanceof Action) {
      this._register(action.onDidChange((event) => {
        if (!this.element) {
          return;
        }
        this.handleActionChangeEvent(event);
      }));
    }
  }
  handleActionChangeEvent(event) {
    if (event.enabled !== void 0) {
      this.updateEnabled();
    }
    if (event.checked !== void 0) {
      this.updateChecked();
    }
    if (event.class !== void 0) {
      this.updateClass();
    }
    if (event.label !== void 0) {
      this.updateLabel();
      this.updateTooltip();
    }
    if (event.tooltip !== void 0) {
      this.updateTooltip();
    }
  }
  get actionRunner() {
    if (!this._actionRunner) {
      this._actionRunner = this._register(new ActionRunner());
    }
    return this._actionRunner;
  }
  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner;
  }
  getAction() {
    return this._action;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(newContext) {
    this._context = newContext;
  }
  render(container) {
    const element = this.element = container;
    this._register(Gesture.addTarget(container));
    const enableDragging = this.options && this.options.draggable;
    if (enableDragging) {
      container.draggable = true;
      if (isFirefox2) {
        this._register(addDisposableListener(container, EventType.DRAG_START, (e) => {
          var _a3;
          return (_a3 = e.dataTransfer) === null || _a3 === void 0 ? void 0 : _a3.setData(DataTransfers.TEXT, this._action.label);
        }));
      }
    }
    this._register(addDisposableListener(element, EventType2.Tap, (e) => this.onClick(e, true)));
    this._register(addDisposableListener(element, EventType.MOUSE_DOWN, (e) => {
      if (!enableDragging) {
        EventHelper.stop(e, true);
      }
      if (this._action.enabled && e.button === 0) {
        element.classList.add("active");
      }
    }));
    if (isMacintosh) {
      this._register(addDisposableListener(element, EventType.CONTEXT_MENU, (e) => {
        if (e.button === 0 && e.ctrlKey === true) {
          this.onClick(e);
        }
      }));
    }
    this._register(addDisposableListener(element, EventType.CLICK, (e) => {
      EventHelper.stop(e, true);
      if (!(this.options && this.options.isMenu)) {
        this.onClick(e);
      }
    }));
    this._register(addDisposableListener(element, EventType.DBLCLICK, (e) => {
      EventHelper.stop(e, true);
    }));
    [EventType.MOUSE_UP, EventType.MOUSE_OUT].forEach((event) => {
      this._register(addDisposableListener(element, event, (e) => {
        EventHelper.stop(e);
        element.classList.remove("active");
      }));
    });
  }
  onClick(event, preserveFocus = false) {
    var _a3;
    EventHelper.stop(event, true);
    const context = isUndefinedOrNull(this._context) ? ((_a3 = this.options) === null || _a3 === void 0 ? void 0 : _a3.useEventAsContext) ? event : { preserveFocus } : this._context;
    this.actionRunner.run(this._action, context);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    if (this.element) {
      this.element.tabIndex = 0;
      this.element.focus();
      this.element.classList.add("focused");
    }
  }
  blur() {
    if (this.element) {
      this.element.blur();
      this.element.tabIndex = -1;
      this.element.classList.remove("focused");
    }
  }
  setFocusable(focusable) {
    if (this.element) {
      this.element.tabIndex = focusable ? 0 : -1;
    }
  }
  get trapsArrowNavigation() {
    return false;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  updateTooltip() {
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    if (this.element) {
      this.element.remove();
      this.element = void 0;
    }
    super.dispose();
  }
};
var ActionViewItem = class extends BaseActionViewItem {
  constructor(context, action, options = {}) {
    super(context, action, options);
    this.options = options;
    this.options.icon = options.icon !== void 0 ? options.icon : false;
    this.options.label = options.label !== void 0 ? options.label : true;
    this.cssClass = "";
  }
  render(container) {
    super.render(container);
    if (this.element) {
      this.label = append(this.element, $("a.action-label"));
    }
    if (this.label) {
      if (this._action.id === Separator.ID) {
        this.label.setAttribute("role", "presentation");
      } else {
        if (this.options.isMenu) {
          this.label.setAttribute("role", "menuitem");
        } else {
          this.label.setAttribute("role", "button");
        }
      }
    }
    if (this.options.label && this.options.keybinding && this.element) {
      append(this.element, $("span.keybinding")).textContent = this.options.keybinding;
    }
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    if (this.label) {
      this.label.tabIndex = 0;
      this.label.focus();
    }
  }
  blur() {
    if (this.label) {
      this.label.tabIndex = -1;
    }
  }
  setFocusable(focusable) {
    if (this.label) {
      this.label.tabIndex = focusable ? 0 : -1;
    }
  }
  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this.getAction().label;
    }
  }
  updateTooltip() {
    let title = null;
    if (this.getAction().tooltip) {
      title = this.getAction().tooltip;
    } else if (!this.options.label && this.getAction().label && this.options.icon) {
      title = this.getAction().label;
      if (this.options.keybinding) {
        title = localize({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", title, this.options.keybinding);
      }
    }
    if (title && this.label) {
      this.label.title = title;
    }
  }
  updateClass() {
    if (this.cssClass && this.label) {
      this.label.classList.remove(...this.cssClass.split(" "));
    }
    if (this.options.icon) {
      this.cssClass = this.getAction().class;
      if (this.label) {
        this.label.classList.add("codicon");
        if (this.cssClass) {
          this.label.classList.add(...this.cssClass.split(" "));
        }
      }
      this.updateEnabled();
    } else {
      if (this.label) {
        this.label.classList.remove("codicon");
      }
    }
  }
  updateEnabled() {
    if (this.getAction().enabled) {
      if (this.label) {
        this.label.removeAttribute("aria-disabled");
        this.label.classList.remove("disabled");
      }
      if (this.element) {
        this.element.classList.remove("disabled");
      }
    } else {
      if (this.label) {
        this.label.setAttribute("aria-disabled", "true");
        this.label.classList.add("disabled");
      }
      if (this.element) {
        this.element.classList.add("disabled");
      }
    }
  }
  updateChecked() {
    if (this.label) {
      if (this.getAction().checked) {
        this.label.classList.add("checked");
      } else {
        this.label.classList.remove("checked");
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js
import "/home/ubuntu/project/s/front2.0/node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css";
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ActionBar = class extends Disposable {
  constructor(container, options = {}) {
    var _a3, _b, _c, _d, _e, _f;
    super();
    this.triggerKeyDown = false;
    this.focusable = true;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onDidCancel = this._register(new Emitter({ onFirstListenerAdd: () => this.cancelHasListener = true }));
    this.onDidCancel = this._onDidCancel.event;
    this.cancelHasListener = false;
    this._onDidRun = this._register(new Emitter());
    this.onDidRun = this._onDidRun.event;
    this._onBeforeRun = this._register(new Emitter());
    this.onBeforeRun = this._onBeforeRun.event;
    this.options = options;
    this._context = (_a3 = options.context) !== null && _a3 !== void 0 ? _a3 : null;
    this._orientation = (_b = this.options.orientation) !== null && _b !== void 0 ? _b : 0;
    this._triggerKeys = {
      keyDown: (_d = (_c = this.options.triggerKeys) === null || _c === void 0 ? void 0 : _c.keyDown) !== null && _d !== void 0 ? _d : false,
      keys: (_f = (_e = this.options.triggerKeys) === null || _e === void 0 ? void 0 : _e.keys) !== null && _f !== void 0 ? _f : [
        3,
        10
        /* Space */
      ]
    };
    if (this.options.actionRunner) {
      this._actionRunner = this.options.actionRunner;
    } else {
      this._actionRunner = new ActionRunner();
      this._register(this._actionRunner);
    }
    this._register(this._actionRunner.onDidRun((e) => this._onDidRun.fire(e)));
    this._register(this._actionRunner.onBeforeRun((e) => this._onBeforeRun.fire(e)));
    this._actionIds = [];
    this.viewItems = [];
    this.focusedItem = void 0;
    this.domNode = document.createElement("div");
    this.domNode.className = "monaco-action-bar";
    if (options.animated !== false) {
      this.domNode.classList.add("animated");
    }
    let previousKeys;
    let nextKeys;
    switch (this._orientation) {
      case 0:
        previousKeys = [
          15
          /* LeftArrow */
        ];
        nextKeys = [
          17
          /* RightArrow */
        ];
        break;
      case 1:
        previousKeys = [
          16
          /* UpArrow */
        ];
        nextKeys = [
          18
          /* DownArrow */
        ];
        this.domNode.className += " vertical";
        break;
    }
    this._register(addDisposableListener(this.domNode, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = true;
      const focusedItem = typeof this.focusedItem === "number" ? this.viewItems[this.focusedItem] : void 0;
      if (previousKeys && (event.equals(previousKeys[0]) || event.equals(previousKeys[1]))) {
        eventHandled = this.focusPrevious();
      } else if (nextKeys && (event.equals(nextKeys[0]) || event.equals(nextKeys[1]))) {
        eventHandled = this.focusNext();
      } else if (event.equals(
        9
        /* Escape */
      ) && this.cancelHasListener) {
        this._onDidCancel.fire();
      } else if (event.equals(
        14
        /* Home */
      )) {
        eventHandled = this.focusFirst();
      } else if (event.equals(
        13
        /* End */
      )) {
        eventHandled = this.focusLast();
      } else if (event.equals(
        2
        /* Tab */
      ) && focusedItem instanceof BaseActionViewItem && focusedItem.trapsArrowNavigation) {
        eventHandled = this.focusNext();
      } else if (this.isTriggerKeyEvent(event)) {
        if (this._triggerKeys.keyDown) {
          this.doTrigger(event);
        } else {
          this.triggerKeyDown = true;
        }
      } else {
        eventHandled = false;
      }
      if (eventHandled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.domNode, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (this.isTriggerKeyEvent(event)) {
        if (!this._triggerKeys.keyDown && this.triggerKeyDown) {
          this.triggerKeyDown = false;
          this.doTrigger(event);
        }
        event.preventDefault();
        event.stopPropagation();
      } else if (event.equals(
        2
        /* Tab */
      ) || event.equals(
        1024 | 2
        /* Tab */
      )) {
        this.updateFocusedItem();
      }
    }));
    this.focusTracker = this._register(trackFocus(this.domNode));
    this._register(this.focusTracker.onDidBlur(() => {
      if (getActiveElement() === this.domNode || !isAncestor(getActiveElement(), this.domNode)) {
        this._onDidBlur.fire();
        this.focusedItem = void 0;
        this.previouslyFocusedItem = void 0;
        this.triggerKeyDown = false;
      }
    }));
    this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem()));
    this.actionsList = document.createElement("ul");
    this.actionsList.className = "actions-container";
    this.actionsList.setAttribute("role", "toolbar");
    if (this.options.ariaLabel) {
      this.actionsList.setAttribute("aria-label", this.options.ariaLabel);
    }
    this.domNode.appendChild(this.actionsList);
    container.appendChild(this.domNode);
  }
  refreshRole() {
    if (this.length() >= 2) {
      this.actionsList.setAttribute("role", "toolbar");
    } else {
      this.actionsList.setAttribute("role", "presentation");
    }
  }
  // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused
  setFocusable(focusable) {
    this.focusable = focusable;
    if (this.focusable) {
      const firstEnabled = this.viewItems.find((vi) => vi instanceof BaseActionViewItem && vi.isEnabled());
      if (firstEnabled instanceof BaseActionViewItem) {
        firstEnabled.setFocusable(true);
      }
    } else {
      this.viewItems.forEach((vi) => {
        if (vi instanceof BaseActionViewItem) {
          vi.setFocusable(false);
        }
      });
    }
  }
  isTriggerKeyEvent(event) {
    let ret = false;
    this._triggerKeys.keys.forEach((keyCode) => {
      ret = ret || event.equals(keyCode);
    });
    return ret;
  }
  updateFocusedItem() {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const elem = this.actionsList.children[i];
      if (isAncestor(getActiveElement(), elem)) {
        this.focusedItem = i;
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(context) {
    this._context = context;
    this.viewItems.forEach((i) => i.setActionContext(context));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(actionRunner) {
    if (actionRunner) {
      this._actionRunner = actionRunner;
      this.viewItems.forEach((item) => item.actionRunner = actionRunner);
    }
  }
  getContainer() {
    return this.domNode;
  }
  push(arg, options = {}) {
    const actions = Array.isArray(arg) ? arg : [arg];
    let index = isNumber(options.index) ? options.index : null;
    actions.forEach((action) => {
      const actionViewItemElement = document.createElement("li");
      actionViewItemElement.className = "action-item";
      actionViewItemElement.setAttribute("role", "presentation");
      if (!this.options.allowContextMenu) {
        this._register(addDisposableListener(actionViewItemElement, EventType.CONTEXT_MENU, (e) => {
          EventHelper.stop(e, true);
        }));
      }
      let item;
      if (this.options.actionViewItemProvider) {
        item = this.options.actionViewItemProvider(action);
      }
      if (!item) {
        item = new ActionViewItem(this.context, action, options);
      }
      item.actionRunner = this._actionRunner;
      item.setActionContext(this.context);
      item.render(actionViewItemElement);
      if (this.focusable && item instanceof BaseActionViewItem && this.viewItems.length === 0) {
        item.setFocusable(true);
      }
      if (index === null || index < 0 || index >= this.actionsList.children.length) {
        this.actionsList.appendChild(actionViewItemElement);
        this.viewItems.push(item);
        this._actionIds.push(action.id);
      } else {
        this.actionsList.insertBefore(actionViewItemElement, this.actionsList.children[index]);
        this.viewItems.splice(index, 0, item);
        this._actionIds.splice(index, 0, action.id);
        index++;
      }
    });
    if (typeof this.focusedItem === "number") {
      this.focus(this.focusedItem);
    }
    this.refreshRole();
  }
  clear() {
    dispose(this.viewItems);
    this.viewItems = [];
    this._actionIds = [];
    clearNode(this.actionsList);
    this.refreshRole();
  }
  length() {
    return this.viewItems.length;
  }
  focus(arg) {
    let selectFirst = false;
    let index = void 0;
    if (arg === void 0) {
      selectFirst = true;
    } else if (typeof arg === "number") {
      index = arg;
    } else if (typeof arg === "boolean") {
      selectFirst = arg;
    }
    if (selectFirst && typeof this.focusedItem === "undefined") {
      const firstEnabled = this.viewItems.findIndex((item) => item.isEnabled());
      this.focusedItem = firstEnabled === -1 ? void 0 : firstEnabled;
      this.updateFocus(void 0, void 0, true);
    } else {
      if (index !== void 0) {
        this.focusedItem = index;
      }
      this.updateFocus(void 0, void 0, true);
    }
  }
  focusFirst() {
    this.focusedItem = this.length() - 1;
    return this.focusNext(true);
  }
  focusLast() {
    this.focusedItem = 0;
    return this.focusPrevious(true);
  }
  focusNext(forceLoop) {
    if (typeof this.focusedItem === "undefined") {
      this.focusedItem = this.viewItems.length - 1;
    } else if (this.viewItems.length <= 1) {
      return false;
    }
    const startIndex = this.focusedItem;
    let item;
    do {
      if (!forceLoop && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length) {
        this.focusedItem = startIndex;
        return false;
      }
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length;
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && this.options.focusOnlyEnabledItems && !item.isEnabled());
    this.updateFocus();
    return true;
  }
  focusPrevious(forceLoop) {
    if (typeof this.focusedItem === "undefined") {
      this.focusedItem = 0;
    } else if (this.viewItems.length <= 1) {
      return false;
    }
    const startIndex = this.focusedItem;
    let item;
    do {
      this.focusedItem = this.focusedItem - 1;
      if (this.focusedItem < 0) {
        if (!forceLoop && this.options.preventLoopNavigation) {
          this.focusedItem = startIndex;
          return false;
        }
        this.focusedItem = this.viewItems.length - 1;
      }
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && this.options.focusOnlyEnabledItems && !item.isEnabled());
    this.updateFocus(true);
    return true;
  }
  updateFocus(fromRight, preventScroll, forceFocus = false) {
    var _a3;
    if (typeof this.focusedItem === "undefined") {
      this.actionsList.focus({ preventScroll });
    }
    if (this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem) {
      (_a3 = this.viewItems[this.previouslyFocusedItem]) === null || _a3 === void 0 ? void 0 : _a3.blur();
    }
    const actionViewItem = this.focusedItem !== void 0 && this.viewItems[this.focusedItem];
    if (actionViewItem) {
      let focusItem = true;
      if (!isFunction(actionViewItem.focus)) {
        focusItem = false;
      }
      if (this.options.focusOnlyEnabledItems && isFunction(actionViewItem.isEnabled) && !actionViewItem.isEnabled()) {
        focusItem = false;
      }
      if (!focusItem) {
        this.actionsList.focus({ preventScroll });
        this.previouslyFocusedItem = void 0;
      } else if (forceFocus || this.previouslyFocusedItem !== this.focusedItem) {
        actionViewItem.focus(fromRight);
        this.previouslyFocusedItem = this.focusedItem;
      }
    }
  }
  doTrigger(event) {
    if (typeof this.focusedItem === "undefined") {
      return;
    }
    const actionViewItem = this.viewItems[this.focusedItem];
    if (actionViewItem instanceof BaseActionViewItem) {
      const context = actionViewItem._context === null || actionViewItem._context === void 0 ? event : actionViewItem._context;
      this.run(actionViewItem._action, context);
    }
  }
  run(action, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this._actionRunner.run(action, context);
    });
  }
  dispose() {
    dispose(this.viewItems);
    this.viewItems = [];
    this._actionIds = [];
    this.getContainer().remove();
    super.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/globalMouseMoveMonitor.js
function standardMouseMoveMerger(lastEvent, currentEvent) {
  let ev = new StandardMouseEvent(currentEvent);
  ev.preventDefault();
  return {
    leftButton: ev.leftButton,
    buttons: ev.buttons,
    posx: ev.posx,
    posy: ev.posy
  };
}
var GlobalMouseMoveMonitor = class {
  constructor() {
    this._hooks = new DisposableStore();
    this._mouseMoveEventMerger = null;
    this._mouseMoveCallback = null;
    this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(false);
    this._hooks.dispose();
  }
  stopMonitoring(invokeStopCallback, browserEvent) {
    if (!this.isMonitoring()) {
      return;
    }
    this._hooks.clear();
    this._mouseMoveEventMerger = null;
    this._mouseMoveCallback = null;
    const onStopCallback = this._onStopCallback;
    this._onStopCallback = null;
    if (invokeStopCallback && onStopCallback) {
      onStopCallback(browserEvent);
    }
  }
  isMonitoring() {
    return !!this._mouseMoveEventMerger;
  }
  startMonitoring(initialElement, initialButtons, mouseMoveEventMerger, mouseMoveCallback, onStopCallback) {
    if (this.isMonitoring()) {
      return;
    }
    this._mouseMoveEventMerger = mouseMoveEventMerger;
    this._mouseMoveCallback = mouseMoveCallback;
    this._onStopCallback = onStopCallback;
    const windowChain = IframeUtils.getSameOriginWindowChain();
    const mouseMove = isIOS ? "pointermove" : "mousemove";
    const mouseUp = "mouseup";
    const listenTo = windowChain.map((element) => element.window.document);
    const shadowRoot = getShadowRoot(initialElement);
    if (shadowRoot) {
      listenTo.unshift(shadowRoot);
    }
    for (const element of listenTo) {
      this._hooks.add(addDisposableThrottledListener(element, mouseMove, (data) => {
        if (data.buttons !== initialButtons) {
          this.stopMonitoring(true);
          return;
        }
        this._mouseMoveCallback(data);
      }, (lastEvent, currentEvent) => this._mouseMoveEventMerger(lastEvent, currentEvent)));
      this._hooks.add(addDisposableListener(element, mouseUp, (e) => this.stopMonitoring(true)));
    }
    if (IframeUtils.hasDifferentOriginAncestor()) {
      let lastSameOriginAncestor = windowChain[windowChain.length - 1];
      this._hooks.add(addDisposableListener(lastSameOriginAncestor.window.document, "mouseout", (browserEvent) => {
        let e = new StandardMouseEvent(browserEvent);
        if (e.target.tagName.toLowerCase() === "html") {
          this.stopMonitoring(true);
        }
      }));
      this._hooks.add(addDisposableListener(lastSameOriginAncestor.window.document, "mouseover", (browserEvent) => {
        let e = new StandardMouseEvent(browserEvent);
        if (e.target.tagName.toLowerCase() === "html") {
          this.stopMonitoring(true);
        }
      }));
      this._hooks.add(addDisposableListener(lastSameOriginAncestor.window.document.body, "mouseleave", (browserEvent) => {
        this.stopMonitoring(true);
      }));
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarArrow.js
var ARROW_IMG_SIZE = 11;
var ScrollbarArrow = class extends Widget {
  constructor(opts) {
    super();
    this._onActivate = opts.onActivate;
    this.bgDomNode = document.createElement("div");
    this.bgDomNode.className = "arrow-background";
    this.bgDomNode.style.position = "absolute";
    this.bgDomNode.style.width = opts.bgWidth + "px";
    this.bgDomNode.style.height = opts.bgHeight + "px";
    if (typeof opts.top !== "undefined") {
      this.bgDomNode.style.top = "0px";
    }
    if (typeof opts.left !== "undefined") {
      this.bgDomNode.style.left = "0px";
    }
    if (typeof opts.bottom !== "undefined") {
      this.bgDomNode.style.bottom = "0px";
    }
    if (typeof opts.right !== "undefined") {
      this.bgDomNode.style.right = "0px";
    }
    this.domNode = document.createElement("div");
    this.domNode.className = opts.className;
    this.domNode.classList.add(...opts.icon.classNamesArray);
    this.domNode.style.position = "absolute";
    this.domNode.style.width = ARROW_IMG_SIZE + "px";
    this.domNode.style.height = ARROW_IMG_SIZE + "px";
    if (typeof opts.top !== "undefined") {
      this.domNode.style.top = opts.top + "px";
    }
    if (typeof opts.left !== "undefined") {
      this.domNode.style.left = opts.left + "px";
    }
    if (typeof opts.bottom !== "undefined") {
      this.domNode.style.bottom = opts.bottom + "px";
    }
    if (typeof opts.right !== "undefined") {
      this.domNode.style.right = opts.right + "px";
    }
    this._mouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());
    this.onmousedown(this.bgDomNode, (e) => this._arrowMouseDown(e));
    this.onmousedown(this.domNode, (e) => this._arrowMouseDown(e));
    this._mousedownRepeatTimer = this._register(new IntervalTimer());
    this._mousedownScheduleRepeatTimer = this._register(new TimeoutTimer());
  }
  _arrowMouseDown(e) {
    const scheduleRepeater = () => {
      this._mousedownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24);
    };
    this._onActivate();
    this._mousedownRepeatTimer.cancel();
    this._mousedownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);
    this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (mouseMoveData) => {
    }, () => {
      this._mousedownRepeatTimer.cancel();
      this._mousedownScheduleRepeatTimer.cancel();
    });
    e.preventDefault();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js
var ScrollbarVisibilityController = class extends Disposable {
  constructor(visibility, visibleClassName, invisibleClassName) {
    super();
    this._visibility = visibility;
    this._visibleClassName = visibleClassName;
    this._invisibleClassName = invisibleClassName;
    this._domNode = null;
    this._isVisible = false;
    this._isNeeded = false;
    this._rawShouldBeVisible = false;
    this._shouldBeVisible = false;
    this._revealTimer = this._register(new TimeoutTimer());
  }
  setVisibility(visibility) {
    if (this._visibility !== visibility) {
      this._visibility = visibility;
      this._updateShouldBeVisible();
    }
  }
  // ----------------- Hide / Reveal
  setShouldBeVisible(rawShouldBeVisible) {
    this._rawShouldBeVisible = rawShouldBeVisible;
    this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    if (this._visibility === 2) {
      return false;
    }
    if (this._visibility === 3) {
      return true;
    }
    return this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const shouldBeVisible = this._applyVisibilitySetting();
    if (this._shouldBeVisible !== shouldBeVisible) {
      this._shouldBeVisible = shouldBeVisible;
      this.ensureVisibility();
    }
  }
  setIsNeeded(isNeeded) {
    if (this._isNeeded !== isNeeded) {
      this._isNeeded = isNeeded;
      this.ensureVisibility();
    }
  }
  setDomNode(domNode) {
    this._domNode = domNode;
    this._domNode.setClassName(this._invisibleClassName);
    this.setShouldBeVisible(false);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(false);
      return;
    }
    if (this._shouldBeVisible) {
      this._reveal();
    } else {
      this._hide(true);
    }
  }
  _reveal() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._revealTimer.setIfNotSet(() => {
      if (this._domNode) {
        this._domNode.setClassName(this._visibleClassName);
      }
    }, 0);
  }
  _hide(withFadeAway) {
    this._revealTimer.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    if (this._domNode) {
      this._domNode.setClassName(this._invisibleClassName + (withFadeAway ? " fade" : ""));
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/abstractScrollbar.js
var MOUSE_DRAG_RESET_DISTANCE = 140;
var AbstractScrollbar = class extends Widget {
  constructor(opts) {
    super();
    this._lazyRender = opts.lazyRender;
    this._host = opts.host;
    this._scrollable = opts.scrollable;
    this._scrollByPage = opts.scrollByPage;
    this._scrollbarState = opts.scrollbarState;
    this._visibilityController = this._register(new ScrollbarVisibilityController(opts.visibility, "visible scrollbar " + opts.extraScrollbarClassName, "invisible scrollbar " + opts.extraScrollbarClassName));
    this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
    this._mouseMoveMonitor = this._register(new GlobalMouseMoveMonitor());
    this._shouldRender = true;
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setAttribute("role", "presentation");
    this.domNode.setAttribute("aria-hidden", "true");
    this._visibilityController.setDomNode(this.domNode);
    this.domNode.setPosition("absolute");
    this.onmousedown(this.domNode.domNode, (e) => this._domNodeMouseDown(e));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(opts) {
    const arrow = this._register(new ScrollbarArrow(opts));
    this.domNode.domNode.appendChild(arrow.bgDomNode);
    this.domNode.domNode.appendChild(arrow.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(top, left, width, height) {
    this.slider = createFastDomNode(document.createElement("div"));
    this.slider.setClassName("slider");
    this.slider.setPosition("absolute");
    this.slider.setTop(top);
    this.slider.setLeft(left);
    if (typeof width === "number") {
      this.slider.setWidth(width);
    }
    if (typeof height === "number") {
      this.slider.setHeight(height);
    }
    this.slider.setLayerHinting(true);
    this.slider.setContain("strict");
    this.domNode.domNode.appendChild(this.slider.domNode);
    this.onmousedown(this.slider.domNode, (e) => {
      if (e.leftButton) {
        e.preventDefault();
        this._sliderMouseDown(e, () => {
        });
      }
    });
    this.onclick(this.slider.domNode, (e) => {
      if (e.leftButton) {
        e.stopPropagation();
      }
    });
  }
  // ----------------- Update state
  _onElementSize(visibleSize) {
    if (this._scrollbarState.setVisibleSize(visibleSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  _onElementScrollSize(elementScrollSize) {
    if (this._scrollbarState.setScrollSize(elementScrollSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  _onElementScrollPosition(elementScrollPosition) {
    if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(true);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(false);
  }
  render() {
    if (!this._shouldRender) {
      return;
    }
    this._shouldRender = false;
    this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
    this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
  }
  // ----------------- DOM events
  _domNodeMouseDown(e) {
    if (e.target !== this.domNode.domNode) {
      return;
    }
    this._onMouseDown(e);
  }
  delegateMouseDown(e) {
    const domTop = this.domNode.domNode.getClientRects()[0].top;
    const sliderStart = domTop + this._scrollbarState.getSliderPosition();
    const sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
    const mousePos = this._sliderMousePosition(e);
    if (sliderStart <= mousePos && mousePos <= sliderStop) {
      if (e.leftButton) {
        e.preventDefault();
        this._sliderMouseDown(e, () => {
        });
      }
    } else {
      this._onMouseDown(e);
    }
  }
  _onMouseDown(e) {
    let offsetX;
    let offsetY;
    if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX === "number" && typeof e.browserEvent.offsetY === "number") {
      offsetX = e.browserEvent.offsetX;
      offsetY = e.browserEvent.offsetY;
    } else {
      const domNodePosition = getDomNodePagePosition(this.domNode.domNode);
      offsetX = e.posx - domNodePosition.left;
      offsetY = e.posy - domNodePosition.top;
    }
    const offset = this._mouseDownRelativePosition(offsetX, offsetY);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(offset) : this._scrollbarState.getDesiredScrollPositionFromOffset(offset));
    if (e.leftButton) {
      e.preventDefault();
      this._sliderMouseDown(e, () => {
      });
    }
  }
  _sliderMouseDown(e, onDragFinished) {
    const initialMousePosition = this._sliderMousePosition(e);
    const initialMouseOrthogonalPosition = this._sliderOrthogonalMousePosition(e);
    const initialScrollbarState = this._scrollbarState.clone();
    this.slider.toggleClassName("active", true);
    this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (mouseMoveData) => {
      const mouseOrthogonalPosition = this._sliderOrthogonalMousePosition(mouseMoveData);
      const mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition);
      if (isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
        this._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());
        return;
      }
      const mousePosition = this._sliderMousePosition(mouseMoveData);
      const mouseDelta = mousePosition - initialMousePosition;
      this._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(mouseDelta));
    }, () => {
      this.slider.toggleClassName("active", false);
      this._host.onDragEnd();
      onDragFinished();
    });
    this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(_desiredScrollPosition) {
    const desiredScrollPosition = {};
    this.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);
    this._scrollable.setScrollPositionNow(desiredScrollPosition);
  }
  updateScrollbarSize(scrollbarSize) {
    this._updateScrollbarSize(scrollbarSize);
    this._scrollbarState.setScrollbarSize(scrollbarSize);
    this._shouldRender = true;
    if (!this._lazyRender) {
      this.render();
    }
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js
var MINIMUM_SLIDER_SIZE = 20;
var ScrollbarState = class _ScrollbarState {
  constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {
    this._scrollbarSize = Math.round(scrollbarSize);
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
    this._arrowSize = Math.round(arrowSize);
    this._visibleSize = visibleSize;
    this._scrollSize = scrollSize;
    this._scrollPosition = scrollPosition;
    this._computedAvailableSize = 0;
    this._computedIsNeeded = false;
    this._computedSliderSize = 0;
    this._computedSliderRatio = 0;
    this._computedSliderPosition = 0;
    this._refreshComputedValues();
  }
  clone() {
    return new _ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(visibleSize) {
    const iVisibleSize = Math.round(visibleSize);
    if (this._visibleSize !== iVisibleSize) {
      this._visibleSize = iVisibleSize;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollSize(scrollSize) {
    const iScrollSize = Math.round(scrollSize);
    if (this._scrollSize !== iScrollSize) {
      this._scrollSize = iScrollSize;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollPosition(scrollPosition) {
    const iScrollPosition = Math.round(scrollPosition);
    if (this._scrollPosition !== iScrollPosition) {
      this._scrollPosition = iScrollPosition;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollbarSize(scrollbarSize) {
    this._scrollbarSize = Math.round(scrollbarSize);
  }
  setOppositeScrollbarSize(oppositeScrollbarSize) {
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
  }
  static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {
    const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
    const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
    const computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;
    if (!computedIsNeeded) {
      return {
        computedAvailableSize: Math.round(computedAvailableSize),
        computedIsNeeded,
        computedSliderSize: Math.round(computedRepresentableSize),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    }
    const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));
    const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);
    const computedSliderPosition = scrollPosition * computedSliderRatio;
    return {
      computedAvailableSize: Math.round(computedAvailableSize),
      computedIsNeeded,
      computedSliderSize: Math.round(computedSliderSize),
      computedSliderRatio,
      computedSliderPosition: Math.round(computedSliderPosition)
    };
  }
  _refreshComputedValues() {
    const r = _ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = r.computedAvailableSize;
    this._computedIsNeeded = r.computedIsNeeded;
    this._computedSliderSize = r.computedSliderSize;
    this._computedSliderRatio = r.computedSliderRatio;
    this._computedSliderPosition = r.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(offset) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(offset) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    const correctedOffset = offset - this._arrowSize;
    let desiredScrollPosition = this._scrollPosition;
    if (correctedOffset < this._computedSliderPosition) {
      desiredScrollPosition -= this._visibleSize;
    } else {
      desiredScrollPosition += this._visibleSize;
    }
    return desiredScrollPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(delta) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    const desiredSliderPosition = this._computedSliderPosition + delta;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/horizontalScrollbar.js
var HorizontalScrollbar = class extends AbstractScrollbar {
  constructor(scrollable, options, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options.lazyRender,
      host,
      scrollbarState: new ScrollbarState(options.horizontalHasArrows ? options.arrowSize : 0, options.horizontal === 2 ? 0 : options.horizontalScrollbarSize, options.vertical === 2 ? 0 : options.verticalScrollbarSize, scrollDimensions.width, scrollDimensions.scrollWidth, scrollPosition.scrollLeft),
      visibility: options.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable,
      scrollByPage: options.scrollByPage
    });
    if (options.horizontalHasArrows) {
      const arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;
      const scrollbarDelta = (options.horizontalScrollbarSize - ARROW_IMG_SIZE) / 2;
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonLeft,
        top: scrollbarDelta,
        left: arrowDelta,
        bottom: void 0,
        right: void 0,
        bgWidth: options.arrowSize,
        bgHeight: options.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 1, 0))
      });
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonRight,
        top: scrollbarDelta,
        left: void 0,
        bottom: void 0,
        right: arrowDelta,
        bgWidth: options.arrowSize,
        bgHeight: options.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, void 0, options.horizontalSliderSize);
  }
  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setWidth(sliderSize);
    this.slider.setLeft(sliderPosition);
  }
  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(largeSize);
    this.domNode.setHeight(smallSize);
    this.domNode.setLeft(0);
    this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
    return this._shouldRender;
  }
  _mouseDownRelativePosition(offsetX, offsetY) {
    return offsetX;
  }
  _sliderMousePosition(e) {
    return e.posx;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posy;
  }
  _updateScrollbarSize(size) {
    this.slider.setHeight(size);
  }
  writeScrollPosition(target, scrollPosition) {
    target.scrollLeft = scrollPosition;
  }
  updateOptions(options) {
    this.updateScrollbarSize(options.horizontal === 2 ? 0 : options.horizontalScrollbarSize);
    this._scrollbarState.setOppositeScrollbarSize(options.vertical === 2 ? 0 : options.verticalScrollbarSize);
    this._visibilityController.setVisibility(options.horizontal);
    this._scrollByPage = options.scrollByPage;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/verticalScrollbar.js
var VerticalScrollbar = class extends AbstractScrollbar {
  constructor(scrollable, options, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options.lazyRender,
      host,
      scrollbarState: new ScrollbarState(
        options.verticalHasArrows ? options.arrowSize : 0,
        options.vertical === 2 ? 0 : options.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        scrollDimensions.height,
        scrollDimensions.scrollHeight,
        scrollPosition.scrollTop
      ),
      visibility: options.vertical,
      extraScrollbarClassName: "vertical",
      scrollable,
      scrollByPage: options.scrollByPage
    });
    if (options.verticalHasArrows) {
      const arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;
      const scrollbarDelta = (options.verticalScrollbarSize - ARROW_IMG_SIZE) / 2;
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonUp,
        top: arrowDelta,
        left: scrollbarDelta,
        bottom: void 0,
        right: void 0,
        bgWidth: options.verticalScrollbarSize,
        bgHeight: options.arrowSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, 1))
      });
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonDown,
        top: void 0,
        left: scrollbarDelta,
        bottom: arrowDelta,
        right: void 0,
        bgWidth: options.verticalScrollbarSize,
        bgHeight: options.arrowSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, void 0);
  }
  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setHeight(sliderSize);
    this.slider.setTop(sliderPosition);
  }
  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(smallSize);
    this.domNode.setHeight(largeSize);
    this.domNode.setRight(0);
    this.domNode.setTop(0);
  }
  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
    return this._shouldRender;
  }
  _mouseDownRelativePosition(offsetX, offsetY) {
    return offsetY;
  }
  _sliderMousePosition(e) {
    return e.posy;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posx;
  }
  _updateScrollbarSize(size) {
    this.slider.setWidth(size);
  }
  writeScrollPosition(target, scrollPosition) {
    target.scrollTop = scrollPosition;
  }
  updateOptions(options) {
    this.updateScrollbarSize(options.vertical === 2 ? 0 : options.verticalScrollbarSize);
    this._scrollbarState.setOppositeScrollbarSize(0);
    this._visibilityController.setVisibility(options.vertical);
    this._scrollByPage = options.scrollByPage;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/scrollable.js
var ScrollState = class _ScrollState {
  constructor(_forceIntegerValues, width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
    this._forceIntegerValues = _forceIntegerValues;
    this._scrollStateBrand = void 0;
    if (this._forceIntegerValues) {
      width = width | 0;
      scrollWidth = scrollWidth | 0;
      scrollLeft = scrollLeft | 0;
      height = height | 0;
      scrollHeight = scrollHeight | 0;
      scrollTop = scrollTop | 0;
    }
    this.rawScrollLeft = scrollLeft;
    this.rawScrollTop = scrollTop;
    if (width < 0) {
      width = 0;
    }
    if (scrollLeft + width > scrollWidth) {
      scrollLeft = scrollWidth - width;
    }
    if (scrollLeft < 0) {
      scrollLeft = 0;
    }
    if (height < 0) {
      height = 0;
    }
    if (scrollTop + height > scrollHeight) {
      scrollTop = scrollHeight - height;
    }
    if (scrollTop < 0) {
      scrollTop = 0;
    }
    this.width = width;
    this.scrollWidth = scrollWidth;
    this.scrollLeft = scrollLeft;
    this.height = height;
    this.scrollHeight = scrollHeight;
    this.scrollTop = scrollTop;
  }
  equals(other) {
    return this.rawScrollLeft === other.rawScrollLeft && this.rawScrollTop === other.rawScrollTop && this.width === other.width && this.scrollWidth === other.scrollWidth && this.scrollLeft === other.scrollLeft && this.height === other.height && this.scrollHeight === other.scrollHeight && this.scrollTop === other.scrollTop;
  }
  withScrollDimensions(update, useRawScrollPositions) {
    return new _ScrollState(this._forceIntegerValues, typeof update.width !== "undefined" ? update.width : this.width, typeof update.scrollWidth !== "undefined" ? update.scrollWidth : this.scrollWidth, useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, typeof update.height !== "undefined" ? update.height : this.height, typeof update.scrollHeight !== "undefined" ? update.scrollHeight : this.scrollHeight, useRawScrollPositions ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(update) {
    return new _ScrollState(this._forceIntegerValues, this.width, this.scrollWidth, typeof update.scrollLeft !== "undefined" ? update.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof update.scrollTop !== "undefined" ? update.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(previous, inSmoothScrolling) {
    const widthChanged = this.width !== previous.width;
    const scrollWidthChanged = this.scrollWidth !== previous.scrollWidth;
    const scrollLeftChanged = this.scrollLeft !== previous.scrollLeft;
    const heightChanged = this.height !== previous.height;
    const scrollHeightChanged = this.scrollHeight !== previous.scrollHeight;
    const scrollTopChanged = this.scrollTop !== previous.scrollTop;
    return {
      inSmoothScrolling,
      oldWidth: previous.width,
      oldScrollWidth: previous.scrollWidth,
      oldScrollLeft: previous.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: previous.height,
      oldScrollHeight: previous.scrollHeight,
      oldScrollTop: previous.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged,
      scrollWidthChanged,
      scrollLeftChanged,
      heightChanged,
      scrollHeightChanged,
      scrollTopChanged
    };
  }
};
var Scrollable = class extends Disposable {
  constructor(options) {
    super();
    this._scrollableBrand = void 0;
    this._onScroll = this._register(new Emitter());
    this.onScroll = this._onScroll.event;
    this._smoothScrollDuration = options.smoothScrollDuration;
    this._scheduleAtNextAnimationFrame = options.scheduleAtNextAnimationFrame;
    this._state = new ScrollState(options.forceIntegerValues, 0, 0, 0, 0, 0, 0);
    this._smoothScrolling = null;
  }
  dispose() {
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
    }
    super.dispose();
  }
  setSmoothScrollDuration(smoothScrollDuration) {
    this._smoothScrollDuration = smoothScrollDuration;
  }
  validateScrollPosition(scrollPosition) {
    return this._state.withScrollPosition(scrollPosition);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(dimensions, useRawScrollPositions) {
    const newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);
    this._setState(newState, Boolean(this._smoothScrolling));
    if (this._smoothScrolling) {
      this._smoothScrolling.acceptScrollDimensions(this._state);
    }
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    if (this._smoothScrolling) {
      return this._smoothScrolling.to;
    }
    return this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(update) {
    const newState = this._state.withScrollPosition(update);
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
    }
    this._setState(newState, false);
  }
  setScrollPositionSmooth(update, reuseAnimation) {
    if (this._smoothScrollDuration === 0) {
      return this.setScrollPositionNow(update);
    }
    if (this._smoothScrolling) {
      update = {
        scrollLeft: typeof update.scrollLeft === "undefined" ? this._smoothScrolling.to.scrollLeft : update.scrollLeft,
        scrollTop: typeof update.scrollTop === "undefined" ? this._smoothScrolling.to.scrollTop : update.scrollTop
      };
      const validTarget = this._state.withScrollPosition(update);
      if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
        return;
      }
      let newSmoothScrolling;
      if (reuseAnimation) {
        newSmoothScrolling = new SmoothScrollingOperation(this._smoothScrolling.from, validTarget, this._smoothScrolling.startTime, this._smoothScrolling.duration);
      } else {
        newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
      }
      this._smoothScrolling.dispose();
      this._smoothScrolling = newSmoothScrolling;
    } else {
      const validTarget = this._state.withScrollPosition(update);
      this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }
      this._smoothScrolling.animationFrameDisposable = null;
      this._performSmoothScrolling();
    });
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling) {
      return;
    }
    const update = this._smoothScrolling.tick();
    const newState = this._state.withScrollPosition(update);
    this._setState(newState, true);
    if (!this._smoothScrolling) {
      return;
    }
    if (update.isDone) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
      return;
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }
      this._smoothScrolling.animationFrameDisposable = null;
      this._performSmoothScrolling();
    });
  }
  _setState(newState, inSmoothScrolling) {
    const oldState = this._state;
    if (oldState.equals(newState)) {
      return;
    }
    this._state = newState;
    this._onScroll.fire(this._state.createScrollEvent(oldState, inSmoothScrolling));
  }
};
var SmoothScrollingUpdate = class {
  constructor(scrollLeft, scrollTop, isDone) {
    this.scrollLeft = scrollLeft;
    this.scrollTop = scrollTop;
    this.isDone = isDone;
  }
};
function createEaseOutCubic(from, to) {
  const delta = to - from;
  return function(completion) {
    return from + delta * easeOutCubic(completion);
  };
}
function createComposed(a, b, cut) {
  return function(completion) {
    if (completion < cut) {
      return a(completion / cut);
    }
    return b((completion - cut) / (1 - cut));
  };
}
var SmoothScrollingOperation = class _SmoothScrollingOperation {
  constructor(from, to, startTime, duration) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    this.startTime = startTime;
    this.animationFrameDisposable = null;
    this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
    this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(from, to, viewportSize) {
    const delta = Math.abs(from - to);
    if (delta > 2.5 * viewportSize) {
      let stop1, stop2;
      if (from < to) {
        stop1 = from + 0.75 * viewportSize;
        stop2 = to - 0.75 * viewportSize;
      } else {
        stop1 = from - 0.75 * viewportSize;
        stop2 = to + 0.75 * viewportSize;
      }
      return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
    }
    return createEaseOutCubic(from, to);
  }
  dispose() {
    if (this.animationFrameDisposable !== null) {
      this.animationFrameDisposable.dispose();
      this.animationFrameDisposable = null;
    }
  }
  acceptScrollDimensions(state) {
    this.to = state.withScrollPosition(this.to);
    this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(now) {
    const completion = (now - this.startTime) / this.duration;
    if (completion < 1) {
      const newScrollLeft = this.scrollLeft(completion);
      const newScrollTop = this.scrollTop(completion);
      return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
    }
    return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
  }
  combine(from, to, duration) {
    return _SmoothScrollingOperation.start(from, to, duration);
  }
  static start(from, to, duration) {
    duration = duration + 10;
    const startTime = Date.now() - 10;
    return new _SmoothScrollingOperation(from, to, startTime, duration);
  }
};
function easeInCubic(t) {
  return Math.pow(t, 3);
}
function easeOutCubic(t) {
  return 1 - easeInCubic(1 - t);
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js
import "/home/ubuntu/project/s/front2.0/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/media/scrollbars.css";
var HIDE_TIMEOUT = 500;
var SCROLL_WHEEL_SENSITIVITY = 50;
var SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED = true;
var MouseWheelClassifierItem = class {
  constructor(timestamp, deltaX, deltaY) {
    this.timestamp = timestamp;
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    this.score = 0;
  }
};
var MouseWheelClassifier = class {
  constructor() {
    this._capacity = 5;
    this._memory = [];
    this._front = -1;
    this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1) {
      return false;
    }
    let remainingInfluence = 1;
    let score = 0;
    let iteration = 1;
    let index = this._rear;
    do {
      const influence = index === this._front ? remainingInfluence : Math.pow(2, -iteration);
      remainingInfluence -= influence;
      score += this._memory[index].score * influence;
      if (index === this._front) {
        break;
      }
      index = (this._capacity + index - 1) % this._capacity;
      iteration++;
    } while (true);
    return score <= 0.5;
  }
  accept(timestamp, deltaX, deltaY) {
    const item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);
    item.score = this._computeScore(item);
    if (this._front === -1 && this._rear === -1) {
      this._memory[0] = item;
      this._front = 0;
      this._rear = 0;
    } else {
      this._rear = (this._rear + 1) % this._capacity;
      if (this._rear === this._front) {
        this._front = (this._front + 1) % this._capacity;
      }
      this._memory[this._rear] = item;
    }
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(item) {
    if (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {
      return 1;
    }
    let score = 0.5;
    const prev = this._front === -1 && this._rear === -1 ? null : this._memory[this._rear];
    if (prev) {
    }
    if (!this._isAlmostInt(item.deltaX) || !this._isAlmostInt(item.deltaY)) {
      score += 0.25;
    }
    return Math.min(Math.max(score, 0), 1);
  }
  _isAlmostInt(value) {
    const delta = Math.abs(Math.round(value) - value);
    return delta < 0.01;
  }
};
MouseWheelClassifier.INSTANCE = new MouseWheelClassifier();
var AbstractScrollableElement = class extends Widget {
  constructor(element, options, scrollable) {
    super();
    this._onScroll = this._register(new Emitter());
    this.onScroll = this._onScroll.event;
    this._onWillScroll = this._register(new Emitter());
    element.style.overflow = "hidden";
    this._options = resolveOptions(options);
    this._scrollable = scrollable;
    this._register(this._scrollable.onScroll((e) => {
      this._onWillScroll.fire(e);
      this._onDidScroll(e);
      this._onScroll.fire(e);
    }));
    const scrollbarHost = {
      onMouseWheel: (mouseWheelEvent) => this._onMouseWheel(mouseWheelEvent),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new VerticalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._horizontalScrollbar = this._register(new HorizontalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._domNode = document.createElement("div");
    this._domNode.className = "monaco-scrollable-element " + this._options.className;
    this._domNode.setAttribute("role", "presentation");
    this._domNode.style.position = "relative";
    this._domNode.style.overflow = "hidden";
    this._domNode.appendChild(element);
    this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode);
    this._domNode.appendChild(this._verticalScrollbar.domNode.domNode);
    if (this._options.useShadows) {
      this._leftShadowDomNode = createFastDomNode(document.createElement("div"));
      this._leftShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._leftShadowDomNode.domNode);
      this._topShadowDomNode = createFastDomNode(document.createElement("div"));
      this._topShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._topShadowDomNode.domNode);
      this._topLeftShadowDomNode = createFastDomNode(document.createElement("div"));
      this._topLeftShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._topLeftShadowDomNode.domNode);
    } else {
      this._leftShadowDomNode = null;
      this._topShadowDomNode = null;
      this._topLeftShadowDomNode = null;
    }
    this._listenOnDomNode = this._options.listenOnDomNode || this._domNode;
    this._mouseWheelToDispose = [];
    this._setListeningToMouseWheel(this._options.handleMouseWheel);
    this.onmouseover(this._listenOnDomNode, (e) => this._onMouseOver(e));
    this.onnonbubblingmouseout(this._listenOnDomNode, (e) => this._onMouseOut(e));
    this._hideTimeout = this._register(new TimeoutTimer());
    this._isDragging = false;
    this._mouseIsOver = false;
    this._shouldRender = true;
    this._revealOnScroll = true;
  }
  get options() {
    return this._options;
  }
  dispose() {
    this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
    super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a mouse down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarMouseDown(browserEvent) {
    this._verticalScrollbar.delegateMouseDown(browserEvent);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(dimensions) {
    this._scrollable.setScrollDimensions(dimensions, false);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(newClassName) {
    this._options.className = newClassName;
    if (isMacintosh) {
      this._options.className += " mac";
    }
    this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */
  updateOptions(newOptions) {
    if (typeof newOptions.handleMouseWheel !== "undefined") {
      this._options.handleMouseWheel = newOptions.handleMouseWheel;
      this._setListeningToMouseWheel(this._options.handleMouseWheel);
    }
    if (typeof newOptions.mouseWheelScrollSensitivity !== "undefined") {
      this._options.mouseWheelScrollSensitivity = newOptions.mouseWheelScrollSensitivity;
    }
    if (typeof newOptions.fastScrollSensitivity !== "undefined") {
      this._options.fastScrollSensitivity = newOptions.fastScrollSensitivity;
    }
    if (typeof newOptions.scrollPredominantAxis !== "undefined") {
      this._options.scrollPredominantAxis = newOptions.scrollPredominantAxis;
    }
    if (typeof newOptions.horizontal !== "undefined") {
      this._options.horizontal = newOptions.horizontal;
    }
    if (typeof newOptions.vertical !== "undefined") {
      this._options.vertical = newOptions.vertical;
    }
    if (typeof newOptions.horizontalScrollbarSize !== "undefined") {
      this._options.horizontalScrollbarSize = newOptions.horizontalScrollbarSize;
    }
    if (typeof newOptions.verticalScrollbarSize !== "undefined") {
      this._options.verticalScrollbarSize = newOptions.verticalScrollbarSize;
    }
    if (typeof newOptions.scrollByPage !== "undefined") {
      this._options.scrollByPage = newOptions.scrollByPage;
    }
    this._horizontalScrollbar.updateOptions(this._options);
    this._verticalScrollbar.updateOptions(this._options);
    if (!this._options.lazyRender) {
      this._render();
    }
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(shouldListen) {
    const isListening = this._mouseWheelToDispose.length > 0;
    if (isListening === shouldListen) {
      return;
    }
    this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
    if (shouldListen) {
      const onMouseWheel = (browserEvent) => {
        this._onMouseWheel(new StandardWheelEvent(browserEvent));
      };
      this._mouseWheelToDispose.push(addDisposableListener(this._listenOnDomNode, EventType.MOUSE_WHEEL, onMouseWheel, { passive: false }));
    }
  }
  _onMouseWheel(e) {
    const classifier = MouseWheelClassifier.INSTANCE;
    if (SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED) {
      const osZoomFactor = window.devicePixelRatio / getZoomFactor();
      if (isWindows || isLinux) {
        classifier.accept(Date.now(), e.deltaX / osZoomFactor, e.deltaY / osZoomFactor);
      } else {
        classifier.accept(Date.now(), e.deltaX, e.deltaY);
      }
    }
    let didScroll = false;
    if (e.deltaY || e.deltaX) {
      let deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
      let deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;
      if (this._options.scrollPredominantAxis) {
        if (Math.abs(deltaY) >= Math.abs(deltaX)) {
          deltaX = 0;
        } else {
          deltaY = 0;
        }
      }
      if (this._options.flipAxes) {
        [deltaY, deltaX] = [deltaX, deltaY];
      }
      const shiftConvert = !isMacintosh && e.browserEvent && e.browserEvent.shiftKey;
      if ((this._options.scrollYToX || shiftConvert) && !deltaX) {
        deltaX = deltaY;
        deltaY = 0;
      }
      if (e.browserEvent && e.browserEvent.altKey) {
        deltaX = deltaX * this._options.fastScrollSensitivity;
        deltaY = deltaY * this._options.fastScrollSensitivity;
      }
      const futureScrollPosition = this._scrollable.getFutureScrollPosition();
      let desiredScrollPosition = {};
      if (deltaY) {
        const deltaScrollTop = SCROLL_WHEEL_SENSITIVITY * deltaY;
        const desiredScrollTop = futureScrollPosition.scrollTop - (deltaScrollTop < 0 ? Math.floor(deltaScrollTop) : Math.ceil(deltaScrollTop));
        this._verticalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollTop);
      }
      if (deltaX) {
        const deltaScrollLeft = SCROLL_WHEEL_SENSITIVITY * deltaX;
        const desiredScrollLeft = futureScrollPosition.scrollLeft - (deltaScrollLeft < 0 ? Math.floor(deltaScrollLeft) : Math.ceil(deltaScrollLeft));
        this._horizontalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollLeft);
      }
      desiredScrollPosition = this._scrollable.validateScrollPosition(desiredScrollPosition);
      if (futureScrollPosition.scrollLeft !== desiredScrollPosition.scrollLeft || futureScrollPosition.scrollTop !== desiredScrollPosition.scrollTop) {
        const canPerformSmoothScroll = SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED && this._options.mouseWheelSmoothScroll && classifier.isPhysicalMouseWheel();
        if (canPerformSmoothScroll) {
          this._scrollable.setScrollPositionSmooth(desiredScrollPosition);
        } else {
          this._scrollable.setScrollPositionNow(desiredScrollPosition);
        }
        didScroll = true;
      }
    }
    let consumeMouseWheel = didScroll;
    if (!consumeMouseWheel && this._options.alwaysConsumeMouseWheel) {
      consumeMouseWheel = true;
    }
    if (!consumeMouseWheel && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded())) {
      consumeMouseWheel = true;
    }
    if (consumeMouseWheel) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
    this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;
    if (this._options.useShadows) {
      this._shouldRender = true;
    }
    if (this._revealOnScroll) {
      this._reveal();
    }
    if (!this._options.lazyRender) {
      this._render();
    }
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender) {
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    }
    this._render();
  }
  _render() {
    if (!this._shouldRender) {
      return;
    }
    this._shouldRender = false;
    this._horizontalScrollbar.render();
    this._verticalScrollbar.render();
    if (this._options.useShadows) {
      const scrollState = this._scrollable.getCurrentScrollPosition();
      const enableTop = scrollState.scrollTop > 0;
      const enableLeft = scrollState.scrollLeft > 0;
      const leftClassName = enableLeft ? " left" : "";
      const topClassName = enableTop ? " top" : "";
      const topLeftClassName = enableLeft || enableTop ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${leftClassName}`);
      this._topShadowDomNode.setClassName(`shadow${topClassName}`);
      this._topLeftShadowDomNode.setClassName(`shadow${topLeftClassName}${topClassName}${leftClassName}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = true;
    this._reveal();
  }
  _onDragEnd() {
    this._isDragging = false;
    this._hide();
  }
  _onMouseOut(e) {
    this._mouseIsOver = false;
    this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = true;
    this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal();
    this._horizontalScrollbar.beginReveal();
    this._scheduleHide();
  }
  _hide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._verticalScrollbar.beginHide();
      this._horizontalScrollbar.beginHide();
    }
  }
  _scheduleHide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._hideTimeout.cancelAndSet(() => this._hide(), HIDE_TIMEOUT);
    }
  }
};
var ScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options) {
    options = options || {};
    options.mouseWheelSmoothScroll = false;
    const scrollable = new Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (callback) => scheduleAtNextAnimationFrame(callback)
    });
    super(element, options, scrollable);
    this._register(scrollable);
  }
  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }
};
var SmoothScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options, scrollable) {
    super(element, options, scrollable);
  }
  setScrollPosition(update) {
    if (update.reuseAnimation) {
      this._scrollable.setScrollPositionSmooth(update, update.reuseAnimation);
    } else {
      this._scrollable.setScrollPositionNow(update);
    }
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
};
var DomScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options) {
    options = options || {};
    options.mouseWheelSmoothScroll = false;
    const scrollable = new Scrollable({
      forceIntegerValues: false,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (callback) => scheduleAtNextAnimationFrame(callback)
    });
    super(element, options, scrollable);
    this._register(scrollable);
    this._element = element;
    this.onScroll((e) => {
      if (e.scrollTopChanged) {
        this._element.scrollTop = e.scrollTop;
      }
      if (e.scrollLeftChanged) {
        this._element.scrollLeft = e.scrollLeft;
      }
    });
    this.scanDomNode();
  }
  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    });
    this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
};
function resolveOptions(opts) {
  const result = {
    lazyRender: typeof opts.lazyRender !== "undefined" ? opts.lazyRender : false,
    className: typeof opts.className !== "undefined" ? opts.className : "",
    useShadows: typeof opts.useShadows !== "undefined" ? opts.useShadows : true,
    handleMouseWheel: typeof opts.handleMouseWheel !== "undefined" ? opts.handleMouseWheel : true,
    flipAxes: typeof opts.flipAxes !== "undefined" ? opts.flipAxes : false,
    consumeMouseWheelIfScrollbarIsNeeded: typeof opts.consumeMouseWheelIfScrollbarIsNeeded !== "undefined" ? opts.consumeMouseWheelIfScrollbarIsNeeded : false,
    alwaysConsumeMouseWheel: typeof opts.alwaysConsumeMouseWheel !== "undefined" ? opts.alwaysConsumeMouseWheel : false,
    scrollYToX: typeof opts.scrollYToX !== "undefined" ? opts.scrollYToX : false,
    mouseWheelScrollSensitivity: typeof opts.mouseWheelScrollSensitivity !== "undefined" ? opts.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof opts.fastScrollSensitivity !== "undefined" ? opts.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof opts.scrollPredominantAxis !== "undefined" ? opts.scrollPredominantAxis : true,
    mouseWheelSmoothScroll: typeof opts.mouseWheelSmoothScroll !== "undefined" ? opts.mouseWheelSmoothScroll : true,
    arrowSize: typeof opts.arrowSize !== "undefined" ? opts.arrowSize : 11,
    listenOnDomNode: typeof opts.listenOnDomNode !== "undefined" ? opts.listenOnDomNode : null,
    horizontal: typeof opts.horizontal !== "undefined" ? opts.horizontal : 1,
    horizontalScrollbarSize: typeof opts.horizontalScrollbarSize !== "undefined" ? opts.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof opts.horizontalSliderSize !== "undefined" ? opts.horizontalSliderSize : 0,
    horizontalHasArrows: typeof opts.horizontalHasArrows !== "undefined" ? opts.horizontalHasArrows : false,
    vertical: typeof opts.vertical !== "undefined" ? opts.vertical : 1,
    verticalScrollbarSize: typeof opts.verticalScrollbarSize !== "undefined" ? opts.verticalScrollbarSize : 10,
    verticalHasArrows: typeof opts.verticalHasArrows !== "undefined" ? opts.verticalHasArrows : false,
    verticalSliderSize: typeof opts.verticalSliderSize !== "undefined" ? opts.verticalSliderSize : 0,
    scrollByPage: typeof opts.scrollByPage !== "undefined" ? opts.scrollByPage : false
  };
  result.horizontalSliderSize = typeof opts.horizontalSliderSize !== "undefined" ? opts.horizontalSliderSize : result.horizontalScrollbarSize;
  result.verticalSliderSize = typeof opts.verticalSliderSize !== "undefined" ? opts.verticalSliderSize : result.verticalScrollbarSize;
  if (isMacintosh) {
    result.className += " mac";
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/base/common/navigator.js
var ArrayNavigator = class {
  constructor(items, start = 0, end = items.length, index = start - 1) {
    this.items = items;
    this.start = start;
    this.end = end;
    this.index = index;
  }
  current() {
    if (this.index === this.start - 1 || this.index === this.end) {
      return null;
    }
    return this.items[this.index];
  }
  next() {
    this.index = Math.min(this.index + 1, this.end);
    return this.current();
  }
  previous() {
    this.index = Math.max(this.index - 1, this.start - 1);
    return this.current();
  }
  first() {
    this.index = this.start;
    return this.current();
  }
  last() {
    this.index = this.end - 1;
    return this.current();
  }
};

// node_modules/monaco-editor/esm/vs/base/common/history.js
var HistoryNavigator = class {
  constructor(history = [], limit = 10) {
    this._initialize(history);
    this._limit = limit;
    this._onChange();
  }
  getHistory() {
    return this._elements;
  }
  add(t) {
    this._history.delete(t);
    this._history.add(t);
    this._onChange();
  }
  next() {
    if (this._currentPosition() !== this._elements.length - 1) {
      return this._navigator.next();
    }
    return null;
  }
  previous() {
    if (this._currentPosition() !== 0) {
      return this._navigator.previous();
    }
    return null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  has(t) {
    return this._history.has(t);
  }
  _onChange() {
    this._reduceToLimit();
    const elements = this._elements;
    this._navigator = new ArrayNavigator(elements, 0, elements.length, elements.length);
  }
  _reduceToLimit() {
    const data = this._elements;
    if (data.length > this._limit) {
      this._initialize(data.slice(data.length - this._limit));
    }
  }
  _currentPosition() {
    const currentElement = this._navigator.current();
    if (!currentElement) {
      return -1;
    }
    return this._elements.indexOf(currentElement);
  }
  _initialize(history) {
    this._history = /* @__PURE__ */ new Set();
    for (const entry of history) {
      this._history.add(entry);
    }
  }
  get _elements() {
    const elements = [];
    this._history.forEach((e) => elements.push(e));
    return elements;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js
import "/home/ubuntu/project/s/front2.0/node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.css";
var $2 = $;
var defaultOpts = {
  inputBackground: Color.fromHex("#3C3C3C"),
  inputForeground: Color.fromHex("#CCCCCC"),
  inputValidationInfoBorder: Color.fromHex("#55AAFF"),
  inputValidationInfoBackground: Color.fromHex("#063B49"),
  inputValidationWarningBorder: Color.fromHex("#B89500"),
  inputValidationWarningBackground: Color.fromHex("#352A05"),
  inputValidationErrorBorder: Color.fromHex("#BE1100"),
  inputValidationErrorBackground: Color.fromHex("#5A1D1D")
};
var InputBox = class extends Widget {
  constructor(container, contextViewProvider, options) {
    var _a3;
    super();
    this.state = "idle";
    this.maxHeight = Number.POSITIVE_INFINITY;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidHeightChange = this._register(new Emitter());
    this.onDidHeightChange = this._onDidHeightChange.event;
    this.contextViewProvider = contextViewProvider;
    this.options = options || /* @__PURE__ */ Object.create(null);
    mixin(this.options, defaultOpts, false);
    this.message = null;
    this.placeholder = this.options.placeholder || "";
    this.tooltip = (_a3 = this.options.tooltip) !== null && _a3 !== void 0 ? _a3 : this.placeholder || "";
    this.ariaLabel = this.options.ariaLabel || "";
    this.inputBackground = this.options.inputBackground;
    this.inputForeground = this.options.inputForeground;
    this.inputBorder = this.options.inputBorder;
    this.inputValidationInfoBorder = this.options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = this.options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = this.options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = this.options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = this.options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = this.options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = this.options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = this.options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = this.options.inputValidationErrorForeground;
    if (this.options.validationOptions) {
      this.validation = this.options.validationOptions.validation;
    }
    this.element = append(container, $2(".monaco-inputbox.idle"));
    let tagName = this.options.flexibleHeight ? "textarea" : "input";
    let wrapper = append(this.element, $2(".ibwrapper"));
    this.input = append(wrapper, $2(tagName + ".input.empty"));
    this.input.setAttribute("autocorrect", "off");
    this.input.setAttribute("autocapitalize", "off");
    this.input.setAttribute("spellcheck", "false");
    this.onfocus(this.input, () => this.element.classList.add("synthetic-focus"));
    this.onblur(this.input, () => this.element.classList.remove("synthetic-focus"));
    if (this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight === "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY;
      this.mirror = append(wrapper, $2("div.mirror"));
      this.mirror.innerText = "";
      this.scrollableElement = new ScrollableElement(this.element, {
        vertical: 1
        /* Auto */
      });
      if (this.options.flexibleWidth) {
        this.input.setAttribute("wrap", "off");
        this.mirror.style.whiteSpace = "pre";
        this.mirror.style.wordWrap = "initial";
      }
      append(container, this.scrollableElement.getDomNode());
      this._register(this.scrollableElement);
      this._register(this.scrollableElement.onScroll((e) => this.input.scrollTop = e.scrollTop));
      const onSelectionChange = this._register(new DomEmitter(document, "selectionchange"));
      const onAnchoredSelectionChange = Event.filter(onSelectionChange.event, () => {
        const selection = document.getSelection();
        return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === wrapper;
      });
      this._register(onAnchoredSelectionChange(this.updateScrollDimensions, this));
      this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else {
      this.input.type = this.options.type || "text";
      this.input.setAttribute("wrap", "off");
    }
    if (this.ariaLabel) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    }
    if (this.placeholder && !this.options.showPlaceholderOnFocus) {
      this.setPlaceHolder(this.placeholder);
    }
    if (this.tooltip) {
      this.setTooltip(this.tooltip);
    }
    this.oninput(this.input, () => this.onValueChange());
    this.onblur(this.input, () => this.onBlur());
    this.onfocus(this.input, () => this.onFocus());
    this.ignoreGesture(this.input);
    setTimeout(() => this.updateMirror(), 0);
    if (this.options.actions) {
      this.actionbar = this._register(new ActionBar(this.element));
      this.actionbar.push(this.options.actions, { icon: true, label: false });
    }
    this.applyStyles();
  }
  onBlur() {
    this._hideMessage();
    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute("placeholder", "");
    }
  }
  onFocus() {
    this._showMessage();
    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute("placeholder", this.placeholder || "");
    }
  }
  setPlaceHolder(placeHolder) {
    this.placeholder = placeHolder;
    this.input.setAttribute("placeholder", placeHolder);
  }
  setTooltip(tooltip) {
    this.tooltip = tooltip;
    this.input.title = tooltip;
  }
  setAriaLabel(label) {
    this.ariaLabel = label;
    if (label) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    } else {
      this.input.removeAttribute("aria-label");
    }
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(newValue) {
    if (this.input.value !== newValue) {
      this.input.value = newValue;
      this.onValueChange();
    }
  }
  get height() {
    return typeof this.cachedHeight === "number" ? this.cachedHeight : getTotalHeight(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return document.activeElement === this.input;
  }
  select(range2 = null) {
    this.input.select();
    if (range2) {
      this.input.setSelectionRange(range2.start, range2.end);
      if (range2.end === this.input.value.length) {
        this.input.scrollLeft = this.input.scrollWidth;
      }
    }
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur();
    this.input.disabled = true;
    this._hideMessage();
  }
  get width() {
    return getTotalWidth(this.input);
  }
  set width(width) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      let horizontalPadding = 0;
      if (this.mirror) {
        const paddingLeft = parseFloat(this.mirror.style.paddingLeft || "") || 0;
        const paddingRight = parseFloat(this.mirror.style.paddingRight || "") || 0;
        horizontalPadding = paddingLeft + paddingRight;
      }
      this.input.style.width = width - horizontalPadding + "px";
    } else {
      this.input.style.width = width + "px";
    }
    if (this.mirror) {
      this.mirror.style.width = width + "px";
    }
  }
  set paddingRight(paddingRight) {
    this.input.style.width = `calc(100% - ${paddingRight}px)`;
    if (this.mirror) {
      this.mirror.style.paddingRight = paddingRight + "px";
    }
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight !== "number" || typeof this.cachedHeight !== "number" || !this.scrollableElement) {
      return;
    }
    const scrollHeight = this.cachedContentHeight;
    const height = this.cachedHeight;
    const scrollTop = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight, height });
    this.scrollableElement.setScrollPosition({ scrollTop });
  }
  showMessage(message, force) {
    this.message = message;
    this.element.classList.remove("idle");
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add(this.classForType(message.type));
    const styles = this.stylesForType(this.message.type);
    this.element.style.border = styles.border ? `1px solid ${styles.border}` : "";
    if (this.hasFocus() || force) {
      this._showMessage();
    }
  }
  hideMessage() {
    this.message = null;
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add("idle");
    this._hideMessage();
    this.applyStyles();
  }
  validate() {
    let errorMsg = null;
    if (this.validation) {
      errorMsg = this.validation(this.value);
      if (errorMsg) {
        this.inputElement.setAttribute("aria-invalid", "true");
        this.showMessage(errorMsg);
      } else if (this.inputElement.hasAttribute("aria-invalid")) {
        this.inputElement.removeAttribute("aria-invalid");
        this.hideMessage();
      }
    }
    return errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.type;
  }
  stylesForType(type) {
    switch (type) {
      case 1:
        return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };
      case 2:
        return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };
      default:
        return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };
    }
  }
  classForType(type) {
    switch (type) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message) {
      return;
    }
    let div;
    let layout = () => div.style.width = getTotalWidth(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (container) => {
        if (!this.message) {
          return null;
        }
        div = append(container, $2(".monaco-inputbox-container"));
        layout();
        const renderOptions = {
          inline: true,
          className: "monaco-inputbox-message"
        };
        const spanElement = this.message.formatContent ? renderFormattedText(this.message.content, renderOptions) : renderText(this.message.content, renderOptions);
        spanElement.classList.add(this.classForType(this.message.type));
        const styles = this.stylesForType(this.message.type);
        spanElement.style.backgroundColor = styles.background ? styles.background.toString() : "";
        spanElement.style.color = styles.foreground ? styles.foreground.toString() : "";
        spanElement.style.border = styles.border ? `1px solid ${styles.border}` : "";
        append(div, spanElement);
        return null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout
    });
    let alertText;
    if (this.message.type === 3) {
      alertText = localize("alertErrorMessage", "Error: {0}", this.message.content);
    } else if (this.message.type === 2) {
      alertText = localize("alertWarningMessage", "Warning: {0}", this.message.content);
    } else {
      alertText = localize("alertInfoMessage", "Info: {0}", this.message.content);
    }
    alert(alertText);
    this.state = "open";
  }
  _hideMessage() {
    if (!this.contextViewProvider) {
      return;
    }
    if (this.state === "open") {
      this.contextViewProvider.hideContextView();
    }
    this.state = "idle";
  }
  onValueChange() {
    this._onDidChange.fire(this.value);
    this.validate();
    this.updateMirror();
    this.input.classList.toggle("empty", !this.value);
    if (this.state === "open" && this.contextViewProvider) {
      this.contextViewProvider.layout();
    }
  }
  updateMirror() {
    if (!this.mirror) {
      return;
    }
    const value = this.value;
    const lastCharCode = value.charCodeAt(value.length - 1);
    const suffix = lastCharCode === 10 ? " " : "";
    const mirrorTextContent = (value + suffix).replace(/\u000c/g, "");
    if (mirrorTextContent) {
      this.mirror.textContent = value + suffix;
    } else {
      this.mirror.innerText = "";
    }
    this.layout();
  }
  style(styles) {
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    const background = this.inputBackground ? this.inputBackground.toString() : "";
    const foreground2 = this.inputForeground ? this.inputForeground.toString() : "";
    const border = this.inputBorder ? this.inputBorder.toString() : "";
    this.element.style.backgroundColor = background;
    this.element.style.color = foreground2;
    this.input.style.backgroundColor = "inherit";
    this.input.style.color = foreground2;
    this.element.style.borderWidth = border ? "1px" : "";
    this.element.style.borderStyle = border ? "solid" : "";
    this.element.style.borderColor = border;
  }
  layout() {
    if (!this.mirror) {
      return;
    }
    const previousHeight = this.cachedContentHeight;
    this.cachedContentHeight = getTotalHeight(this.mirror);
    if (previousHeight !== this.cachedContentHeight) {
      this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight);
      this.input.style.height = this.cachedHeight + "px";
      this._onDidHeightChange.fire(this.cachedContentHeight);
    }
  }
  insertAtCursor(text) {
    const inputElement = this.inputElement;
    const start = inputElement.selectionStart;
    const end = inputElement.selectionEnd;
    const content = inputElement.value;
    if (start !== null && end !== null) {
      this.value = content.substr(0, start) + text + content.substr(end);
      inputElement.setSelectionRange(start + 1, start + 1);
      this.layout();
    }
  }
  dispose() {
    this._hideMessage();
    this.message = null;
    if (this.actionbar) {
      this.actionbar.dispose();
    }
    super.dispose();
  }
};
var HistoryInputBox = class extends InputBox {
  constructor(container, contextViewProvider, options) {
    const NLS_PLACEHOLDER_HISTORY_HINT = localize({ key: "history.inputbox.hint", comment: ["Text will be prefixed with  plus a single space, then used as a hint where input field keeps history"] }, "for history");
    const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX = ` or  ${NLS_PLACEHOLDER_HISTORY_HINT}`;
    const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS = ` ( ${NLS_PLACEHOLDER_HISTORY_HINT})`;
    super(container, contextViewProvider, options);
    this.history = new HistoryNavigator(options.history, 100);
    const addSuffix = () => {
      if (options.showHistoryHint && options.showHistoryHint() && !this.placeholder.endsWith(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX) && !this.placeholder.endsWith(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS) && this.history.getHistory().length) {
        const suffix = this.placeholder.endsWith(")") ? NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX : NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS;
        const suffixedPlaceholder = this.placeholder + suffix;
        if (options.showPlaceholderOnFocus && document.activeElement !== this.input) {
          this.placeholder = suffixedPlaceholder;
        } else {
          this.setPlaceHolder(suffixedPlaceholder);
        }
      }
    };
    this.observer = new MutationObserver((mutationList, observer) => {
      mutationList.forEach((mutation) => {
        if (!mutation.target.textContent) {
          addSuffix();
        }
      });
    });
    this.observer.observe(this.input, { attributeFilter: ["class"] });
    this.onfocus(this.input, () => addSuffix());
    this.onblur(this.input, () => {
      const resetPlaceholder = (historyHint) => {
        if (!this.placeholder.endsWith(historyHint)) {
          return false;
        } else {
          const revertedPlaceholder = this.placeholder.slice(0, this.placeholder.length - historyHint.length);
          if (options.showPlaceholderOnFocus) {
            this.placeholder = revertedPlaceholder;
          } else {
            this.setPlaceHolder(revertedPlaceholder);
          }
          return true;
        }
      };
      if (!resetPlaceholder(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS)) {
        resetPlaceholder(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX);
      }
    });
  }
  dispose() {
    super.dispose();
    if (this.observer) {
      this.observer.disconnect();
      this.observer = void 0;
    }
  }
  addToHistory() {
    if (this.value && this.value !== this.getCurrentValue()) {
      this.history.add(this.value);
    }
  }
  showNextValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }
    let next = this.getNextValue();
    if (next) {
      next = next === this.value ? this.getNextValue() : next;
    }
    if (next) {
      this.value = next;
      status(this.value);
    }
  }
  showPreviousValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }
    let previous = this.getPreviousValue();
    if (previous) {
      previous = previous === this.value ? this.getPreviousValue() : previous;
    }
    if (previous) {
      this.value = previous;
      status(this.value);
    }
  }
  getCurrentValue() {
    let currentValue = this.history.current();
    if (!currentValue) {
      currentValue = this.history.last();
      this.history.next();
    }
    return currentValue;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next() || this.history.last();
  }
};

export {
  localize,
  globals,
  isWindows,
  isMacintosh,
  isLinux,
  isNative,
  isWeb,
  isIOS,
  OS,
  isLittleEndian,
  USUAL_WORD_SEPARATORS,
  DEFAULT_WORD_REGEXP,
  ensureValidWordDefinition,
  getWordAtText,
  tail2,
  equals,
  binarySearch,
  findFirstInSorted,
  coalesce,
  isFalsyOrEmpty,
  isNonEmptyArray,
  distinct,
  firstOrDefault,
  flatten,
  range,
  arrayInsert,
  pushToStart,
  pushToEnd,
  splice,
  compareBy,
  findLastMaxBy,
  findMinBy,
  ArrayQueue,
  isString,
  isObject,
  isNumber,
  isIterable,
  isBoolean,
  isUndefined,
  isDefined,
  isUndefinedOrNull,
  assertType,
  isFunction,
  getAllMethodNames,
  createProxyObject,
  withNullAsUndefined,
  assertNever,
  deepClone,
  deepFreeze,
  mixin,
  equals2,
  getOrDefault,
  EDITOR_MODEL_DEFAULTS,
  onUnexpectedError,
  onUnexpectedExternalError,
  transformErrorForSerialization,
  isCancellationError,
  canceled,
  illegalArgument,
  illegalState,
  once,
  Iterable,
  markAsSingleton,
  isDisposable,
  dispose,
  combinedDisposable,
  toDisposable,
  DisposableStore,
  Disposable,
  MutableDisposable,
  ImmortalReference,
  LinkedList,
  StopWatch,
  Event,
  Emitter,
  PauseableEmitter,
  DebounceEmitter,
  EventBufferer,
  Relay,
  CancellationToken,
  CancellationTokenSource,
  IMMUTABLE_CODE_TO_KEY_CODE,
  KeyCodeUtils,
  KeyChord,
  posix,
  normalize,
  basename,
  extname,
  sep,
  URI,
  Position,
  Range,
  Selection,
  getCodiconAriaLabel,
  Codicon,
  CSSIcon,
  TokenMetadata,
  Token,
  TokenizationResult,
  EncodedTokenizationResult,
  FoldingRangeKind,
  TokenizationRegistry2 as TokenizationRegistry,
  format,
  escape,
  escapeRegExpCharacters,
  ltrim,
  rtrim,
  convertSimple2RegExpPattern,
  regExpLeadsToEndlessLoop,
  regExpFlags,
  splitLines,
  firstNonWhitespaceIndex,
  getLeadingWhitespace,
  lastNonWhitespaceIndex,
  compare,
  compareSubstring,
  compareIgnoreCase,
  compareSubstringIgnoreCase,
  isLowerAsciiLetter,
  isUpperAsciiLetter,
  equalsIgnoreCase,
  startsWithIgnoreCase,
  commonPrefixLength,
  commonSuffixLength,
  isHighSurrogate,
  isLowSurrogate,
  computeCodePoint,
  nextCharLength,
  prevCharLength,
  getCharContainingOffset,
  containsRTL,
  isBasicASCII,
  isFullWidthCharacter,
  isEmojiImprecise,
  startsWithUTF8BOM,
  containsUppercaseCharacter,
  singleLetterHash,
  getLeftDeleteOffset,
  AmbiguousCharacters,
  InvisibleCharacters,
  PixelRatio,
  isFirefox2 as isFirefox,
  isWebKit,
  isSafari2 as isSafari,
  isWebkitWebView,
  isAndroid2 as isAndroid,
  browser_exports,
  FastDomNode,
  createFastDomNode,
  _util,
  IInstantiationService,
  createDecorator,
  ICodeEditorService,
  ok,
  OverviewRulerLane,
  MinimapPosition,
  InjectedTextCursorStops,
  TextModelResolvedOptions,
  FindMatch,
  shouldSynchronizeModel,
  IndentAction,
  createScopedLineTokens,
  VSBuffer,
  createStringBuilder,
  IConfigurationService,
  toValuesTree,
  addToValueTree,
  removeFromValueTree,
  getConfigurationValue,
  ILanguageService,
  SyncDescriptor,
  registerSingleton,
  getSingletonServiceDescriptors,
  ILanguageConfigurationService,
  LanguageConfigurationRegistry,
  NullState,
  nullTokenize,
  IModelService,
  isThenable,
  createCancelablePromise,
  MicrotaskDelay,
  Delayer,
  timeout,
  disposableTimeout,
  TimeoutTimer,
  IntervalTimer,
  RunOnceScheduler,
  IdleValue,
  DeferredPromise,
  Promises,
  toUint8,
  toUint32,
  CharacterClassifier,
  getMapForWordSeparators,
  SearchParams,
  Searcher,
  ILogService,
  LogLevel,
  ConsoleLogger,
  LogService,
  LineTokens,
  BrowserFeatures,
  createKeybinding,
  SimpleKeybinding,
  ChordKeybinding,
  ResolvedKeybindingPart,
  ResolvedKeybinding,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StandardWheelEvent,
  Schemas,
  clearNode,
  isInDOM,
  addDisposableListener,
  addStandardDisposableListener,
  addDisposableNonBubblingMouseOutListener,
  addDisposableNonBubblingPointerOutListener,
  createEventEmitter,
  runAtThisOrScheduleAtNextAnimationFrame,
  scheduleAtNextAnimationFrame,
  addDisposableThrottledListener,
  getComputedStyle,
  getClientArea,
  Dimension,
  getTopLeftOffset,
  getDomNodePagePosition,
  StandardWindow,
  getTotalWidth,
  getContentWidth,
  getContentHeight,
  getTotalHeight,
  isAncestor,
  findParentWithClass,
  hasParentWithClass,
  isInShadowDOM,
  getShadowRoot,
  getActiveElement,
  createStyleSheet,
  createCSSRule,
  isHTMLElement,
  EventType,
  EventHelper,
  saveParentsScrollTop,
  restoreParentsScrollTop,
  trackFocus,
  append,
  reset,
  $,
  show,
  hide,
  computeScreenAwareSize,
  windowOpenNoOpener,
  animate,
  asCSSUrl,
  asCSSPropertyValue,
  ModifierKeyEmitter,
  addMatchMediaChangeListener,
  setARIAContainer,
  alert,
  status,
  ITextModelService,
  Action,
  ActionRunner,
  Separator,
  SubmenuAction,
  EmptySubmenuAction,
  ICommandService,
  CommandsRegistry,
  ContextKeyExpr,
  expressionsAreEqualWithConstantSubstitution,
  RawContextKey,
  IContextKeyService,
  SET_CONTEXT_COMMAND_ID,
  implies,
  Registry,
  ColorScheme,
  IThemeService,
  themeColorFromId,
  ThemeIcon,
  getThemeTypeSelector,
  Extensions,
  registerThemingParticipant,
  Themable,
  isIMenuItem,
  MenuId,
  IMenuService,
  MenuRegistry,
  SubmenuItemAction,
  MenuItemAction,
  KeybindingsRegistry,
  ITelemetryService,
  Command,
  EditorCommand,
  EditorAction,
  MultiEditorAction,
  registerEditorCommand,
  registerEditorAction,
  registerMultiEditorAction,
  registerEditorContribution,
  EditorExtensionsRegistry,
  UndoCommand,
  RedoCommand,
  SelectAllCommand,
  memoize,
  EventType2,
  Gesture,
  standardMouseMoveMerger,
  GlobalMouseMoveMonitor,
  Color,
  Extensions4 as Extensions2,
  asCssVariableName,
  Extensions5 as Extensions3,
  errorForeground,
  focusBorder,
  contrastBorder,
  activeContrastBorder,
  widgetShadow,
  inputBackground,
  inputForeground,
  inputBorder,
  inputActiveOptionBorder,
  inputActiveOptionBackground,
  inputActiveOptionForeground,
  inputValidationInfoBackground,
  inputValidationInfoForeground,
  inputValidationInfoBorder,
  inputValidationWarningBackground,
  inputValidationWarningForeground,
  inputValidationWarningBorder,
  inputValidationErrorBackground,
  inputValidationErrorForeground,
  inputValidationErrorBorder,
  buttonForeground,
  buttonBackground,
  buttonHoverBackground,
  badgeBackground,
  badgeForeground,
  scrollbarShadow,
  scrollbarSliderBackground,
  scrollbarSliderHoverBackground,
  scrollbarSliderActiveBackground,
  progressBarBackground,
  editorErrorBackground,
  editorErrorForeground,
  editorErrorBorder,
  editorWarningBackground,
  editorWarningForeground,
  editorWarningBorder,
  editorInfoBackground,
  editorInfoForeground,
  editorInfoBorder,
  editorHintForeground,
  editorHintBorder,
  editorBackground,
  editorForeground,
  editorWidgetBackground,
  editorWidgetForeground,
  editorWidgetBorder,
  editorWidgetResizeBorder,
  quickInputBackground,
  quickInputForeground,
  quickInputTitleBackground,
  pickerGroupForeground,
  pickerGroupBorder,
  keybindingLabelBackground,
  keybindingLabelForeground,
  keybindingLabelBorder,
  keybindingLabelBottomBorder,
  editorSelectionBackground,
  editorSelectionForeground,
  editorInactiveSelection,
  editorSelectionHighlight,
  editorFindMatch,
  editorFindMatchHighlight,
  editorFindRangeHighlight,
  editorFindMatchBorder,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlightBorder,
  defaultInsertColor,
  defaultRemoveColor,
  diffInserted,
  diffRemoved,
  diffInsertedLine,
  diffRemovedLine,
  diffInsertedLineGutter,
  diffRemovedLineGutter,
  diffOverviewRulerInserted,
  diffOverviewRulerRemoved,
  diffInsertedOutline,
  diffRemovedOutline,
  diffBorder,
  diffDiagonalFill,
  listFocusBackground,
  listFocusForeground,
  listFocusOutline,
  listActiveSelectionBackground,
  listActiveSelectionForeground,
  listActiveSelectionIconForeground,
  listInactiveSelectionBackground,
  listInactiveSelectionForeground,
  listInactiveSelectionIconForeground,
  listInactiveFocusBackground,
  listInactiveFocusOutline,
  listHoverBackground,
  listHoverForeground,
  listDropBackground,
  listFilterWidgetBackground,
  listFilterWidgetOutline,
  listFilterWidgetNoMatchesOutline,
  treeIndentGuidesStroke,
  tableColumnsBorder,
  tableOddRowsBackgroundColor,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickInputListFocusBackground,
  menuBorder,
  menuForeground,
  menuBackground,
  menuSelectionForeground,
  menuSelectionBackground,
  menuSelectionBorder,
  menuSeparatorBackground,
  toolbarHoverBackground,
  overviewRulerFindMatchForeground,
  minimapFindMatch,
  minimapSelection,
  minimapError,
  minimapWarning,
  minimapBackground,
  minimapForegroundOpacity,
  minimapSliderBackground,
  minimapSliderHoverBackground,
  minimapSliderActiveBackground,
  resolveColorValue,
  CursorColumns,
  Mimes,
  editorLineHighlight,
  editorLineHighlightBorder,
  editorCursorForeground,
  editorCursorBackground,
  editorIndentGuides,
  editorActiveIndentGuides,
  editorLineNumbers,
  editorActiveLineNumber,
  editorRuler,
  editorOverviewRulerBorder,
  editorOverviewRulerBackground,
  editorUnnecessaryCodeBorder,
  editorUnnecessaryCodeOpacity,
  overviewRulerError,
  overviewRulerWarning,
  overviewRulerInfo,
  editorBracketHighlightingForeground1,
  editorBracketHighlightingForeground2,
  editorBracketHighlightingForeground3,
  editorBracketHighlightingForeground4,
  editorBracketHighlightingForeground5,
  editorBracketHighlightingForeground6,
  editorBracketPairGuideBackground1,
  editorBracketPairGuideBackground2,
  editorBracketPairGuideBackground3,
  editorBracketPairGuideBackground4,
  editorBracketPairGuideBackground5,
  editorBracketPairGuideBackground6,
  editorBracketPairGuideActiveBackground1,
  editorBracketPairGuideActiveBackground2,
  editorBracketPairGuideActiveBackground3,
  editorBracketPairGuideActiveBackground4,
  editorBracketPairGuideActiveBackground5,
  editorBracketPairGuideActiveBackground6,
  normalizeIndentation,
  ReplaceCommand,
  ReplaceCommandWithoutChangingPosition,
  ReplaceCommandWithOffsetCursorState,
  ReplaceCommandThatPreservesSelection,
  EditorContextKeys,
  Widget,
  Scrollable,
  SmoothScrollableElement,
  DomScrollableElement,
  HorizontalGuidesState,
  IndentGuide,
  IndentGuideHorizontalLine,
  BracketPairGuidesClassNames,
  LineInjectedText,
  ModelRawContentChangedEvent,
  ModelInjectedTextChangedEvent,
  isEqualOrParent,
  normalizePath,
  DataUri,
  isEditStackElement,
  countEOL,
  IUndoRedoService,
  ResourceEditStackSnapshot,
  UndoRedoGroup,
  UndoRedoSource,
  TextModel,
  ModelDecorationOptions,
  severity_default,
  INotificationService,
  NoOpNotification,
  DomEmitter,
  stopEvent,
  Sash,
  DataTransfers,
  DragAndDropData,
  StaticDND,
  BaseActionViewItem,
  ActionViewItem,
  ActionBar,
  registerIcon,
  getIconRegistry,
  widgetClose,
  IContextViewService,
  IContextMenuService,
  IClipboardService,
  IKeybindingService,
  InputBox,
  HistoryInputBox,
  IStorageService,
  InMemoryStorageService
};
//# sourceMappingURL=chunk-5R67UFLJ.js.map
